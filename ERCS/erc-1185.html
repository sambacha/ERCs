<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Storage of DNS Records in ENS | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Storage of DNS Records in ENS | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-1185" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-1185" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Storage of DNS Records in ENS</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>This EIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.</p>

<h2 id="motivation">Motivation</h2>

<p>ENS is a highly desirable store for DNS information.  It provides the distributed authority of DNS without conflating ownership and authoritative serving of information.  With ENS, the owner of a domain has full control over their own DNS records.  Also, ENS has the ability (through smart contracts) for a domainâ€™s subdomains to be irrevocably assigned to another entity.</p>

<h2 id="specification">Specification</h2>

<p>The resolver profile to support DNS on ENS follows the resolver specification as defined in <a href="./eip-137.md">ERC-137</a>.</p>

<p>Traditionally, DNS is a zone-based system in that all of the records for a zone are kept together in the same file.  This has the benefit of simplicity and atomicity of zone updates, but when transposed to ENS can result in significant gas costs for simple changes.  As a result, the resolver works on the basis of record sets.  A record set is uniquely defined by the tuple <code class="language-plaintext highlighter-rouge">(domain, name, resource record type)</code>, for example the tuple <code class="language-plaintext highlighter-rouge">(example.com, www.example.com, A)</code> defines the record set of <code class="language-plaintext highlighter-rouge">A</code> records for the name <code class="language-plaintext highlighter-rouge">www.example.com</code> in the domain <code class="language-plaintext highlighter-rouge">example.com</code>.  A record set can contain 0 or more values, for example if <code class="language-plaintext highlighter-rouge">www.example.com</code> has <code class="language-plaintext highlighter-rouge">A</code> records <code class="language-plaintext highlighter-rouge">1.2.3.4</code> and <code class="language-plaintext highlighter-rouge">5.6.7.8</code> then the aforementioned tuple will have two values.</p>

<p>The choice to work at the level of record sets rather than zones means that this specification cannot completely support some features of DNS, such as zone transfers and DNSSEC.  It would be possible to build a different resolver profile that works at the zone level, however it would be very expensive to carry out updates and so is not considered further for this EIP.</p>

<p>The DNS resolver interface consists of two functions to set DNS information and two functions to query DNS information.</p>

<h3 id="setdnsrecordsbytes32-node-bytes-data">setDNSRecords(bytes32 node, bytes data)</h3>

<p><code class="language-plaintext highlighter-rouge">setDNSRecords()</code> sets, updates or clears 1 or more DNS records for a given node.  It has function signature <code class="language-plaintext highlighter-rouge">0x0af179d7</code>.</p>

<p>The arguments for the function are as follows:</p>

<ul>
  <li>node: the namehash of the fully-qualified domain in ENS for which to set the records.  Namehashes are defined in <a href="./eip-137.md">ERC-137</a></li>
  <li>data: 1 or more DNS records in DNS wire format.  Any record that is supplied without a value will be cleared.  Note that all records in the same RRset should be contiguous within the data; if not then the later RRsets will overwrite the earlier one(s)</li>
</ul>

<h3 id="cleardnszonebytes32-node">clearDNSZone(bytes32 node)</h3>

<p><code class="language-plaintext highlighter-rouge">clearDNSZone()</code> removes all DNS records for the domain.  It has function signature <code class="language-plaintext highlighter-rouge">0xad5780af</code>.</p>

<p>Although it is possible to clear records individually with <code class="language-plaintext highlighter-rouge">setDNSRecords()</code> as described above this requires the owner to know all of the records that have been set (as the resolver has no methods to iterate over the records for a given domain), and might require multiple transactions.  <code class="language-plaintext highlighter-rouge">clearDNSZone()</code> removes all zone information in a single operation.</p>

<p>The arguments for the function is as follows:</p>

<ul>
  <li>node: the namehash of the fully-qualified domain in ENS for which to clear the records.  Namehashes are defined in <a href="./eip-137.md">ERC-137</a></li>
</ul>

<h3 id="dnsrecordsbytes32-node-bytes32-name-uint16-resource-view-returns-bytes">dnsRecords(bytes32 node, bytes32 name, uint16 resource) view returns (bytes)</h3>

<p><code class="language-plaintext highlighter-rouge">dnsRecords()</code> obtains the DNS records for a given node, name and resource.  It has function signature <code class="language-plaintext highlighter-rouge">0x2461e851</code>.</p>

<p>The arguments for the function are as follows:</p>

<ul>
  <li>node: the namehash of the fully-qualified domain in ENS for which to set the records.  Namehashes are defined in <a href="./eip-137.md">ERC-137</a></li>
  <li>name: the <code class="language-plaintext highlighter-rouge">keccak256()</code> hash of the name of the record in DNS wire format.</li>
  <li>resource: the resource record ID.  Resource record IDs are defined in RFC1035 and subsequent RFCs.</li>
</ul>

<p>The function returns all matching records in DNS wire format.  If there are no records present the function will return nothing.</p>

<h3 id="hasdnsrecordsbytes32-node-bytes32-name-view-returns-bool">hasDNSRecords(bytes32 node, bytes32 name) view returns (bool)</h3>

<p><code class="language-plaintext highlighter-rouge">hasDNSRecords()</code> reports if there are any records for the provided name in the domain.  It has function signature <code class="language-plaintext highlighter-rouge">0x4cbf6ba4</code>.</p>

<p>This function is needed by DNS resolvers when working with wildcard resources as defined in RFC4592.</p>

<p>The arguments for the function are as follows:</p>

<ul>
  <li>node: the namehash of the fully-qualified domain in ENS for which to set the records.  Namehashes are defined in <a href="./eip-137.md">ERC-137</a></li>
  <li>name: the <code class="language-plaintext highlighter-rouge">keccak256()</code> hash of the name of the record in DNS wire format.</li>
</ul>

<p>The function returns <code class="language-plaintext highlighter-rouge">true</code> if there are any records for the provided node and name, otherwise <code class="language-plaintext highlighter-rouge">false</code>.</p>

<h2 id="rationale">Rationale</h2>

<p>DNS is a federated system of naming, and the higher-level entities control availability of everything beneath them (<em>e.g.</em> <code class="language-plaintext highlighter-rouge">.org</code> controls the availability of <code class="language-plaintext highlighter-rouge">ethereum.org</code>).  A decentralized version of DNS would not have this constraint, and allow lookups directly for any domain with relevant records within ENS.</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>Not applicable.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>The reference implementation of the DNS resolver is as follows:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.7</span><span class="p">.</span><span class="mi">4</span><span class="p">;</span>
<span class="k">import</span> <span class="s">"../ResolverBase.sol"</span><span class="p">;</span>
<span class="k">import</span> <span class="s">"@ensdomains/dnssec-oracle/contracts/RRUtils.sol"</span><span class="p">;</span>

<span class="k">abstract</span> <span class="k">contract</span> <span class="n">DNSResolver</span> <span class="k">is</span> <span class="n">ResolverBase</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">RRUtils</span> <span class="k">for</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">BytesUtils</span> <span class="k">for</span> <span class="kt">bytes</span><span class="p">;</span>

    <span class="kt">bytes4</span> <span class="k">constant</span> <span class="k">private</span> <span class="n">DNS_RECORD_INTERFACE_ID</span> <span class="o">=</span> <span class="mh">0xa8fa5682</span><span class="p">;</span>
    <span class="kt">bytes4</span> <span class="k">constant</span> <span class="k">private</span> <span class="n">DNS_ZONE_INTERFACE_ID</span> <span class="o">=</span> <span class="mh">0x5c47637c</span><span class="p">;</span>

    <span class="c1">// DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.
</span>    <span class="k">event</span> <span class="n">DNSRecordChanged</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint16</span> <span class="n">resource</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">record</span><span class="p">);</span>
    <span class="c1">// DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.
</span>    <span class="k">event</span> <span class="n">DNSRecordDeleted</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint16</span> <span class="n">resource</span><span class="p">);</span>
    <span class="c1">// DNSZoneCleared is emitted whenever a given node's zone information is cleared.
</span>    <span class="k">event</span> <span class="n">DNSZoneCleared</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">node</span><span class="p">);</span>

    <span class="c1">// DNSZonehashChanged is emitted whenever a given node's zone hash is updated.
</span>    <span class="k">event</span> <span class="n">DNSZonehashChanged</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">lastzonehash</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">zonehash</span><span class="p">);</span>

    <span class="c1">// Zone hashes for the domains.
</span>    <span class="c1">// A zone hash is an ERC-1577 content hash in binary format that should point to a
</span>    <span class="c1">// resource containing a single zonefile.
</span>    <span class="c1">// node =&gt; contenthash
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="kt">bytes</span><span class="p">)</span> <span class="k">private</span> <span class="n">zonehashes</span><span class="p">;</span>

    <span class="c1">// Version the mapping for each zone.  This allows users who have lost
</span>    <span class="c1">// track of their entries to effectively delete an entire zone by bumping
</span>    <span class="c1">// the version number.
</span>    <span class="c1">// node =&gt; version
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="kt">uint256</span><span class="p">)</span> <span class="k">private</span> <span class="n">versions</span><span class="p">;</span>

    <span class="c1">// The records themselves.  Stored as binary RRSETs
</span>    <span class="c1">// node =&gt; version =&gt; name =&gt; resource =&gt; data
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="k">mapping</span><span class="p">(</span><span class="kt">uint256</span><span class="o">=&gt;</span><span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="k">mapping</span><span class="p">(</span><span class="kt">uint16</span><span class="o">=&gt;</span><span class="kt">bytes</span><span class="p">))))</span> <span class="k">private</span> <span class="n">records</span><span class="p">;</span>

    <span class="c1">// Count of number of entries for a given name.  Required for DNS resolvers
</span>    <span class="c1">// when resolving wildcards.
</span>    <span class="c1">// node =&gt; version =&gt; name =&gt; number of records
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="k">mapping</span><span class="p">(</span><span class="kt">uint256</span><span class="o">=&gt;</span><span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span><span class="o">=&gt;</span><span class="kt">uint16</span><span class="p">)))</span> <span class="k">private</span> <span class="n">nameEntriesCount</span><span class="p">;</span>

    <span class="cm">/**
     * Set one or more DNS records.  Records are supplied in wire-format.
     * Records with the same node/name/resource must be supplied one after the
     * other to ensure the data is updated correctly. For example, if the data
     * was supplied:
     *     a.example.com IN A 1.2.3.4
     *     a.example.com IN A 5.6.7.8
     *     www.example.com IN CNAME a.example.com.
     * then this would store the two A records for a.example.com correctly as a
     * single RRSET, however if the data was supplied:
     *     a.example.com IN A 1.2.3.4
     *     www.example.com IN CNAME a.example.com.
     *     a.example.com IN A 5.6.7.8
     * then this would store the first A record, the CNAME, then the second A
     * record which would overwrite the first.
     *
     * @param node the namehash of the node for which to set the records
     * @param data the DNS wire format records to set
     */</span>
    <span class="k">function</span> <span class="n">setDNSRecords</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span> <span class="n">authorised</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint16</span> <span class="n">resource</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">uint256</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">value</span><span class="p">;</span>
        <span class="kt">bytes32</span> <span class="n">nameHash</span><span class="p">;</span>
        <span class="c1">// Iterate over the data to add the resource records
</span>        <span class="k">for</span> <span class="p">(</span><span class="n">RRUtils</span><span class="p">.</span><span class="n">RRIterator</span> <span class="k">memory</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">iterateRRs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="o">!</span><span class="n">iter</span><span class="p">.</span><span class="n">done</span><span class="p">();</span> <span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">resource</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">resource</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">dnstype</span><span class="p">;</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
                <span class="n">nameHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kt">bytes</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">rdata</span><span class="p">());</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">newName</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">resource</span> <span class="o">!=</span> <span class="n">iter</span><span class="p">.</span><span class="n">dnstype</span> <span class="o">||</span> <span class="o">!</span><span class="n">name</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">newName</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">setDNSRRSet</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resource</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">resource</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">dnstype</span><span class="p">;</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">newName</span><span class="p">;</span>
                    <span class="n">nameHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kt">bytes</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">rdata</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">setDNSRRSet</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resource</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Obtain a DNS record.
     * @param node the namehash of the node for which to fetch the record
     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record
     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types
     * @return the DNS record in wire format if present, otherwise empty
     */</span>
    <span class="k">function</span> <span class="n">dnsRecord</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint16</span> <span class="n">resource</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">records</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">versions</span><span class="p">[</span><span class="n">node</span><span class="p">]][</span><span class="n">name</span><span class="p">][</span><span class="n">resource</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Check if a given node has records.
     * @param node the namehash of the node for which to check the records
     * @param name the namehash of the node for which to check the records
     */</span>
    <span class="k">function</span> <span class="n">hasDNSRecords</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">name</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">nameEntriesCount</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">versions</span><span class="p">[</span><span class="n">node</span><span class="p">]][</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * Clear all information for a DNS zone.
     * @param node the namehash of the node for which to clear the zone
     */</span>
    <span class="k">function</span> <span class="n">clearDNSZone</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">)</span> <span class="k">public</span> <span class="n">authorised</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">versions</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="k">emit</span> <span class="n">DNSZoneCleared</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * setZonehash sets the hash for the zone.
     * May only be called by the owner of that node in the ENS registry.
     * @param node The node to update.
     * @param hash The zonehash to set
     */</span>
    <span class="k">function</span> <span class="n">setZonehash</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">hash</span><span class="p">)</span> <span class="k">external</span> <span class="n">authorised</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">oldhash</span> <span class="o">=</span> <span class="n">zonehashes</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
        <span class="n">zonehashes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
        <span class="k">emit</span> <span class="n">DNSZonehashChanged</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">oldhash</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/**
     * zonehash obtains the hash for the zone.
     * @param node The ENS node to query.
     * @return The associated contenthash.
     */</span>
    <span class="k">function</span> <span class="n">zonehash</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">node</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">zonehashes</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">supportsInterface</span><span class="p">(</span><span class="kt">bytes4</span> <span class="n">interfaceID</span><span class="p">)</span> <span class="k">virtual</span> <span class="k">override</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">interfaceID</span> <span class="o">==</span> <span class="n">DNS_RECORD_INTERFACE_ID</span> <span class="o">||</span>
               <span class="n">interfaceID</span> <span class="o">==</span> <span class="n">DNS_ZONE_INTERFACE_ID</span> <span class="o">||</span>
               <span class="nb">super</span><span class="p">.</span><span class="n">supportsInterface</span><span class="p">(</span><span class="n">interfaceID</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">setDNSRRSet</span><span class="p">(</span>
        <span class="kt">bytes32</span> <span class="n">node</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">name</span><span class="p">,</span>
        <span class="kt">uint16</span> <span class="n">resource</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">offset</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">size</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">deleteRecord</span><span class="p">)</span> <span class="k">private</span>
    <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">version</span> <span class="o">=</span> <span class="n">versions</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
        <span class="kt">bytes32</span> <span class="n">nameHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">rrData</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">substring</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">deleteRecord</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">records</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">][</span><span class="n">resource</span><span class="p">].</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nameEntriesCount</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">delete</span><span class="p">(</span><span class="n">records</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">][</span><span class="n">resource</span><span class="p">]);</span>
            <span class="k">emit</span> <span class="n">DNSRecordDeleted</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resource</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">records</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">][</span><span class="n">resource</span><span class="p">].</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nameEntriesCount</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">records</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">nameHash</span><span class="p">][</span><span class="n">resource</span><span class="p">]</span> <span class="o">=</span> <span class="n">rrData</span><span class="p">;</span>
            <span class="k">emit</span> <span class="n">DNSRecordChanged</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resource</span><span class="p">,</span> <span class="n">rrData</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="security-considerations">Security Considerations</h2>

<p>Security of this solution would be dependent on security of the records within the ENS domain.  This degenenrates to the security of the key(s) which have authority over that domain.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
