<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Ethereum Verifiable Claims | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Ethereum Verifiable Claims | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-1812" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-1812" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Ethereum Verifiable Claims</h1>
  </header>

  <div class="post-content">
    <h1 id="ethereum-verifiable-claims">Ethereum Verifiable Claims</h1>

<h2 id="simple-summary">Simple Summary</h2>

<p>Reusable Verifiable Claims using <a href="./eip-712.md">EIP 712 Signed Typed Data</a>.</p>

<h2 id="abstract">Abstract</h2>
<p>A new method for Off-Chain Verifiable Claims built on <a href="./eip-712.md">EIP-712</a>. These Claims can be issued by any user with a EIP 712 compatible web3 provider. Claims can be stored off chain and verified on-chain by Solidity Smart Contracts, State Channel Implementations or off-chain libraries.</p>

<h2 id="motivation">Motivation</h2>
<p>Reusable Off-Chain Verifiable Claims provide an important piece of integrating smart contracts with real world organizational requirements such as meeting regulatory requirements such as KYC, GDPR, Accredited Investor rules etc.</p>

<p><a href="https://github.com/ethereum/EIPs/issues/735">ERC-735</a> and <a href="https://github.com/ethereum/EIPs/issues/780">ERC-780</a> provide methods of making claims that live on chain. This is useful for some particular use cases, where some claim about an address must be verified on chain.</p>

<p>In most cases though it is both dangerous and in some cases illegal (according to EU GDPR rules for example) to record Identity Claims containing Personal Identifying Information (PII) on an immutable public database such as the Ethereum blockchain.</p>

<p>The W3C <a href="https://www.w3.org/TR/verifiable-claims-data-model/">Verifiable Claims Data Model and Representations</a> as well as uPorts <a href="https://developer.uport.me/messages/verification">Verification Message Spec</a> are proposed off-chain solutions.</p>

<p>While built on industry standards such as <a href="https://json-ld.org">JSON-LD</a> and <a href="https://jwt.io">JWT</a> neither of them are easy to integrate with the Ethereum ecosystem.</p>

<p><a href="./eip-712.md">EIP-712</a> introduces a new method of signing off chain Identity data. This provides both a data format based on Solidity ABI encoding that can easily be parsed on-chain an a new JSON-RPC call that is easily supported by existing Ethereum wallets and Web3 clients.</p>

<p>This format  allows reusable off-chain Verifiable Claims to be cheaply issued to users, who can present them when needed.</p>

<h2 id="prior-art">Prior Art</h2>
<p>Verified Identity Claims such as those proposed by <a href="https://developer.uport.me/messages/verification">uPort</a> and <a href="https://www.w3.org/2017/vc/WG/">W3C Verifiable Claims Working Group</a> form an important part of building up reusable identity claims.</p>

<p><a href="https://github.com/ethereum/EIPs/issues/735">ERC-735</a> and <a href="https://github.com/ethereum/EIPs/issues/780">ERC-780</a> provide on-chain storage and lookups of Verifiable Claims.</p>

<h2 id="specification">Specification</h2>
<h3 id="claims">Claims</h3>
<p>Claims can be generalized like this:</p>

<blockquote>
  <p>Issuer makes the claim that Subject is something or has some attribute and value.</p>
</blockquote>

<p>Claims should be deterministic, in that the same claim signed multiple times by the same signer.</p>

<h3 id="claims-data-structure">Claims data structure</h3>
<p>Each claim should be typed based on its specific use case, which EIP 712 lets us do effortlessly. But there are 3 minimal attributes required of the claims structure.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">subject</code> the subject of the claim as an <code class="language-plaintext highlighter-rouge">address</code> (who the claim is about)</li>
  <li><code class="language-plaintext highlighter-rouge">validFrom</code> the time in seconds encoded as a <code class="language-plaintext highlighter-rouge">uint256</code> of start of validity of claim. In most cases this would be the time of issuance, but some claims may be valid in the future or past.</li>
  <li><code class="language-plaintext highlighter-rouge">validTo</code> the time in seconds encoded as a <code class="language-plaintext highlighter-rouge">uint256</code> of when the validity of  the claim expires. If you intend for the claim not to expire use <code class="language-plaintext highlighter-rouge">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code>.</li>
</ul>

<p>The basic minimal claim data structure as a Solidity struct:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">[</span><span class="n">CLAIM</span> <span class="n">TYPE</span><span class="p">]</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The CLAIM TYPE is the actual name of the claim. While not required, in most cases use the taxonomy developed by <a href="https://schema.org/docs/full.html">schema.org</a> which is also commonly used in other Verifiable Claims formats.</p>

<p>Example claim that issuer knows a subject:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Know</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="presenting-a-verifiable-claim">Presenting a Verifiable Claim</h3>
<h4 id="verifying-contract">Verifying Contract</h4>
<p>When defining Verifiable Claims formats a Verifying Contract should be created with a public <code class="language-plaintext highlighter-rouge">verify()</code>  view function. This makes it very easy for other smart contracts to verify a claim correctly.</p>

<p>It also provides a convenient interface for web3 and state channel apps to verify claims securely.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">verifyIssuer</span><span class="p">(</span><span class="n">Know</span> <span class="k">memory</span> <span class="n">claim</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">v</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">r</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">s</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">bytes32</span> <span class="n">digest</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span>
	  <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span>
	    <span class="s">"</span><span class="se">\x19\x01</span><span class="s">"</span><span class="p">,</span>
	    <span class="n">DOMAIN_SEPARATOR</span><span class="p">,</span>
	    <span class="n">hash</span><span class="p">(</span><span class="n">claim</span><span class="p">)</span>
	  <span class="p">)</span>
	<span class="p">);</span>
	<span class="nb">require</span><span class="p">(</span>
		<span class="p">(</span><span class="n">claim</span><span class="p">.</span><span class="n">validFrom</span> <span class="o">&gt;=</span> <span class="n">block</span><span class="p">.</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">claim</span><span class="p">.</span><span class="n">validTo</span><span class="p">)</span>
<span class="p">,</span> <span class="s">"invalid issuance timestamps"</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">ecrecover</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="calling-a-smartcontract-function">Calling a SmartContract function</h4>
<p>Verifiable Claims can be presented to a solidity function call as it’s struct together with the <code class="language-plaintext highlighter-rouge">v</code>, <code class="language-plaintext highlighter-rouge">r</code> and <code class="language-plaintext highlighter-rouge">s</code> signature components.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">vouch</span><span class="p">(</span><span class="n">Know</span> <span class="k">memory</span> <span class="n">claim</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">v</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">r</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">s</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span> <span class="o">=</span> <span class="n">verifier</span><span class="p">.</span><span class="n">verifyIssuer</span><span class="p">(</span><span class="n">claim</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="nb">require</span><span class="p">(</span><span class="n">issuer</span> <span class="o">!==</span> <span class="s">'0x0'</span><span class="p">);</span>
	<span class="n">knows</span><span class="p">[</span><span class="n">issuer</span><span class="p">][</span><span class="n">claim</span><span class="p">.</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="embedding-a-verifiable-claim-in-another-signed-typed-data--structure">Embedding a Verifiable Claim in another Signed Typed Data  structure</h4>
<p>The Claim struct should be embedded in another struct together with the <code class="language-plaintext highlighter-rouge">v</code>, <code class="language-plaintext highlighter-rouge">r</code> and <code class="language-plaintext highlighter-rouge">s</code> signature parameters.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Know</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">VerifiableReference</span> <span class="p">{</span>
	<span class="n">Know</span> <span class="n">delegate</span><span class="p">;</span>
	<span class="kt">uint8</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Introduction</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">recipient</span><span class="p">;</span>
	<span class="n">VerifiableReference</span> <span class="n">issuer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each Verifiable Claim should be individually verified  together with the parent Signed Typed Data structure.</p>

<p>Verifiable Claims issued to different EIP 712 Domains can be embedded within each other.</p>

<h4 id="state-channels">State Channels</h4>
<p>This proposal will not show how to use Eth Verifiable Claims  as part of a specific State Channel method.</p>

<p>Any State Channel based on EIP712 should be able to include the embeddable Verifiable Claims as part of its protocol. This could be useful for exchanging private Identity Claims between the parties for regulatory reasons, while ultimately not posting them to the blockchain on conclusion of a channel.</p>

<h3 id="key-delegation">Key Delegation</h3>
<p>In most simple cases the issuer of a Claim is the signer of the data. There are cases however where signing should be delegated to an intermediary key.</p>

<p>KeyDelegation can be used to implement off chain signing for smart contract based addresses, server side key rotation as well as employee permissions in complex  business use cases.</p>

<h4 id="erc1056-signing-delegation">ERC1056 Signing Delegation</h4>

<p><a href="./eip-1056.md">ERC-1056</a> provides a method for addresses to assign delegate signers. One of the primary use cases for this is that a smart contract can allow a key pair to sign on its behalf for a certain period. It also allows server based issuance tools to institute key rotation.</p>

<p>To support this an additional <code class="language-plaintext highlighter-rouge">issuer</code> attribute can be added to the Claim Type struct. In this case the verification code should lookup the EthereumDIDRegistry to see if the signer of the data is an allowed signing delegate for the <code class="language-plaintext highlighter-rouge">issuer</code></p>

<p>The following is the minimal struct for a Claim containing an issuer:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">[</span><span class="n">CLAIM</span> <span class="n">TYPE</span><span class="p">]</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
  <span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the <code class="language-plaintext highlighter-rouge">issuer</code> is specified in the struct In addition to performing the standard ERC712 verification the verification code MUST also verify that the signing address is a valid <code class="language-plaintext highlighter-rouge">veriKey</code> delegate for the address specified in the issuer.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">registry</span><span class="p">.</span><span class="n">validDelegate</span><span class="p">(</span><span class="n">issuer</span><span class="p">,</span> <span class="s">'veriKey'</span><span class="p">,</span> <span class="n">recoveredAddress</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="embedded-delegation-proof">Embedded Delegation Proof</h4>
<p>There may be applications, in particularly where organizations want to allow delegates to issue claims about specific domains and types.</p>

<p>For this purpose instead of the <code class="language-plaintext highlighter-rouge">issuer</code> we allow a special claim to be embedded following this same format:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Delegate</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">VerifiableDelegate</span> <span class="p">{</span>
	<span class="n">Delegate</span> <span class="n">delegate</span><span class="p">;</span>
	<span class="kt">uint8</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="p">[</span><span class="n">CLAIM</span> <span class="n">TYPE</span><span class="p">]</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="n">VerifiedDelegate</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Delegates should be created for specific EIP 712 Domains and not be reused across Domains.</p>

<p>Implementers of new EIP 712 Domains can add further data to the <code class="language-plaintext highlighter-rouge">Delegate</code> struct to allow finer grained application specific rules to it.</p>

<h3 id="claim-types">Claim Types</h3>
<h4 id="binary-claims">Binary Claims</h4>
<p>A Binary claim is something that doesn’t have a particular value. It either is issued or not.</p>

<p>Examples:</p>
<ul>
  <li>subject is a Person</li>
  <li>subject is my owner (eg. Linking an ethereum account to an owner identity)</li>
</ul>

<p>Example:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is exactly the same as the minimal claim above with the CLAIM TYPE set to <a href="https://schema.org/Person">Person</a>.</p>

<h3 id="value-claims">Value Claims</h3>
<p>Value claims can be used to make a claim about the subject containing a specific readable value.</p>

<p><strong>WARNING</strong>: Be very careful about  using Value Claims  as part of Smart Contract transactions. Identity Claims containing values could be a GDPR violation for the business or developer encouraging a user to post it to a public blockchain.</p>

<p>Examples:</p>
<ul>
  <li>subject’s name is Alice</li>
  <li>subjects average account balance is 1234555</li>
</ul>

<p>Each value should use the <code class="language-plaintext highlighter-rouge">value</code> field to indicate the value.</p>

<p>A Name Claim</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Average Balance</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AverageBalance</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="hashed-claims">Hashed Claims</h3>
<p>Hashed claims can be used to make a claim about the subject containing the hash of a claim value. Hashes should use ethereum standard <code class="language-plaintext highlighter-rouge">keccak256</code> hashing function.</p>

<p><strong>WARNING</strong>: Be very careful about  using Hashed Claims  as part of Smart Contract transactions. Identity Claims containing hashes of known values could be a GDPR violation for the business or developer encouraging a user to post it to a public blockchain.</p>

<p>Examples:</p>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />hash of subject’s name is <code class="language-plaintext highlighter-rouge">keccak256(“Alice Torres”)</code></li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />hash of subject’s email is <code class="language-plaintext highlighter-rouge">keccak256(“alice@example.com”)</code></li>
</ul>

<p>Each value should use the <code class="language-plaintext highlighter-rouge">keccak256 </code> field to indicate the hashed value. Question. The choice of using this name  is that we can easily add support for future algorithms as well as maybe zkSnark proofs.</p>

<p>A Name Claim</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Name</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="nb">keccak256</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Email Claim</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Email</span> <span class="p">{</span>
	<span class="kt">address</span> <span class="n">issuer</span><span class="p">;</span>
	<span class="kt">address</span> <span class="n">subject</span><span class="p">;</span>
	<span class="kt">bytes32</span> <span class="nb">keccak256</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validFrom</span><span class="p">;</span>
	<span class="kt">uint256</span> <span class="n">validTo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="eip-712-domain">EIP 712 Domain</h3>
<p>The EIP 712 Domain specifies what kind of message that is to be signed and is used to differentiate between signed data types. The content MUST contain the following:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">name</span><span class="o">:</span> <span class="s">"EIP1???Claim"</span><span class="p">,</span>
  <span class="n">version</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">chainId</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// for mainnet
</span>  <span class="n">verifyingContract</span><span class="o">:</span> <span class="mi">0</span><span class="n">x</span> <span class="c1">// TBD
</span>  <span class="n">salt</span><span class="o">:</span> <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="full-combined-format-for-eip-712-signing">Full Combined format for EIP 712 signing:</h4>

<p>Following the EIP 712 standard we can combine the Claim Type with the EIP 712 Domain and the claim itself (in the <code class="language-plaintext highlighter-rouge">message</code>)  attribute.</p>

<p>Eg:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
    <span class="s">"types"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s">"EIP712Domain"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"string"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"version"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"string"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"chainId"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"uint256"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"verifyingContract"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"address"</span>
        <span class="p">}</span>
      <span class="p">],</span>
      <span class="s">"Email"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span> 
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"subject"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"address"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"keccak256"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"bytes32"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"validFrom"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"uint256"</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s">"name"</span><span class="o">:</span> <span class="s">"validTo"</span><span class="p">,</span>
          <span class="s">"type"</span><span class="o">:</span> <span class="s">"uint256"</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="s">"primaryType"</span><span class="o">:</span> <span class="s">"Email"</span><span class="p">,</span>
    <span class="s">"domain"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s">"name"</span><span class="o">:</span> <span class="s">"EIP1??? Claim"</span><span class="p">,</span>
      <span class="s">"version"</span><span class="o">:</span> <span class="s">"1"</span><span class="p">,</span>
      <span class="s">"chainId"</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="s">"verifyingContract"</span><span class="o">:</span> <span class="s">"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"</span>
    <span class="p">},</span>
    <span class="s">"message"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s">"subject"</span><span class="o">:</span> <span class="s">"0x5792e817336f41de1d8f54feab4bc200624a1d9d"</span><span class="p">,</span>
      <span class="s">"value"</span><span class="o">:</span> <span class="s">"9c8465d9ae0b0bc167dee7f62880034f59313100a638dcc86a901956ea52e280"</span><span class="p">,</span>
      <span class="s">"validFrom"</span><span class="o">:</span> <span class="s">"0x0000000000000000000000000000000000000000000000000001644b74c2a0"</span><span class="p">,</span>
      <span class="s">"validTo"</span><span class="o">:</span> <span class="s">"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<h3 id="revocation">Revocation</h3>
<p>Both Issuers and Subjects should be allowed to revoke Verifiable Claims. Revocations can be handled through a simple on-chain registry.</p>

<p>The ultimate rules of who should be able to revoke a claim is determined by the Verifying contract.</p>

<p>The <code class="language-plaintext highlighter-rouge">digest</code> used for revocation is the EIP712 Signed Typed Data digest.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">RevocationRegistry</span> <span class="p">{</span>
  <span class="k">mapping</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">))</span> <span class="k">public</span> <span class="n">revocations</span><span class="p">;</span>

  <span class="k">function</span> <span class="n">revoke</span><span class="p">(</span><span class="kt">bytes32</span> <span class="n">digest</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">revocations</span><span class="p">[</span><span class="n">digest</span><span class="p">][</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="n">revoked</span><span class="p">(</span><span class="kt">address</span> <span class="n">party</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">digest</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">revocations</span><span class="p">[</span><span class="n">digest</span><span class="p">][</span><span class="n">party</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A verifying contract can query the Revocation Registry as such:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes32</span> <span class="n">digest</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span>
  <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span>
    <span class="s">"</span><span class="se">\x19\x01</span><span class="s">"</span><span class="p">,</span>
    <span class="n">DOMAIN_SEPARATOR</span><span class="p">,</span>
    <span class="n">hash</span><span class="p">(</span><span class="n">claim</span><span class="p">)</span>
  <span class="p">)</span>
<span class="p">);</span>
<span class="nb">require</span><span class="p">(</span><span class="n">valid</span><span class="p">(</span><span class="n">claim</span><span class="p">.</span><span class="n">validFrom</span><span class="p">,</span> <span class="n">claim</span><span class="p">.</span><span class="n">validTo</span><span class="p">),</span> <span class="s">"invalid issuance timestamps"</span><span class="p">);</span>
<span class="kt">address</span> <span class="n">issuer</span> <span class="o">=</span> <span class="nb">ecrecover</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="n">revocations</span><span class="p">.</span><span class="n">revoked</span><span class="p">(</span><span class="n">issuer</span><span class="p">,</span> <span class="n">digest</span><span class="p">),</span> <span class="s">"claim was revoked by issuer"</span><span class="p">);</span>
<span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="n">revocations</span><span class="p">.</span><span class="n">revoked</span><span class="p">(</span><span class="n">claim</span><span class="p">.</span><span class="n">subject</span><span class="p">,</span> <span class="n">digest</span><span class="p">),</span> <span class="s">"claim was revoked by subject"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="creation-of-verifiable-claims-domains">Creation of Verifiable Claims Domains</h3>

<p>Creating specific is Verifiable Claims Domains is out of the scope of this EIP.   The Example Code has a few examples.</p>

<p>EIP’s or another process could be used to standardize specific important Domains that are universally useful across the Ethereum world.</p>

<h2 id="rationale">Rationale</h2>
<p>Signed Typed Data provides a strong foundation for Verifiable Claims that can be used in many different kinds of applications built on both Layer 1 and Layer 2 of Ethereum.</p>

<h3 id="rationale-for-using-not-using-a-single-eip-712-domain">Rationale for using not using a single EIP 712 Domain</h3>
<p>EIP712 supports complex types and domains in itself, that we believe are perfect building blocks for building Verifiable Claims for specific purposes.</p>

<p>The Type and Domain of a Claim is itself an important part of a claim and ensures that Verifiable Claims are used for the specific purposes required and not misused.</p>

<p>EIP712 Domains also allow rapid experimentation, allowing taxonomies to be built up by the community.</p>

<h2 id="test-cases">Test Cases</h2>
<p>There is a repo with a few example verifiers and consuming smart contracts written in Solidity:</p>

<p><strong>Example Verifiers</strong></p>
<ul>
  <li><a href="https://github.com/uport-project/eip712-claims-experiments/blob/master/contracts/IdentityClaimsVerifier.sol">Verifier for very simple IdVerification Verifiable Claims containing minimal Personal Data</a></li>
  <li><a href="https://github.com/uport-project/eip712-claims-experiments/blob/master/contracts/OwnershipProofVerifier.sol">Verifier for OwnershipProofs signed by a users wallet</a></li>
</ul>

<p><strong>Example Smart Contracts</strong></p>
<ul>
  <li><a href="https://github.com/uport-project/eip712-claims-experiments/blob/master/contracts/KYCCoin.sol">KYCCoin.sol</a> - Example Token allows reusable IdVerification claims issued by trusted verifiers and users to whitelist their own addresses using OwnershipProofs</li>
  <li><a href="https://github.com/uport-project/eip712-claims-experiments/blob/master/contracts/ConsortiumAgreements.sol">ConsortiumAgreement.sol</a> - Example Consortium Agreement smart contract. Consortium Members can issue Delegated Claims to employees or servers to interact on their behalf.</li>
</ul>

<p><strong>Shared Registries</strong></p>
<ul>
  <li><a href="https://github.com/uport-project/eip712-claims-experiments/blob/master/contracts/RevocationRegistry.sol">RevocationRegistry.sol</a></li>
</ul>

<h2 id="copyright">Copyright</h2>
<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
