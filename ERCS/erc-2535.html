<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Diamonds, Multi-Facet Proxy | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Diamonds, Multi-Facet Proxy | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-2535" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-2535" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Diamonds, Multi-Facet Proxy</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p><img align="right" src="../assets/eip-2535/diamond.svg" width="230" height="230" alt="Diamonds contract structure" /></p>

<p>This proposal standardizes diamonds, which are modular smart contract systems that can be upgraded/extended after deployment, and have virtually no size limit. More technically, a <strong>diamond</strong> is a contract with external functions that are supplied by contracts called <strong>facets</strong>. Facets are separate, independent contracts that can share internal functions, libraries, and state variables.</p>

<h2 id="motivation">Motivation</h2>

<p>There are a number of different reasons to use diamonds. Here are some of them:</p>

<ol>
  <li><strong>A single address for unlimited contract functionality.</strong> Using a single address for contract functionality makes deployment, testing and integration with other smart contracts, software and user interfaces easier.</li>
  <li><strong>Your contract exceeds the 24KB maximum contract size.</strong> You may have related functionality that it makes sense to keep in a single contract, or at a single contract address. A diamond does not have a max contract size.</li>
  <li><strong>A diamond provides a way to organize contract code and data.</strong> You may want to build a contract system with a lot of functionality. A diamond provides a systematic way to isolate different functionality and connect them together and share data between them as needed in a gas-efficient way.</li>
  <li><strong>A diamond provides a way to upgrade functionality.</strong> Upgradeable diamonds can be upgraded to add/replace/remove functionality. Because diamonds have no max contract size, there is no limit to the amount of functionality that can be added to diamonds over time. Diamonds can be upgraded without having to redeploy existing functionality. Parts of a diamond can be added/replaced/removed while leaving other parts alone.</li>
  <li><strong>A diamond can be immutable.</strong> It is possible to deploy an immutable diamond or make an upgradeable diamond immutable at a later time.</li>
  <li><strong>A diamond can reuse deployed contracts.</strong> Instead of deploying contracts to a blockchain, existing already deployed, onchain contracts can be used to create diamonds. Custom diamonds can be created from existing deployed contracts. This enables the creation of on-chain smart contract platforms and libraries.</li>
</ol>

<p>This standard is an improvement of <a href="./eip-1538.md">EIP-1538</a>. The same motivations of that standard apply to this standard.</p>

<p>A deployed facet can be used by any number of diamonds.</p>

<p>The diagram below shows two diamonds using the same two facets.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FacetA</code> is used by <code class="language-plaintext highlighter-rouge">Diamond1</code></li>
  <li><code class="language-plaintext highlighter-rouge">FacetA</code> is used by <code class="language-plaintext highlighter-rouge">Diamond2</code></li>
  <li><code class="language-plaintext highlighter-rouge">FacetB</code> is used by <code class="language-plaintext highlighter-rouge">Diamond1</code></li>
  <li><code class="language-plaintext highlighter-rouge">FacetB</code> is used by <code class="language-plaintext highlighter-rouge">Diamond2</code></li>
</ul>

<p><img src="../assets/eip-2535/facetreuse.png" alt="Facet reuse" /></p>

<h3 id="upgradeable-diamond-vs-centralized-private-database">Upgradeable Diamond vs. Centralized Private Database</h3>

<p>Why have an upgradeable diamond instead of a centralized, private, mutable database?</p>

<ol>
  <li>Decentralized Autonomous Organizations (DAOs) and other governance systems can be used to upgrade diamonds.</li>
  <li>Wide interaction and integration with the Ethereum ecosystem.</li>
  <li>With open storage data and verified source code it is possible to show a provable history of trustworthiness.</li>
  <li>With openness bad behavior can be spotted and reported when it happens.</li>
  <li>Independent security and domain experts can review the change history of contracts and vouch for their history of trustworthiness.</li>
  <li>It is possible for an upgradeable diamond to become immutable and trustless.</li>
</ol>

<h3 id="some-diamond-benefits">Some Diamond Benefits</h3>

<ol>
  <li>A stable contract address that provides needed functionality.</li>
  <li>A single address with the functionality of multiple contracts (facets) that are independent from each other but can share internal functions, libraries and state variables.</li>
  <li>Emitting events from a single address can simplify event handling.</li>
  <li>A way to add, replace and remove multiple external functions atomically (in the same transaction).</li>
  <li>Fine-grained upgrades, so you can change just the parts of a diamond that need to be changed.</li>
  <li>Have greater control over when and what functions exist.</li>
  <li>Decentralized Autonomous Organizations (DAOs), multisig contracts and other governance systems can be used to upgrade diamonds.</li>
  <li>An event that shows what functions are added, replaced and removed.</li>
  <li>The ability to show all changes made to a diamond.</li>
  <li>Increase trust over time by showing all changes made to a diamond.</li>
  <li>A way to look at a diamond to see its current facets and functions.</li>
  <li>Have an immutable, trustless diamond.</li>
  <li>Solves the 24KB maximum contract size limitation. Diamonds can be any size.</li>
  <li>Separate functionality can be implemented in separate facets and used together in a diamond.</li>
  <li>Diamonds can be created from already deployed, existing onchain contracts.</li>
  <li>Larger contracts have to reduce their size by removing error messages and other things. You can keep your full functionality that you need by implementing a diamond.</li>
  <li>Enables zero, partial or full diamond immutability as desired, and when desired.</li>
  <li>The ability to develop and improve an application over time with an upgradeable diamond and then make it immutable and trustless if desired.</li>
  <li>Develop incrementally and let your diamond grow with your application.</li>
  <li>Upgrade diamonds to fix bugs, add functionality and implement new standards.</li>
  <li>Organize your code with a diamond and facets.</li>
  <li>Diamonds can be large (have many functions) but still be modular because they are compartmented with facets.</li>
  <li>Contract architectures that call multiple contracts in a single transaction can save gas by condensing those contracts into a single diamond and accessing state variables directly.</li>
  <li>Save gas by converting external functions to internal functions. This done by sharing internal functions between facets.</li>
  <li>Save gas by creating external functions for gas-optimized specific use cases, such as bulk transfers.</li>
  <li>Diamonds are designed for tooling and user-interface software.</li>
</ol>

<h2 id="specification">Specification</h2>

<h3 id="terms">Terms</h3>

<ol>
  <li>A <strong>diamond</strong> is a facade smart contract that <code class="language-plaintext highlighter-rouge">delegatecall</code>s into its facets to execute function calls. A diamond is stateful. Data is stored in the contract storage of a diamond.</li>
  <li>A <strong>facet</strong> is a stateless smart contract or Solidity library with external functions. A facet is deployed and one or more of its functions are added to one or more diamonds. A facet does not store data within its own contract storage but it can define state and read and write to the storage of one or more diamonds. The term facet comes from the diamond industry. It is a side, or flat surface of a diamond.</li>
  <li>A <strong>loupe facet</strong> is a facet that provides introspection functions. In the diamond industry, a loupe is a magnifying glass that is used to look at diamonds.</li>
  <li>An <strong>immutable function</strong> is an external function that cannot be replaced or removed (because it is defined directly in the diamond, or because the diamond’s logic does not allow it to be modified).</li>
  <li>A <strong>mapping</strong> for the purposes of this EIP is an association between two things and does not refer to a specific implementation.</li>
</ol>

<p>The term <strong>contract</strong> is used loosely to mean a smart contract or deployed Solidity library.</p>

<p>When this EIP uses <strong>function</strong> without specifying internal or external, it means external function.</p>

<p>In this EIP the information that applies to external functions also applies to public functions.</p>

<h3 id="overview">Overview</h3>

<p>A diamond calls functions from its facets using <code class="language-plaintext highlighter-rouge">delegatecall</code>.</p>

<p>In the diamond industry diamonds are created and shaped by being cut, creating facets. In this standard diamonds are cut by adding, replacing or removing functions from facets.</p>

<h3 id="a-note-on-implementing-interfaces">A Note on Implementing Interfaces</h3>

<p>Because of the nature of diamonds, a diamond can implement an interface in one of two ways: directly (<code class="language-plaintext highlighter-rouge">contract Contract is Interface</code>), or by adding functions to it from one or more facets. For the purposes of this proposal, when a diamond is said to implement an interface, either method of implementation is permitted.</p>

<h3 id="fallback-function">Fallback Function</h3>

<p>When an external function is called on a diamond its fallback function is executed. The fallback function determines which facet to call based on the first four bytes of the call data (known as the function selector) and executes that function from the facet using <code class="language-plaintext highlighter-rouge">delegatecall</code>.</p>

<p>A diamond’s fallback function and <code class="language-plaintext highlighter-rouge">delegatecall</code> enable a diamond to execute a facet’s function as if it was implemented by the diamond itself. The <code class="language-plaintext highlighter-rouge">msg.sender</code> and <code class="language-plaintext highlighter-rouge">msg.value</code> values do not change and only the diamond’s storage is read and written to.</p>

<p>Here is an illustrative example of how a diamond’s fallback function might be implemented:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Find facet for function that is called and execute the
// function if a facet is found and return any value.
</span><span class="k">fallback</span><span class="p">()</span> <span class="k">external</span> <span class="k">payable</span> <span class="p">{</span>
  <span class="c1">// get facet from function selector
</span>  <span class="kt">address</span> <span class="n">facet</span> <span class="o">=</span> <span class="n">selectorTofacet</span><span class="p">[</span><span class="n">msg</span><span class="p">.</span><span class="n">sig</span><span class="p">];</span>
  <span class="nb">require</span><span class="p">(</span><span class="n">facet</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="c1">// Execute external function from facet using delegatecall and return any value.
</span>  <span class="k">assembly</span> <span class="p">{</span>
    <span class="c1">// copy function selector and any arguments
</span>    <span class="n">calldatacopy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">calldatasize</span><span class="p">())</span>
    <span class="c1">// execute function call using the facet
</span>    <span class="kr">let</span> <span class="n">result</span> <span class="o">:=</span> <span class="nb">delegatecall</span><span class="p">(</span><span class="n">gas</span><span class="p">(),</span> <span class="n">facet</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">calldatasize</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">// get any return value
</span>    <span class="n">returndatacopy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">returndatasize</span><span class="p">())</span>
    <span class="c1">// return any return value or error back to the caller
</span>    <span class="kr">switch</span> <span class="n">result</span>
      <span class="kr">case</span> <span class="mi">0</span> <span class="p">{</span><span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">returndatasize</span><span class="p">())}</span>
      <span class="kr">default</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">returndatasize</span><span class="p">())}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This diagram shows the structure of a diamond:</p>

<p><img src="../assets/eip-2535/DiamondDiagram.png" alt="Mapping facets and storage" /></p>

<h3 id="storage">Storage</h3>

<p>A state variable or storage layout organizational pattern is needed because Solidity’s builtin storage layout system doesn’t support proxy contracts or diamonds. The particular layout of storage is not defined in this EIP, but may be defined by later proposals. Examples of storage layout patterns that work with diamonds are <a href="../assets/eip-2535/storage-examples/DiamondStorage.sol">Diamond Storage</a> and <a href="../assets/eip-2535/storage-examples/AppStorage.sol">AppStorage</a>.</p>

<p>Facets can share state variables by using the same structs at the same storage positions. Facets can share internal functions and libraries by inheriting the same contracts or using the same libraries. In these ways facets are separate, independent units but can share state and functionality.</p>

<p>The diagram below shows facets with their own data and data shared between them.</p>

<p>Notice that all data is stored in the diamond’s storage, but different facets have different access to data.</p>

<p>In this diagram</p>

<ul>
  <li>Only <code class="language-plaintext highlighter-rouge">FacetA</code> can access <code class="language-plaintext highlighter-rouge">DataA</code></li>
  <li>Only <code class="language-plaintext highlighter-rouge">FacetB</code> can access <code class="language-plaintext highlighter-rouge">DataB</code></li>
  <li>Only the diamond’s own code can access <code class="language-plaintext highlighter-rouge">DataD</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">FacetA</code> and <code class="language-plaintext highlighter-rouge">FacetB</code> share access to <code class="language-plaintext highlighter-rouge">DataAB</code>.</li>
  <li>The diamond’s own code, <code class="language-plaintext highlighter-rouge">FacetA</code> and <code class="language-plaintext highlighter-rouge">FacetB</code> share access to <code class="language-plaintext highlighter-rouge">DataABD</code>.</li>
</ul>

<p><img src="../assets/eip-2535/diamondstorage1.png" alt="Mapping code, data, and facets" /></p>

<h3 id="solidity-libraries-as-facets">Solidity Libraries as Facets</h3>

<p>Smart contracts or deployed Solidity libraries can be facets of diamonds.</p>

<p>Only Solidity libraries that have one or more external functions can be deployed to a blockchain and be a facet.</p>

<p>Solidity libraries that contain internal functions only cannot be deployed and cannot be a facet. Internal functions from Solidity libraries are included in the bytecode of facets and contracts that use them. Solidity libraries with internal functions only are useful for sharing internal functions between facets.</p>

<p>Solidity library facets have a few properties that match their use as facets:</p>
<ul>
  <li>They cannot be deleted.</li>
  <li>They are stateless. They do not have contract storage.</li>
  <li>Their syntax prevents declaring state variables outside Diamond Storage.</li>
</ul>

<h3 id="addingreplacingremoving-functions">Adding/Replacing/Removing Functions</h3>

<h4 id="idiamond-interface"><code class="language-plaintext highlighter-rouge">IDiamond</code> Interface</h4>

<p>All diamonds must implement the <code class="language-plaintext highlighter-rouge">IDiamond</code> interface.</p>

<p>During the deployment of a diamond any immutable functions and any external functions added to the diamond must be emitted in the <code class="language-plaintext highlighter-rouge">DiamondCut</code> event.</p>

<p><strong>A <code class="language-plaintext highlighter-rouge">DiamondCut</code> event must be emitted any time external functions are added, replaced, or removed.</strong> This applies to all upgrades, all functions changes, at any time, whether through <code class="language-plaintext highlighter-rouge">diamondCut</code> or not.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IDiamond</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">FacetCutAction</span> <span class="p">{</span><span class="n">Add</span><span class="p">,</span> <span class="n">Replace</span><span class="p">,</span> <span class="n">Remove</span><span class="p">}</span>
    <span class="c1">// Add=0, Replace=1, Remove=2
</span>
    <span class="k">struct</span> <span class="n">FacetCut</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">facetAddress</span><span class="p">;</span>
        <span class="n">FacetCutAction</span> <span class="n">action</span><span class="p">;</span>
        <span class="kt">bytes4</span><span class="p">[]</span> <span class="n">functionSelectors</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">event</span> <span class="n">DiamondCut</span><span class="p">(</span><span class="n">FacetCut</span><span class="p">[]</span> <span class="n">_diamondCut</span><span class="p">,</span> <span class="kt">address</span> <span class="n">_init</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">_calldata</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">DiamondCut</code> event records all function changes to a diamond.</p>

<h4 id="idiamondcut-interface"><code class="language-plaintext highlighter-rouge">IDiamondCut</code> Interface</h4>

<p>A diamond contains within it a mapping of function selectors to facet addresses. Functions are added/replaced/removed by modifying this mapping.</p>

<p>Diamonds should implement the <code class="language-plaintext highlighter-rouge">IDiamondCut</code> interface if after their deployment they allow modifications to their function selector mapping.</p>

<p>The <code class="language-plaintext highlighter-rouge">diamondCut</code> function updates any number of functions from any number of facets in a single transaction. Executing all changes within a single transaction prevents data corruption which could occur in upgrades done over multiple transactions.</p>

<p><code class="language-plaintext highlighter-rouge">diamondCut</code> is specified for the purpose of interoperability. Diamond tools, software and user-interfaces should expect and use the standard <code class="language-plaintext highlighter-rouge">diamondCut</code> function.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IDiamondCut</span> <span class="k">is</span> <span class="n">IDiamond</span> <span class="p">{</span>
    <span class="c1">/// @notice Add/replace/remove any number of functions and optionally execute
</span>    <span class="c1">///         a function with delegatecall
</span>    <span class="c1">/// @param _diamondCut Contains the facet addresses and function selectors
</span>    <span class="c1">/// @param _init The address of the contract or facet to execute _calldata
</span>    <span class="c1">/// @param _calldata A function call, including function selector and arguments
</span>    <span class="c1">///                  _calldata is executed with delegatecall on _init
</span>    <span class="k">function</span> <span class="n">diamondCut</span><span class="p">(</span>
        <span class="n">FacetCut</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">_diamondCut</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">_init</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">_calldata</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">_diamondCut</code> argument is an array of <code class="language-plaintext highlighter-rouge">FacetCut</code> structs.</p>

<p>Each <code class="language-plaintext highlighter-rouge">FacetCut</code> struct contains a facet address and array of function selectors that are updated in a diamond.</p>

<p>For each <code class="language-plaintext highlighter-rouge">FacetCut</code> struct:</p>

<ul>
  <li>If the <code class="language-plaintext highlighter-rouge">action</code> is <code class="language-plaintext highlighter-rouge">Add</code>, update the function selector mapping for each <code class="language-plaintext highlighter-rouge">functionSelectors</code> item to the <code class="language-plaintext highlighter-rouge">facetAddress</code>. If any of the <code class="language-plaintext highlighter-rouge">functionSelectors</code> had a mapped facet, revert instead.</li>
  <li>If the <code class="language-plaintext highlighter-rouge">action</code> is <code class="language-plaintext highlighter-rouge">Replace</code>, update the function selector mapping for each <code class="language-plaintext highlighter-rouge">functionSelectors</code> item to the <code class="language-plaintext highlighter-rouge">facetAddress</code>. If any of the <code class="language-plaintext highlighter-rouge">functionSelectors</code> had a value equal to <code class="language-plaintext highlighter-rouge">facetAddress</code> or the selector was unset, revert instead.</li>
  <li>If the <code class="language-plaintext highlighter-rouge">action</code> is <code class="language-plaintext highlighter-rouge">Remove</code>, remove the function selector mapping for each <code class="language-plaintext highlighter-rouge">functionSelectors</code> item. If any of the <code class="language-plaintext highlighter-rouge">functionSelectors</code> were previously unset, revert instead.</li>
</ul>

<p>Any attempt to replace or remove an immutable function must revert.</p>

<p>Being intentional and explicit about adding/replacing/removing functions helps catch and prevent upgrade mistakes.</p>

<h5 id="executing-_calldata">Executing <code class="language-plaintext highlighter-rouge">_calldata</code></h5>

<p>After adding/replacing/removing functions the <code class="language-plaintext highlighter-rouge">_calldata</code> argument is executed with <code class="language-plaintext highlighter-rouge">delegatecall</code> on <code class="language-plaintext highlighter-rouge">_init</code>. This execution is done to initialize data or setup or remove anything needed or no longer needed after adding, replacing and/or removing functions.</p>

<p>If the <code class="language-plaintext highlighter-rouge">_init</code> value is <code class="language-plaintext highlighter-rouge">address(0)</code> then <code class="language-plaintext highlighter-rouge">_calldata</code> execution is skipped. In this case <code class="language-plaintext highlighter-rouge">_calldata</code> can contain 0 bytes or custom information.</p>

<h3 id="inspecting-facets--functions">Inspecting Facets &amp; Functions</h3>

<blockquote>
  <p>A loupe is a small magnifying glass used to look at diamonds.</p>
</blockquote>

<p>Diamonds must support inspecting facets and functions by implementing the <code class="language-plaintext highlighter-rouge">IDiamondLoupe</code> interface.</p>

<h4 id="idiamondloupe-interface"><code class="language-plaintext highlighter-rouge">IDiamondLoupe</code> Interface</h4>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A loupe is a small magnifying glass used to look at diamonds.
// These functions look at diamonds
</span><span class="k">interface</span> <span class="n">IDiamondLoupe</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Facet</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">facetAddress</span><span class="p">;</span>
        <span class="kt">bytes4</span><span class="p">[]</span> <span class="n">functionSelectors</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// @notice Gets all facet addresses and their four byte function selectors.
</span>    <span class="c1">/// @return facets_ Facet
</span>    <span class="k">function</span> <span class="n">facets</span><span class="p">()</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Facet</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">facets_</span><span class="p">);</span>

    <span class="c1">/// @notice Gets all the function selectors supported by a specific facet.
</span>    <span class="c1">/// @param _facet The facet address.
</span>    <span class="c1">/// @return facetFunctionSelectors_
</span>    <span class="k">function</span> <span class="n">facetFunctionSelectors</span><span class="p">(</span><span class="kt">address</span> <span class="n">_facet</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">facetFunctionSelectors_</span><span class="p">);</span>

    <span class="c1">/// @notice Get all the facet addresses used by a diamond.
</span>    <span class="c1">/// @return facetAddresses_
</span>    <span class="k">function</span> <span class="n">facetAddresses</span><span class="p">()</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">facetAddresses_</span><span class="p">);</span>

    <span class="c1">/// @notice Gets the facet that supports the given selector.
</span>    <span class="c1">/// @dev If facet is not found return address(0).
</span>    <span class="c1">/// @param _functionSelector The function selector.
</span>    <span class="c1">/// @return facetAddress_ The facet address.
</span>    <span class="k">function</span> <span class="n">facetAddress</span><span class="p">(</span><span class="kt">bytes4</span> <span class="n">_functionSelector</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">facetAddress_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>See a <a href="#reference-implementation">reference implementation</a> to see how this can be implemented.</p>

<p>The loupe functions can be used in user-interface software. A user interface calls these functions to provide information about and visualize diamonds.</p>

<p>The loupe functions can be used in deployment functionality, upgrade functionality, testing and other software.</p>

<h3 id="implementation-points">Implementation Points</h3>

<p>A diamond must implement the following:</p>

<ol>
  <li>A diamond contains a fallback function and zero or more immutable functions that are defined within it.</li>
  <li>A diamond associates function selectors with facets.</li>
  <li>When a function is called on a diamond it executes immediately if it is an “immutable function” defined directly in the diamond. Otherwise the diamond’s fallback function is executed. The fallback function finds the facet associated with the function and executes the function using <code class="language-plaintext highlighter-rouge">delegatecall</code>. If there is no facet for the function then optionally a default function may be executed. If there is no facet for the function and no default function and no other mechanism to handle it then execution reverts.</li>
  <li>Each time functions are added, replaced or removed a <code class="language-plaintext highlighter-rouge">DiamondCut</code> event is emitted to record it.</li>
  <li>A diamond implements the DiamondLoupe interface.</li>
  <li>All immutable functions must be emitted in the <code class="language-plaintext highlighter-rouge">DiamondCut</code> event as new functions added. And the loupe functions must return information about immutable functions if they exist. The facet address for an immutable function is the diamond’s address. Any attempt to delete or replace an immutable function must revert.</li>
</ol>

<p>A diamond may implement the following:</p>

<ol>
  <li><a href="./eip-165.md">EIP-165</a>’s <code class="language-plaintext highlighter-rouge">supportsInterface</code>. If a diamond has the <code class="language-plaintext highlighter-rouge">diamondCut</code> function then the interface ID used for it is <code class="language-plaintext highlighter-rouge">IDiamondCut.diamondCut.selector</code>. The interface ID used for the diamond loupe interface is <code class="language-plaintext highlighter-rouge">IDiamondLoupe.facets.selector ^ IDiamondLoupe.facetFunctionSelectors.selector ^ IDiamondLoupe.facetAddresses.selector ^ IDiamondLoupe.facetAddress.selector</code>.</li>
</ol>

<p>The diamond address is the address that users interact with. The diamond address does not change. Only facet addresses can change by using the <code class="language-plaintext highlighter-rouge">diamondCut</code> function, or other function.</p>

<h2 id="rationale">Rationale</h2>

<h3 id="using-function-selectors">Using Function Selectors</h3>

<p>User interface software can be used to retrieve function selectors and facet addresses from a diamond in order show what functions a diamond has.</p>

<p>This standard is designed to make diamonds work well with user-interface software. Function selectors with the ABI of a contract provide enough information about functions to be useful for user-interface software.</p>

<h3 id="gas-considerations">Gas Considerations</h3>

<p>Delegating function calls does have some gas overhead. This is mitigated in several ways:</p>

<ol>
  <li>Because diamonds do not have a max size limitation it is possible to add gas optimizing functions for use cases. For example someone could use a diamond to implement the <a href="./eip-721.md">EIP-721</a> standard and implement batch transfer functions to reduce gas (and make batch transfers more convenient).</li>
  <li>Some contract architectures require calling multiple contracts in one transaction. Gas savings can be realized by condensing those contracts into a single diamond and accessing contract storage directly.</li>
  <li>Facets can contain few external functions, reducing gas costs. Because it costs more gas to call a function in a contract with many functions than a contract with few functions.</li>
  <li>The Solidity optimizer can be set to a high setting causing more bytecode to be generated but the facets will use less gas when executed.</li>
</ol>

<h3 id="versions-of-functions">Versions of Functions</h3>

<p>Software or a user can verify what version of a function is called by getting the facet address of the function. This can be done by calling the <code class="language-plaintext highlighter-rouge">facetAddress</code> function from the <code class="language-plaintext highlighter-rouge">IDiamondLoupe</code> interface. This function takes a function selector as an argument and returns the facet address where it is implemented.</p>

<h3 id="default-function">Default Function</h3>

<p>Solidity provides the <code class="language-plaintext highlighter-rouge">fallback</code> function so that specific functionality can be executed when a function is called on a contract that does not exist in the contract. This same behavior can optionally be implemented in a diamond by implementing and using a default function, which is a function that is executed when a function is called on a diamond that does not exist in the diamond.</p>

<p>A default function can be implemented a number of ways and this standard does not specify how it must be implemented.</p>

<h3 id="loupe-functions--diamondcut-event">Loupe Functions &amp; <code class="language-plaintext highlighter-rouge">DiamondCut</code> Event</h3>

<p>To find out what functions a regular contract has it is only necessary to look at its verified source code.</p>

<p>The verified source code of a diamond does not include what functions it has so a different mechanism is needed.</p>

<p>A diamond has four standard functions called the loupe functions that are used to show what functions a diamond has.</p>

<p>The loupe functions can be used for many things including:</p>
<ol>
  <li>To show all functions used by a diamond.</li>
  <li>To query services like Etherscan or files to retrieve and show all source code used by a diamond.</li>
  <li>To query services like Etherscan or files to retrieve ABI information for a diamond.</li>
  <li>To test or verify that a transaction that adds/replaces/removes functions on a diamond succeeded.</li>
  <li>To find out what functions a diamond has before calling functions on it.</li>
  <li>To be used by tools and programming libraries to deploy and upgrade diamonds.</li>
  <li>To be used by user interfaces to show information about diamonds.</li>
  <li>To be used by user interfaces to enable users to call functions on diamonds.</li>
</ol>

<p>Diamonds support another form of transparency which is a historical record of all upgrades on a diamond. This is done with the <code class="language-plaintext highlighter-rouge">DiamondCut</code> event which is used to record all functions that are added, replaced or removed on a diamond.</p>

<h3 id="sharing-functions-between-facets">Sharing Functions Between Facets</h3>

<p>In some cases it might be necessary to call a function defined in a different facet. Here are ways to do this:</p>

<ol>
  <li>Copy internal function code in one facet to the other facet.</li>
  <li>Put common internal functions in a contract that is inherited by multiple facets.</li>
  <li>Put common internal functions in a Solidity library and use the library in facets.</li>
  <li>A type safe way to call an external function defined in another facet is to do this: <code class="language-plaintext highlighter-rouge">MyOtherFacet(address(this)).myFunction(arg1, arg2)</code></li>
  <li>A more gas-efficient way to call an external function defined in another facet is to use delegatecall. Here is an example of doing that:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DiamondStorage</span> <span class="k">storage</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">diamondStorage</span><span class="p">();</span>
<span class="kt">bytes4</span> <span class="n">functionSelector</span> <span class="o">=</span> <span class="kt">bytes4</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="s">"myFunction(uint256)"</span><span class="p">));</span>
<span class="c1">// get facet address of function
</span><span class="kt">address</span> <span class="n">facet</span> <span class="o">=</span> <span class="n">ds</span><span class="p">.</span><span class="n">selectorToFacet</span><span class="p">[</span><span class="n">functionSelector</span><span class="p">];</span>
<span class="kt">bytes</span> <span class="k">memory</span> <span class="n">myFunctionCall</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">encodeWithSelector</span><span class="p">(</span><span class="n">functionSelector</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="n">facet</span><span class="p">).</span><span class="nb">delegatecall</span><span class="p">(</span><span class="n">myFunctionCall</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>Instead of calling an external function defined in another facet you can instead create an internal function version of the external function. Add the internal version of the function to the facet that needs to use it.</li>
</ol>

<h3 id="facets-can-be-reusable-and-composable">Facets can be Reusable and Composable</h3>

<p>A deployed facet can be used by any number of diamonds.</p>

<p>Different combinations of facets can be used with different diamonds.</p>

<p>It is possible to create and deploy a set of facets that are reused by different diamonds over time.</p>

<p>The ability to use the same deployed facets for many diamonds reduces deployment costs.</p>

<p>It is possible to implement facets in a way that makes them usable/composable/compatible with other facets. It is also possible to implement facets in a way that makes them not usable/composable/compatible with other facets.</p>

<p>A function signature is the name of a function and its parameter types. Example function signature: <code class="language-plaintext highlighter-rouge">myfunction(uint256)</code>. A limitation is that two external functions with the same function signature can’t be added to the same diamond at the same time because a diamond, or any contract, cannot have two external functions with the same function signature.</p>

<p>All the functions of a facet do not have to be added to a diamond. Some functions in a facet can be added to a diamond while other functions in the facet are not added to the diamond.</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>This standard makes upgradeable diamonds compatible with future standards and functionality because new functions can be added and existing functions can be replaced or removed.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>All the Solidity code for a complete reference implementation has been put in a single file here: <a href="../assets/eip-2535/reference/Diamond.sol">Diamond.sol</a></p>

<p>The same reference implementation has been organized into multiple files and directories and also includes a deployment script and tests. Download it as a zip file: <a href="../assets/eip-2535/reference/EIP2535-Diamonds-Reference-Implementation.zip"><code class="language-plaintext highlighter-rouge">EIP2535-Diamonds-Reference-Implementation.zip</code></a></p>

<h2 id="security-considerations">Security Considerations</h2>

<h3 id="ownership-and-authentication">Ownership and Authentication</h3>

<blockquote>
  <p><strong>Note:</strong> The design and implementation of diamond ownership/authentication is <strong>not</strong> part of this standard. The examples given in this standard and in the reference implementation are just <strong>examples</strong> of how it could be done.</p>
</blockquote>

<p>It is possible to create many different authentication or ownership schemes with this proposal. Authentication schemes can be very simple or complex, fine grained or coarse. This proposal does not limit it in any way. For example ownership/authentication could be as simple as a single account address having the authority to add/replace/remove functions. Or a decentralized autonomous organization could have the authority to only add/replace/remove certain functions.</p>

<p>Consensus functionality could be implemented such as an approval function that multiple different people call to approve changes before they are executed with the <code class="language-plaintext highlighter-rouge">diamondCut</code> function. These are just examples.</p>

<p>The development of standards and implementations of ownership, control and authentication of diamonds is encouraged.</p>

<h3 id="arbitrary-execution-with-diamondcut">Arbitrary Execution with <code class="language-plaintext highlighter-rouge">diamondCut</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">diamondCut</code> function allows arbitrary execution with access to the diamond’s storage (through <code class="language-plaintext highlighter-rouge">delegatecall</code>). Access to this function must be restricted carefully.</p>

<h3 id="do-not-self-destruct">Do Not Self Destruct</h3>
<p>Use of <code class="language-plaintext highlighter-rouge">selfdestruct</code> in a facet is heavily discouraged. Misuse of it can delete a diamond or a facet.</p>

<h3 id="function-selector-clash">Function Selector Clash</h3>

<p>A function selector clash occurs when two different function signatures hash to the same four-byte hash. This has the unintended consequence of replacing an existing function in a diamond when the intention was to add a new function. This scenario is not possible with a properly implemented <code class="language-plaintext highlighter-rouge">diamondCut</code> function because it prevents adding function selectors that already exist.</p>

<h3 id="transparency">Transparency</h3>

<p>Diamonds emit an event every time one or more functions are added, replaced or removed. All source code can be verified. This enables people and software to monitor changes to a contract. If any bad acting function is added to a diamond then it can be seen.</p>

<p>Security and domain experts can review the history of change of a diamond to detect any history of foul play.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
