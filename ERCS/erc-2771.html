<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Secure Protocol for Native Meta Transactions | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Secure Protocol for Native Meta Transactions | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-2771" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-2771" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Secure Protocol for Native Meta Transactions</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>This EIP defines a contract-level protocol for <code class="language-plaintext highlighter-rouge">Recipient</code> contracts to accept meta-transactions through trusted <code class="language-plaintext highlighter-rouge">Forwarder</code> contracts. No protocol changes are made. <code class="language-plaintext highlighter-rouge">Recipient</code> contracts are sent the effective <code class="language-plaintext highlighter-rouge">msg.sender</code> (referred to as <code class="language-plaintext highlighter-rouge">_msgSender()</code>) and <code class="language-plaintext highlighter-rouge">msg.data</code> (referred to as <code class="language-plaintext highlighter-rouge">_msgData()</code>) by appending additional calldata.</p>

<h2 id="motivation">Motivation</h2>

<p>There is a growing interest in making it possible for Ethereum contracts to accept calls from externally owned accounts that do not have ETH to pay for gas. Solutions that allow for third parties to pay for gas costs are called meta transactions. For the purposes of this EIP, meta transactions are transactions that have been authorized by a <strong>Transaction Signer</strong> and relayed by an untrusted third party that pays for the gas (the <strong>Gas Relay</strong>).</p>

<h2 id="specification">Specification</h2>

<p>The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<h3 id="definitions">Definitions</h3>

<p><strong>Transaction Signer</strong>: Signs &amp; sends transactions to a Gas Relay</p>

<p><strong>Gas Relay</strong>: Receives signed requests off-chain from Transaction Signers and pays gas to turn it into a valid transaction that goes through a Trusted Forwarder</p>

<p><strong>Trusted Forwarder</strong>: A contract trusted by the <code class="language-plaintext highlighter-rouge">Recipient</code> to correctly verify signatures and nonces before forwarding the request from Transaction Signers</p>

<p><strong>Recipient</strong>: A contract that accepts meta-transactions through a Trusted Forwarder</p>

<h3 id="example-flow">Example Flow</h3>

<p><img src="../assets/eip-2771/example-flow.png" alt="Example flow" /></p>

<h3 id="extracting-the-transaction-signer-address">Extracting The Transaction Signer address</h3>

<p>The <strong>Trusted Forwarder</strong> is responsible for calling the <strong>Recipient</strong> contract and MUST append the address of the <strong>Transaction Signer</strong> (20 bytes of data) to the end of the call data.</p>

<p>For example :</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">returnData</span><span class="p">)</span> <span class="o">=</span> <span class="n">to</span><span class="p">.</span><span class="nb">call</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">)(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">from</span><span class="p">));</span>
</code></pre></div></div>

<p>The <strong>Recipient</strong> contract can then extract the <strong>Transaction Signer</strong> address by performing 3 operations:</p>

<ol>
  <li>Check that the <strong>Forwarder</strong> is trusted. How this is implemented is out of the scope of this proposal.</li>
  <li>Extract the <strong>Transaction Signer</strong> address from the last 20 bytes of the call data and use that as the original <code class="language-plaintext highlighter-rouge">sender</code> of the transaction (instead of <code class="language-plaintext highlighter-rouge">msg.sender</code>)</li>
  <li>If the <code class="language-plaintext highlighter-rouge">msg.sender</code> is not a trusted forwarder (or if the <code class="language-plaintext highlighter-rouge">msg.data</code> is shorter than 20 bytes), then return the original <code class="language-plaintext highlighter-rouge">msg.sender</code> as it is.</li>
</ol>

<p>The <strong>Recipient</strong> MUST check that it trusts the Forwarder to prevent it from
extracting address data appended from an untrusted contract. This could result
in a forged address.</p>

<h3 id="protocol-support-discovery-mechanism">Protocol Support Discovery Mechanism</h3>

<p>Unless a <strong>Recipient</strong> contract is being used by a particular frontend that knows that this contract has support for native meta transactions, it would not be possible to offer the user the choice of using meta-transaction to interact with the contract. We thus need a mechanism by which the <strong>Recipient</strong> can let the world know that it supports meta transactions.</p>

<p>This is especially important for meta transactions to be supported at the Web3 wallet level. Such wallets may not necessarily know anything about the <strong>Recipient</strong> contract users may wish to interact with.</p>

<p>As a <strong>Recipient</strong> could trust forwarders with different interfaces and capabilities (e.g., transaction batching, different message signing formats), we need to allow wallets to discover which Forwarder is trusted.</p>

<p>To provide this discovery mechanism a <strong>Recipient</strong> contract MUST implement this function:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">isTrustedForwarder</span><span class="p">(</span><span class="kt">address</span> <span class="n">forwarder</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">isTrustedForwarder</code> MUST return <code class="language-plaintext highlighter-rouge">true</code> if the forwarder is trusted by the Recipient, otherwise it MUST return <code class="language-plaintext highlighter-rouge">false</code>. <code class="language-plaintext highlighter-rouge">isTrustedForwarder</code> MUST NOT revert.</p>

<p>Internally, the <strong>Recipient</strong> MUST then accept a request from forwarder.</p>

<p><code class="language-plaintext highlighter-rouge">isTrustedForwarder</code> function MAY be called on-chain, and as such gas restrictions MUST be put in place. It SHOULD NOT consume more than 50,000 gas</p>

<h2 id="rationale">Rationale</h2>

<ul>
  <li>Make it easy for contract developers to add support for meta
transactions by standardizing the simplest viable contract interface.</li>
  <li>Without support for meta transactions in the recipient contract, an externally owned 
account can not use meta transactions to interact with the recipient contract.</li>
  <li>Without a standard contract interface, there is no standard way for a client
to discover whether a recipient supports meta transactions.</li>
  <li>Without a standard contract interface, there is no standard way to send a
meta transaction to a recipient.</li>
  <li>Without the ability to leverage a trusted forwarder every recipient contract
has to internally implement the logic required to accept meta transactions securely.</li>
  <li>Without a discovery protocol, there is no mechanism for a client to discover
whether a recipient supports a specific forwarder.</li>
  <li>Making the contract interface agnostic to the internal implementation
details of the trusted forwarder, makes it possible for a recipient contract
to support multiple forwarders with no change to code.</li>
  <li><code class="language-plaintext highlighter-rouge">msg.sender</code> is a transaction parameter that can be inspected by a contract to determine who signed the transaction. The integrity of this parameter is guaranteed by the Ethereum EVM, but for a meta transaction securing <code class="language-plaintext highlighter-rouge">msg.sender</code> is insufficient.
    <ul>
      <li>The problem is that for a contract that is not natively aware of meta transactions, the <code class="language-plaintext highlighter-rouge">msg.sender</code> of the transaction will make it appear to be coming from the <strong>Gas Relay</strong> and not the <strong>Transaction Signer</strong>. A secure protocol for a contract to accept meta transactions needs to prevent the <strong>Gas Relay</strong> from forging, modifying or duplicating requests by the <strong>Transaction Signer</strong>.</li>
    </ul>
  </li>
</ul>

<h2 id="reference-implementation">Reference Implementation</h2>

<h3 id="recipient-example">Recipient Example</h3>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">RecipientExample</span> <span class="p">{</span>

    <span class="k">function</span> <span class="n">purchaseItem</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">itemId</span><span class="p">)</span> <span class="k">external</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="n">sender</span> <span class="o">=</span> <span class="n">_msgSender</span><span class="p">();</span>
        <span class="c1">// ... perform the purchase for sender
</span>    <span class="p">}</span>

    <span class="kt">address</span> <span class="kr">immutable</span> <span class="n">_trustedForwarder</span><span class="p">;</span>
    <span class="k">constructor</span><span class="p">(</span><span class="kt">address</span> <span class="n">trustedForwarder</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="n">_trustedForwarder</span> <span class="o">=</span> <span class="n">trustedForwarder</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">isTrustedForwarder</span><span class="p">(</span><span class="kt">address</span> <span class="n">forwarder</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">forwarder</span> <span class="o">==</span> <span class="n">_trustedForwarder</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">_msgSender</span><span class="p">()</span> <span class="k">internal</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="k">payable</span> <span class="n">signer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">signer</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;=</span><span class="mi">20</span> <span class="o">&amp;&amp;</span> <span class="n">isTrustedForwarder</span><span class="p">(</span><span class="n">signer</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">assembly</span> <span class="p">{</span>
                <span class="n">signer</span> <span class="o">:=</span> <span class="n">shr</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span><span class="n">calldataload</span><span class="p">(</span><span class="n">sub</span><span class="p">(</span><span class="n">calldatasize</span><span class="p">(),</span><span class="mi">20</span><span class="p">)))</span>
            <span class="p">}</span>
        <span class="p">}</span>    
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="security-considerations">Security Considerations</h2>

<p>A malicious forwarder may forge the value of <code class="language-plaintext highlighter-rouge">_msgSender()</code> and effectively send transactions from any address. Therefore, <code class="language-plaintext highlighter-rouge">Recipient</code> contracts must be very careful in trusting forwarders. If a forwarder is upgradeable, then one must also trust that the contract won’t perform a malicious upgrade.</p>

<p>In addition, modifying which forwarders are trusted must be restricted, since an attacker could “trust” their own address to forward transactions, and therefore be able to forge transactions. It is recommended to have the list of trusted forwarders be immutable, and if this is not feasible, then only trusted contract owners should be able to modify it.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
