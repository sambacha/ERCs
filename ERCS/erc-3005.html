<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Batched meta transactions | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Batched meta transactions | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-3005" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-3005" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Batched meta transactions</h1>
  </header>

  <div class="post-content">
    <h2 id="simple-summary">Simple Summary</h2>

<p>Defines an extension function for ERC-20 (and other fungible token standards), which allows receiving and processing a batch of meta transactions.</p>

<h2 id="abstract">Abstract</h2>

<p>This EIP defines a new function called <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> that extends any fungible token standard, and enables batched meta transactions coming from many senders in one on-chain transaction.</p>

<p>The function must be able to receive multiple meta transactions data and process it. This means validating the data and the signature, before proceeding with token transfers based on the data.</p>

<p>The function enables senders to make gasless transactions, while reducing the relayer’s gas cost due to batching.</p>

<h2 id="motivation">Motivation</h2>

<p>Meta transactions have proven useful as a solution for Ethereum accounts that don’t have any ether, but hold ERC-20 tokens and would like to transfer them (gasless transactions).</p>

<p>The current meta transaction relayer implementations only allow relaying one meta transaction at a time. Some also allow batched meta transactions from the same sender. But none offers batched meta transactions from <strong>multiple</strong> senders.</p>

<p>The motivation behind this EIP is to find a way to allow relaying batched meta transactions from <strong>many senders</strong> in <strong>one on-chain transaction</strong>, which also <strong>reduces the total gas cost</strong> that a relayer needs to cover.</p>

<p><img src="../assets/eip-3005/meta-txs-directly-to-token-smart-contract.png" alt="" /></p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”,  “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<p>The key words “MUST (BUT WE KNOW YOU WON’T)”, “SHOULD CONSIDER”, “REALLY SHOULD NOT”, “OUGHT TO”, “WOULD PROBABLY”, “MAY WISH TO”, “COULD”, “POSSIBLE”, and “MIGHT” in this document are to be interpreted as described in RFC 6919.</p>

<h3 id="meta-transaction-data">Meta transaction data</h3>

<p>In order to successfully validate and transfer tokens, the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function MUST process the following data about a meta transaction:</p>

<ul>
  <li>sender address</li>
  <li>receiver address</li>
  <li>token amount</li>
  <li>relayer fee</li>
  <li>a (meta tx) nonce</li>
  <li>an expiration date (this COULD be a block number, or it COULD be a block timestamp)</li>
  <li>a token address</li>
  <li>a relayer address</li>
  <li>a signature</li>
</ul>

<p>Not all of the data needs to be sent to the function by the relayer (see the function interface specification). Some of the data can be deduced or extracted from other sources (from transaction data and contract state).</p>

<h3 id="processmetabatch-function-input-data"><code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function input data</h3>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function MUST receive the following data:</p>

<ul>
  <li>sender address</li>
  <li>receiver address</li>
  <li>token amount</li>
  <li>relayer fee</li>
  <li>an expiration date (this COULD be a block number, or it COULD be a block timestamp)</li>
  <li>a signature</li>
</ul>

<p>The following data is OPTIONAL to be sent to the function, because it can be extracted or derived from other sources:</p>

<ul>
  <li>a (meta tx) nonce</li>
  <li>a token address</li>
  <li>a relayer address</li>
</ul>

<h3 id="meta-transaction-data-hash">Meta transaction data hash</h3>

<p>The pseudocode for creating a hash of meta transaction data is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keccak256(address(sender)
	   ++ address(recipient)
	   ++ uint256(amount)
	   ++ uint256(relayerFee)
	   ++ uint256(nonce)
	   ++ uint256(expirationDate)
	   ++ address(tokenContract)
	   ++ address(relayer)
)
</code></pre></div></div>

<p>The created hash MUST then be signed with the sender’s private key.</p>

<h3 id="validation-rules">Validation rules</h3>

<ul>
  <li>Nonce of a new transaction MUST always be bigger by exactly 1 from the nonce of the last successfully processed meta transaction of the same sender to the same token contract.</li>
  <li>Sending to and from a 0x0 address MUST be prohibited.</li>
  <li>A meta transaction MUST be processed before the expiration date.</li>
  <li>Each sender’s token balance MUST be equal or greater than the sum of their respective meta transaction token amount and relayer fee.</li>
  <li>A transaction where at least one meta transaction in the batch does not satisfy the above requirements MUST not be reverted. Instead, a failed meta transaction MUST be skipped or ignored.</li>
</ul>

<h3 id="processmetabatch-function-interface"><code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function interface</h3>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function MUST have the following interface:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">processMetaBatch</span><span class="p">(</span><span class="kt">address</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">senders</span><span class="p">,</span>
                          <span class="kt">address</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">recipients</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">amounts</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">relayerFees</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">blocks</span><span class="p">,</span>
                          <span class="kt">uint8</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigV</span><span class="p">,</span>
                          <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigR</span><span class="p">,</span>
                          <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigS</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
</code></pre></div></div>

<p>The overview of parameters that are passed:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">senders</code>: an array of meta transaction sender addresses (token senders)</li>
  <li><code class="language-plaintext highlighter-rouge">recipients </code>: an array of token recipients addresses</li>
  <li><code class="language-plaintext highlighter-rouge">amounts</code>: an array of token amounts that are sent from each sender to each recipient, respectively</li>
  <li><code class="language-plaintext highlighter-rouge">relayerFees</code>: an array of the relayer fees paid in tokens by senders. The fee receiver is a relayer (<code class="language-plaintext highlighter-rouge">msg.address</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">blocks</code>: an array of block numbers that represent an expiration date by which the meta transaction must be processed (alternatively, a timestamp could be used instead of a block number)</li>
  <li><code class="language-plaintext highlighter-rouge">sigV</code>, <code class="language-plaintext highlighter-rouge">sigR</code>, <code class="language-plaintext highlighter-rouge">sigS</code>: three arrays that represent parts of meta transaction signatures</li>
</ul>

<p>Each entry in each of the arrays MUST represent data from one meta transaction. The order of the data is very important. Data from a single meta transaction MUST have the same index in every array.</p>

<h3 id="meta-transaction-nonce">Meta transaction nonce</h3>

<p>The token smart contract must keep track of a meta transaction nonce for each token holder.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">private</span> <span class="n">_metaNonces</span><span class="p">;</span>
</code></pre></div></div>

<p>The interface for the <code class="language-plaintext highlighter-rouge">nonceOf()</code> function is the following:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">nonceOf</span><span class="p">(</span><span class="kt">address</span> <span class="n">account</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="token-transfers">Token transfers</h3>

<p>After a meta transaction is successfully validated, the meta nonce of the meta transaction sender MUST be increased by 1.</p>

<p>Then two token transfers MUST occur:</p>

<ul>
  <li>The specified token amount MUST go to the recipient.</li>
  <li>The relayer fee MUST go to the relayer (<code class="language-plaintext highlighter-rouge">msg.sender</code>).</li>
</ul>

<h2 id="implementation">Implementation</h2>

<p>The <strong>reference implementation</strong> adds a couple of functions to the existing ERC-20 token standard:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">processMetaBatch()</code></li>
  <li><code class="language-plaintext highlighter-rouge">nonceOf()</code></li>
</ul>

<p>You can see the implementation of both functions in this file: <a href="https://github.com/defifuture/erc20-batched-meta-transactions/blob/master/contracts/ERC20MetaBatch.sol">ERC20MetaBatch.sol</a>. This is an extended ERC-20 contract with added meta transaction batch transfer capabilities.</p>

<h3 id="processmetabatch"><code class="language-plaintext highlighter-rouge">processMetaBatch()</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function is responsible for receiving and processing a batch of meta transactions that change token balances.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">processMetaBatch</span><span class="p">(</span><span class="kt">address</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">senders</span><span class="p">,</span>
                          <span class="kt">address</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">recipients</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">amounts</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">relayerFees</span><span class="p">,</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">blocks</span><span class="p">,</span>
                          <span class="kt">uint8</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigV</span><span class="p">,</span>
                          <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigR</span><span class="p">,</span>
                          <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">sigS</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="kt">address</span> <span class="n">sender</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">newNonce</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">relayerFeesSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bytes32</span> <span class="n">msgHash</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">i</span><span class="p">;</span>

    <span class="c1">// loop through all meta txs
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">senders</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sender</span> <span class="o">=</span> <span class="n">senders</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">newNonce</span> <span class="o">=</span> <span class="n">_metaNonces</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="n">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">recipients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// sender or recipient is 0x0 address, skip this meta tx
</span>        <span class="p">}</span>

        <span class="c1">// the meta tx should be processed until (including) the specified block number, otherwise it is invalid
</span>        <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// if current block number is bigger than the requested number, skip this meta tx
</span>        <span class="p">}</span>

        <span class="c1">// check if meta tx sender's balance is big enough
</span>        <span class="k">if</span><span class="p">(</span><span class="n">_balances</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// if sender's balance is less than the amount and the relayer fee, skip this meta tx
</span>        <span class="p">}</span>

        <span class="c1">// check if the signature is valid
</span>        <span class="n">msgHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">recipients</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">newNonce</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sender</span> <span class="o">!=</span> <span class="nb">ecrecover</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="s">"</span><span class="se">\x19</span><span class="s">Ethereum Signed Message:</span><span class="se">\n</span><span class="s">32"</span><span class="p">,</span> <span class="n">msgHash</span><span class="p">)),</span> <span class="n">sigV</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigR</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigS</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// if sig is not valid, skip to the next meta tx
</span>        <span class="p">}</span>

        <span class="c1">// set a new nonce for the sender
</span>        <span class="n">_metaNonces</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNonce</span><span class="p">;</span>

        <span class="c1">// transfer tokens
</span>        <span class="n">_balances</span><span class="p">[</span><span class="n">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">_balances</span><span class="p">[</span><span class="n">recipients</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">relayerFeesSum</span> <span class="o">+=</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

	<span class="c1">// give the relayer the sum of all relayer fees
</span>    <span class="n">_balances</span><span class="p">[</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">]</span> <span class="o">+=</span> <span class="n">relayerFeesSum</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nonceof"><code class="language-plaintext highlighter-rouge">nonceOf()</code></h3>

<p>Nonces are needed due to the replay protection (see <em>Replay attacks</em> under <em>Security Considerations</em>).</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">private</span> <span class="n">_metaNonces</span><span class="p">;</span>

<span class="c1">// ...
</span>
<span class="k">function</span> <span class="n">nonceOf</span><span class="p">(</span><span class="kt">address</span> <span class="n">account</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_metaNonces</span><span class="p">[</span><span class="n">account</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The link to the complete implementation (along with gas usage results) is here: <a href="https://github.com/defifuture/erc20-batched-meta-transactions">https://github.com/defifuture/erc20-batched-meta-transactions</a>.</p>

<blockquote>
  <p>Note that the OpenZeppelin ERC-20 implementation was used here. Some other implementation may have named the <code class="language-plaintext highlighter-rouge">_balances</code> mapping differently, which would require minor changes in the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function.</p>
</blockquote>

<h2 id="rationale">Rationale</h2>

<h3 id="all-in-one">All-in-one</h3>

<p>Alternative implementations (like GSN) use multiple smart contracts to enable meta transactions, although this increases gas usage. This implementation (EIP-3005) intentionally keeps everything within one function which reduces complexity and gas cost.</p>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function thus does the job of receiving a batch of meta transactions, validating them, and then transferring tokens from one address to another.</p>

<h3 id="function-parameters">Function parameters</h3>

<p>As you can see, the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function in the reference implementation takes the following parameters:</p>

<ul>
  <li>an array of <strong>sender addresses</strong> (meta txs senders, not relayers)</li>
  <li>an array of <strong>receiver addresses</strong></li>
  <li>an array of <strong>amounts</strong></li>
  <li>an array of <strong>relayer fees</strong> (relayer is <code class="language-plaintext highlighter-rouge">msg.sender</code>)</li>
  <li>an array of <strong>block numbers</strong> (a due “date” for meta tx to be processed)</li>
  <li>Three arrays that represent parts of a <strong>signature</strong> (v, r, s)</li>
</ul>

<p><strong>Each item</strong> in these arrays represents <strong>data of one meta transaction</strong>. That’s why the <strong>correct order</strong> in the arrays is very important.</p>

<p>If a relayer gets the order wrong, the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function would notice that (when validating a signature), because the hash of the meta transaction values would not match the signed hash. A meta transaction with an invalid signature is <strong>skipped</strong>.</p>

<h3 id="the-alternative-way-of-passing-meta-transaction-data-into-the-function">The alternative way of passing meta transaction data into the function</h3>

<p>The reference implementation takes parameters as arrays. There’s a separate array for each meta transaction data category (the ones that cannot be deduced or extracted from other sources).</p>

<p>A different approach would be to bitpack all data of a meta transaction into one value and then unpack it within the smart contract. The data for a batch of meta transactions would be sent in an array, but there would need to be only one array (of packed data), instead of multiple arrays.</p>

<h3 id="why-is-nonce-not-one-of-the-parameters-in-the-reference-implementation">Why is nonce not one of the parameters in the reference implementation?</h3>

<p>Meta nonce is used for constructing a signed hash (see the <code class="language-plaintext highlighter-rouge">msgHash</code> line where a <code class="language-plaintext highlighter-rouge">keccak256</code> hash is constructed - you’ll find a nonce there).</p>

<p>Since a new nonce has to always be bigger than the previous one by exactly 1, there’s no need to include it as a parameter array in the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function, because its value can be deduced.</p>

<p>This also helps avoid the “Stack too deep” error.</p>

<h3 id="can-eip-2612-nonces-mapping-be-re-used">Can EIP-2612 nonces mapping be re-used?</h3>

<p>The EIP-2612 (<code class="language-plaintext highlighter-rouge">permit()</code> function) also requires a nonce mapping. At this point, I’m not sure yet if this mapping should be <strong>re-used</strong> in case a smart contract implements both EIP-3005 and EIP-2612.</p>

<p>At the first glance, it seems the <code class="language-plaintext highlighter-rouge">nonces</code> mapping from EIP-2612 could be re-used, but this should be thought through (and tested) for possible security implications.</p>

<h3 id="token-transfers-1">Token transfers</h3>

<p>Token transfers in the reference implementation could alternatively be done by calling the <code class="language-plaintext highlighter-rouge">_transfer()</code> function (part of the OpenZeppelin ERC-20 implementation), but it would increase the gas usage and it would also revert the whole batch if some meta transaction was invalid (the current implementation just skips it).</p>

<p>Another gas usage optimization is to assign total relayer fees to the relayer at the end of the function, and not with every token transfer inside the for loop (thus avoiding multiple SSTORE calls that cost 5’000 gas).</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>The code implementation of batched meta transactions is backwards compatible with any fungible token standard, for example, ERC-20 (it only extends it with one function).</p>

<h2 id="test-cases">Test Cases</h2>

<p>Link to tests: <a href="https://github.com/defifuture/erc20-batched-meta-transactions/tree/master/test">https://github.com/defifuture/erc20-batched-meta-transactions/tree/master/test</a>.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>Here is a list of potential security issues and how are they addressed in this implementation.</p>

<h3 id="forging-a-meta-transaction">Forging a meta transaction</h3>

<p>The solution against a relayer forging a meta transaction is for a user to sign the meta transaction with their private key.</p>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function then verifies the signature using <code class="language-plaintext highlighter-rouge">ecrecover()</code>.</p>

<h3 id="replay-attacks">Replay attacks</h3>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function is secure against two types of a replay attack:</p>

<p><strong>Using the same meta transaction twice in the same token smart contract</strong></p>

<p>A nonce prevents a replay attack where a relayer would send the same meta transaction more than once.</p>

<p><strong>Using the same meta transaction twice in different token smart contracts</strong></p>

<p>A token smart contract address must be added into the signed hash (of a meta transaction).</p>

<p>This address does not need to be sent as a parameter into the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function. Instead, the function uses <code class="language-plaintext highlighter-rouge">address(this)</code> when constructing a hash in order to verify the signature. This way a meta transaction not intended for the token smart contract would be rejected (skipped).</p>

<h3 id="signature-validation">Signature validation</h3>

<p>Signing a meta transaction and validating the signature is crucial for this whole scheme to work.</p>

<p>The <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function validates a meta transaction signature, and if it’s <strong>invalid</strong>, the meta transaction is <strong>skipped</strong> (but the whole on-chain transaction is <strong>not reverted</strong>).</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">msgHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">recipients</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">newNonce</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">));</span>

<span class="k">if</span><span class="p">(</span><span class="n">sender</span> <span class="o">!=</span> <span class="nb">ecrecover</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="s">"</span><span class="se">\x19</span><span class="s">Ethereum Signed Message:</span><span class="se">\n</span><span class="s">32"</span><span class="p">,</span> <span class="n">msgHash</span><span class="p">)),</span> <span class="n">sigV</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigR</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigS</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span> <span class="c1">// if sig is not valid, skip to the next meta tx
</span><span class="p">}</span>
</code></pre></div></div>

<p>Why not reverting the whole on-chain transaction? Because there could be only one problematic meta transaction, and the others should not be dropped just because of one rotten apple.</p>

<p>That said, it is expected of relayers to validate meta transactions in advance before relaying them. That’s why relayers are not entitled to a relayer fee for an invalid meta transaction.</p>

<h3 id="malicious-relayer-forcing-a-user-into-over-spending">Malicious relayer forcing a user into over-spending</h3>

<p>A malicious relayer could delay sending some user’s meta transaction until the user would decide to make the token transaction on-chain.</p>

<p>After that, the relayer would relay the delayed meta transaction which would mean that the user would have made two token transactions (over-spending).</p>

<p><strong>Solution:</strong> Each meta transaction should have an “expiry date”. This is defined in a form of a block number by which the meta transaction must be relayed on-chain.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">processMetaBatch</span><span class="p">(...</span>
                          <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">blocks</span><span class="p">,</span>
                          <span class="p">...)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="c1">//...
</span>
	<span class="c1">// loop through all meta txs
</span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">senders</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// the meta tx should be processed until (including) the specified block number, otherwise it is invalid
</span>        <span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// if current block number is bigger than the requested number, skip this meta tx
</span>        <span class="p">}</span>

        <span class="c1">//...
</span></code></pre></div></div>

<h3 id="front-running-attack">Front-running attack</h3>

<p>A malicious relayer could scout the Ethereum mempool to steal meta transactions and front-run the original relayer.</p>

<p><strong>Solution:</strong> The protection that <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function uses is that it requires the meta transaction sender to add the relayer’s Ethereum address as one of the values in the hash (which is then signed).</p>

<p>When the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function generates a hash it includes the <code class="language-plaintext highlighter-rouge">msg.sender</code> address in it:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">msgHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">recipients</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">amounts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">relayerFees</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">newNonce</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">));</span>

<span class="k">if</span><span class="p">(</span><span class="n">sender</span> <span class="o">!=</span> <span class="nb">ecrecover</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="s">"</span><span class="se">\x19</span><span class="s">Ethereum Signed Message:</span><span class="se">\n</span><span class="s">32"</span><span class="p">,</span> <span class="n">msgHash</span><span class="p">)),</span> <span class="n">sigV</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigR</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigS</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span> <span class="c1">// if sig is not valid, skip to the next meta tx
</span><span class="p">}</span>
</code></pre></div></div>

<p>If the meta transaction was “stolen”, the signature check would fail because the <code class="language-plaintext highlighter-rouge">msg.sender</code> address would not be the same as the intended relayer’s address.</p>

<h3 id="a-malicious-or-too-impatient-user-sending-a-meta-transaction-with-the-same-nonce-through-multiple-relayers-at-once">A malicious (or too impatient) user sending a meta transaction with the same nonce through multiple relayers at once</h3>

<p>A user that is either malicious or just impatient could submit a meta transaction with the same nonce (for the same token contract) to various relayers. Only one of them would get the relayer fee (the first one on-chain), while the others would get an invalid meta transaction.</p>

<p><strong>Solution:</strong> Relayers could <strong>share a list of their pending meta transactions</strong> between each other (sort of an info mempool).</p>

<p>The relayers don’t have to fear that someone would steal their respective pending transactions, due to the front-running protection (see above).</p>

<p>If relayers see meta transactions from a certain sender address that have the same nonce and are supposed to be relayed to the same token smart contract, they can decide that only the first registered meta transaction goes through and others are dropped (or in case meta transactions were registered at the same time, the remaining meta transaction could be randomly picked).</p>

<p>At a minimum, relayers need to share this meta transaction data (in order to detect meta transaction collision):</p>

<ul>
  <li>sender address</li>
  <li>token address</li>
  <li>nonce</li>
</ul>

<h3 id="too-big-due-block-number">Too big due block number</h3>

<p>The relayer could trick the meta transaction sender into adding too big due block number - this means a block by which the meta transaction must be processed. The block number could be far in the future, for example, 10 years in the future. This means that the relayer would have 10 years to submit the meta transaction.</p>

<p><strong>One way</strong> to solve this problem is by adding an upper bound constraint for a block number within the smart contract. For example, we could say that the specified due block number must not be bigger than 100’000 blocks from the current one (this is around 17 days in the future if we assume 15 seconds block time).</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the meta tx should be processed until (including) the specified block number, otherwise it is invalid
</span><span class="k">if</span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">number</span> <span class="o">+</span> <span class="mi">100000</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// If current block number is bigger than the requested due block number, skip this meta tx.
</span>    <span class="c1">// Also skip if the due block number is too big (bigger than 100'000 blocks in the future).
</span>    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This addition could open new security implications, that’s why it is left out of this proof-of-concept. But anyone who wishes to implement it should know about this potential constraint, too.</p>

<p><strong>The other way</strong> is to keep the <code class="language-plaintext highlighter-rouge">processMetaBatch()</code> function as it is and rather check for the too big due block number <strong>on the relayer level</strong>. In this case, the user could be notified about the problem and could issue a new meta transaction with another relayer that would have a much lower block parameter (and the same nonce).</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights are waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
