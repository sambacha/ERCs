<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Account Abstraction Using Alt Mempool | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Account Abstraction Using Alt Mempool | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-4337" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-4337" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Account Abstraction Using Alt Mempool</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a <code class="language-plaintext highlighter-rouge">UserOperation</code>. Users send <code class="language-plaintext highlighter-rouge">UserOperation</code> objects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making a <code class="language-plaintext highlighter-rouge">handleOps</code> call to a special contract, and that transaction then gets included in a block.</p>

<h2 id="motivation">Motivation</h2>

<p>See also <code class="language-plaintext highlighter-rouge">https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020</code> and the links therein for historical work and motivation, and <a href="./eip-2938.md">EIP-2938</a> for a consensus layer proposal for implementing the same goal.</p>

<p>This proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals:</p>

<ul>
  <li><strong>Achieve the key goal of account abstraction</strong>: allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and <a href="./eip-3074.md">EIP-3074</a> both require)</li>
  <li><strong>Decentralization</strong>
    <ul>
      <li>Allow any bundler (think: block builder) to participate in the process of including account-abstracted user operations</li>
      <li>Work with all activity happening over a public mempool; users do not need to know the direct communication addresses (eg. IP, onion) of any specific actors</li>
      <li>Avoid trust assumptions on bundlers</li>
    </ul>
  </li>
  <li><strong>Do not require any Ethereum consensus changes</strong>: Ethereum consensus layer development is focusing on the merge and later on scalability-oriented features, and there may not be any opportunity for further protocol changes for a long time. Hence, to increase the chance of faster adoption, this proposal avoids Ethereum consensus changes.</li>
  <li><strong>Try to support other use cases</strong>
    <ul>
      <li>Privacy-preserving applications</li>
      <li>Atomic multi-operations (similar goal to [EIP-3074])</li>
      <li>Pay tx fees with <a href="./eip-20.md">ERC-20</a> tokens, allow developers to pay fees for their users, and [EIP-3074]-like <strong>sponsored transaction</strong> use cases more generally</li>
      <li>Support aggregated signature (e.g. BLS)</li>
    </ul>
  </li>
</ul>

<h2 id="specification">Specification</h2>

<h3 id="definitions">Definitions</h3>

<ul>
  <li><strong>UserOperation</strong> - a structure that describes a transaction to be sent on behalf of a user. To avoid confusion, it is not named “transaction”.
    <ul>
      <li>Like a transaction, it contains “sender”, “to”, “calldata”, “maxFeePerGas”, “maxPriorityFee”, “signature”, “nonce”</li>
      <li>unlike a transaction, it contains several other fields, described below</li>
      <li>also, the “signature” field usage is not defined by the protocol, but by each account implementation</li>
    </ul>
  </li>
  <li><strong>Sender</strong> - the account contract sending a user operation.</li>
  <li><strong>EntryPoint</strong> - a singleton contract to execute bundles of UserOperations. Bundlers/Clients whitelist the supported entrypoint.</li>
  <li><strong>Bundler</strong> - a node (block builder) that can handle UserOperations,
create a valid an EntryPoint.handleOps() transaction,
and add it to the block while it is still valid.
This can be achieved by a number of ways:
    <ul>
      <li>Bundler can act as a block builder itself</li>
      <li>If the bundler is not a block builder, it MUST work with the block building infrastructure such as <code class="language-plaintext highlighter-rouge">mev-boost</code> or
other kind of PBS (proposer-builder separation)</li>
      <li>The <code class="language-plaintext highlighter-rouge">bundler</code> can also rely on an experimental <code class="language-plaintext highlighter-rouge">eth_sendRawTransactionConditional</code> RPC API if it is available.</li>
    </ul>
  </li>
  <li><strong>Paymaster</strong> - a helper contract that agrees to pay for the transaction, instead of the sender itself.</li>
  <li><strong>Aggregator</strong> - a helper contract trusted by accounts to validate an aggregated signature. Bundlers/Clients whitelist the supported aggregators.</li>
</ul>

<h3 id="useroperation">UserOperation</h3>

<p>To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their account to take in a struct named <code class="language-plaintext highlighter-rouge">UserOperation</code>:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sender</code></td>
      <td><code class="language-plaintext highlighter-rouge">address</code></td>
      <td>The account making the operation</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">nonce</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>Anti-replay parameter (see “Semi-abstracted Nonce Support” )</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">factory</code></td>
      <td><code class="language-plaintext highlighter-rouge">address</code></td>
      <td>account factory, only for new accounts</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">factoryData</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>data for account factory (only if account factory exists)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">callData</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>The data to pass to the <code class="language-plaintext highlighter-rouge">sender</code> during the main execution call</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">callGasLimit</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>The amount of gas to allocate the main execution call</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">verificationGasLimit</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>The amount of gas to allocate for the verification step</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preVerificationGas</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>Extra gas to pay the bunder</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">maxFeePerGas</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>Maximum fee per gas (similar to <a href="./eip-1559.md">EIP-1559</a> <code class="language-plaintext highlighter-rouge">max_fee_per_gas</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>Maximum priority fee per gas (similar to EIP-1559 <code class="language-plaintext highlighter-rouge">max_priority_fee_per_gas</code>)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">paymaster</code></td>
      <td><code class="language-plaintext highlighter-rouge">address</code></td>
      <td>Address of paymaster contract, (or empty, if account pays for itself)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">paymasterVerificationGasLimit</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>The amount of gas to allocate for the paymaster validation code</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">paymasterPostOpGasLimit</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td>The amount of gas to allocate for the paymaster post-operation code</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">paymasterData</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>Data for paymaster (only if paymaster exists)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">signature</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>Data passed into the account to verify authorization</td>
    </tr>
  </tbody>
</table>

<p>Users send <code class="language-plaintext highlighter-rouge">UserOperation</code> objects to a dedicated user operation mempool. The are not concerned with the packed version.
A specialized class of actors called <strong>bundlers</strong> (either block builders running special-purpose code, or users that can relay transactions to block builders eg. through a bundle marketplace such as Flashbots that can guarantee next-block-or-never inclusion) listen in on the user operation mempool, and create <strong>bundle transactions</strong>. A bundle transaction packages up multiple <code class="language-plaintext highlighter-rouge">UserOperation</code> objects into a single <code class="language-plaintext highlighter-rouge">handleOps</code> call to a pre-published global <strong>entry point contract</strong>.</p>

<p>To prevent replay attacks (both cross-chain and multiple <code class="language-plaintext highlighter-rouge">EntryPoint</code> implementations), the <code class="language-plaintext highlighter-rouge">signature</code> should depend on <code class="language-plaintext highlighter-rouge">chainid</code> and the <code class="language-plaintext highlighter-rouge">EntryPoint</code> address.</p>

<h3 id="entrypoint-definition">EntryPoint definition</h3>

<p>When passed to on-chain contacts (the EntryPoint contract, and then to account and paymaster), a packed version of the above structure is used:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sender</code></td>
      <td><code class="language-plaintext highlighter-rouge">address</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">nonce</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">initCode</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>concatenation of factory address and factoryData (or empty)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">callData</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">accountGasLimits</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes32</code></td>
      <td>concatenation of verificationGas (16 bytes) and callGas (16 bytes)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preVerificationGas</code></td>
      <td><code class="language-plaintext highlighter-rouge">uint256</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">gasFees</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes32</code></td>
      <td>concatenation of maxPriorityFee (16 bytes) and maxFeePerGas (16 bytes)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">paymasterAndData</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td>concatenation of paymaster fields (or empty)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">signature</code></td>
      <td><code class="language-plaintext highlighter-rouge">bytes</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>The core interface of the entry point contract is as follows:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">handleOps</span><span class="p">(</span><span class="n">PackedUserOperation</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">ops</span><span class="p">,</span> <span class="kt">address</span> <span class="k">payable</span> <span class="n">beneficiary</span><span class="p">);</span>

<span class="k">function</span> <span class="n">handleAggregatedOps</span><span class="p">(</span>
    <span class="n">UserOpsPerAggregator</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">opsPerAggregator</span><span class="p">,</span>
    <span class="kt">address</span> <span class="k">payable</span> <span class="n">beneficiary</span>
<span class="p">);</span>

<span class="k">struct</span> <span class="n">UserOpsPerAggregator</span> <span class="p">{</span>
    <span class="n">PackedUserOperation</span><span class="p">[]</span> <span class="n">userOps</span><span class="p">;</span>
    <span class="n">IAggregator</span> <span class="n">aggregator</span><span class="p">;</span>
    <span class="kt">bytes</span> <span class="n">signature</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="account-contract-interface">Account Contract Interface</h3>

<p>The core interface required for an account to have is:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IAccount</span> <span class="p">{</span>
  <span class="k">function</span> <span class="n">validateUserOp</span>
      <span class="p">(</span><span class="n">PackedUserOperation</span> <span class="k">calldata</span> <span class="n">userOp</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">userOpHash</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">missingAccountFunds</span><span class="p">)</span>
      <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">validationData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">userOpHash</code> is a hash over the userOp (except signature), entryPoint and chainId.</p>

<p>The account:</p>

<ul>
  <li>MUST validate the caller is a trusted EntryPoint</li>
  <li>If the account does not support signature aggregation, it MUST validate the signature is a valid signature of the <code class="language-plaintext highlighter-rouge">userOpHash</code>, and
SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error MUST revert.</li>
  <li>MUST pay the entryPoint (caller) at least the “missingAccountFunds” (which might be zero, in case current account’s deposit is high enough)</li>
  <li>The account MAY pay more than this minimum, to cover future transactions (it can always issue <code class="language-plaintext highlighter-rouge">withdrawTo</code> to retrieve it)</li>
  <li>The return value MUST be packed of <code class="language-plaintext highlighter-rouge">authorizer</code>, <code class="language-plaintext highlighter-rouge">validUntil</code> and <code class="language-plaintext highlighter-rouge">validAfter</code> timestamps.
    <ul>
      <li>authorizer - 0 for valid signature, 1 to mark signature failure. Otherwise, an address of an authorizer contract. This ERC defines “signature aggregator” as authorizer.</li>
      <li><code class="language-plaintext highlighter-rouge">validUntil</code> is 6-byte timestamp value, or zero for “infinite”. The UserOp is valid only up to this time.</li>
      <li><code class="language-plaintext highlighter-rouge">validAfter</code> is 6-byte timestamp. The UserOp is valid only after this time.</li>
    </ul>
  </li>
</ul>

<p>An account that works with aggregated signature, should return its signature aggregator address in the “sigAuthorizer” return value of validateUserOp.
It MAY ignore the signature field.</p>

<p>The account MAY implement the interface <code class="language-plaintext highlighter-rouge">IAccountExecute</code></p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IAccountExecute</span> <span class="p">{</span>
  <span class="k">function</span> <span class="n">executeUserOp</span><span class="p">(</span><span class="n">PackedUserOperation</span> <span class="k">calldata</span> <span class="n">userOp</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">userOpHash</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This method will be called by the entryPoint with the current UserOperation, instead of executing the <code class="language-plaintext highlighter-rouge">callData</code> itself on the account.</p>

<h3 id="semi-abstracted-nonce-support">Semi-abstracted Nonce Support</h3>

<p>In Ethereum protocol, the sequential transaction <code class="language-plaintext highlighter-rouge">nonce</code> value is used as a replay protection method as well as to
determine the valid order of transaction being included in blocks.</p>

<p>It also contributes to the transaction hash uniqueness, as a transaction by the same sender with the same
nonce may not be included in the chain twice.</p>

<p>However, requiring a single sequential <code class="language-plaintext highlighter-rouge">nonce</code> value is limiting the senders’ ability to define their custom logic
with regard to transaction ordering and replay protection.</p>

<p>Instead of sequential <code class="language-plaintext highlighter-rouge">nonce</code> we implement a nonce mechanism that uses a single <code class="language-plaintext highlighter-rouge">uint256</code> nonce value in the <code class="language-plaintext highlighter-rouge">UserOperation</code>,
but treats it as two values:</p>

<ul>
  <li>192-bit “key”</li>
  <li>64-bit “sequence”</li>
</ul>

<p>These values are represented on-chain in the <code class="language-plaintext highlighter-rouge">EntryPoint</code> contract.
We define the following method in the <code class="language-plaintext highlighter-rouge">EntryPoint</code> interface to expose these values:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getNonce</span><span class="p">(</span><span class="kt">address</span> <span class="n">sender</span><span class="p">,</span> <span class="kt">uint192</span> <span class="n">key</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">nonce</span><span class="p">);</span>
</code></pre></div></div>

<p>For each <code class="language-plaintext highlighter-rouge">key</code> the <code class="language-plaintext highlighter-rouge">sequence</code> is validated and incremented sequentially and monotonically by the <code class="language-plaintext highlighter-rouge">EntryPoint</code> for
each UserOperation, however a new key can be introduced with an arbitrary value at any point.</p>

<p>This approach maintains the guarantee of <code class="language-plaintext highlighter-rouge">UserOperation</code> hash uniqueness on-chain on the protocol level while allowing
wallets to implement any custom logic they may need operating on a 192-bit “key” field, while fitting the 32 byte word.</p>

<h4 id="reading-and-validating-the-nonce">Reading and validating the nonce</h4>

<p>When preparing the UserOp clients may make a view call to this method to determine a valid value for the <code class="language-plaintext highlighter-rouge">nonce</code> field.</p>

<p>Bundler’s validation of a UserOp should start with <code class="language-plaintext highlighter-rouge">getNonce</code> to ensure the transaction has a valid <code class="language-plaintext highlighter-rouge">nonce</code> field.</p>

<p>If the bundler is willing to accept multiple UserOperations by the same sender into their mempool,
this bundler is supposed to track the <code class="language-plaintext highlighter-rouge">key</code> and <code class="language-plaintext highlighter-rouge">sequence</code> pair of the UserOperations already added in the mempool.</p>

<h4 id="usage-examples">Usage examples</h4>

<ol>
  <li>
    <p>Classic sequential nonce.</p>

    <p>In order to require the wallet to have classic, sequential nonce, the validation function should perform:</p>

    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span><span class="p">(</span><span class="n">userOp</span><span class="p">.</span><span class="n">nonce</span><span class="o">&lt;</span><span class="k">type</span><span class="p">(</span><span class="kt">uint64</span><span class="p">).</span><span class="n">max</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Ordered administrative events</p>

    <p>In some cases, an account may need to have an “administrative” channel of operations running in parallel to normal
operations.</p>

    <p>In this case, the account may use specific <code class="language-plaintext highlighter-rouge">key</code> when calling methods on the account itself:</p>

    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes4</span> <span class="n">sig</span> <span class="o">=</span> <span class="kt">bytes4</span><span class="p">(</span><span class="n">userOp</span><span class="p">.</span><span class="n">callData</span><span class="p">[</span><span class="mi">0</span> <span class="o">:</span> <span class="mi">4</span><span class="p">]);</span>
<span class="kt">uint</span> <span class="n">key</span> <span class="o">=</span> <span class="n">userOp</span><span class="p">.</span><span class="n">nonce</span> <span class="o">&gt;&gt;</span> <span class="mi">64</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">ADMIN_METHODSIG</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">require</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">ADMIN_KEY</span><span class="p">,</span> <span class="s">"wrong nonce-key for admin operation"</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">require</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"wrong nonce-key for normal operation"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="required-entry-point-contract-functionality">Required entry point contract functionality</h3>

<p>There are 2 separate entry point methods: <code class="language-plaintext highlighter-rouge">handleOps</code> and <code class="language-plaintext highlighter-rouge">handleAggregatedOps</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">handleOps</code> handle userOps of accounts that don’t require any signature aggregator.</li>
  <li><code class="language-plaintext highlighter-rouge">handleAggregatedOps</code> can handle a batch that contains userOps of multiple aggregators (and also requests without any aggregator)</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">handleAggregatedOps</code> performs the same logic below as <code class="language-plaintext highlighter-rouge">handleOps</code>, but it must transfer the correct aggregator to each userOp, and also must call <code class="language-plaintext highlighter-rouge">validateSignatures</code> on each aggregator before doing all the per-account validation.
The entry point’s <code class="language-plaintext highlighter-rouge">handleOps</code> function must perform the following steps (we first describe the simpler non-paymaster case). It must make two loops, the <strong>verification loop</strong> and the <strong>execution loop</strong>. In the verification loop, the <code class="language-plaintext highlighter-rouge">handleOps</code> call must perform the following steps for each <code class="language-plaintext highlighter-rouge">UserOperation</code>:</p>
  </li>
  <li><strong>Create the account if it does not yet exist</strong>, using the initcode provided in the <code class="language-plaintext highlighter-rouge">UserOperation</code>. If the account does not exist, <em>and</em> the initcode is empty, or does not deploy a contract at the “sender” address, the call must fail.</li>
  <li>calculate the maximum possible fee the account needs to pay (based on validation and call gas limits, and current gas values)</li>
  <li>calculate the fee the account must add to its “deposit” in the EntryPoint</li>
  <li><strong>Call <code class="language-plaintext highlighter-rouge">validateUserOp</code> on the account</strong>, passing in the <code class="language-plaintext highlighter-rouge">UserOperation</code>, its hash and the required fee. The account should verify the operation’s signature, and pay the fee if the account considers the operation valid. If any <code class="language-plaintext highlighter-rouge">validateUserOp</code> call fails, <code class="language-plaintext highlighter-rouge">handleOps</code> must skip execution of at least that operation, and may revert entirely.</li>
  <li>Validate the account’s deposit in the entryPoint is high enough to cover the max possible cost (cover the already-done verification and max execution gas)</li>
</ul>

<p>In the execution loop, the <code class="language-plaintext highlighter-rouge">handleOps</code> call must perform the following steps for each <code class="language-plaintext highlighter-rouge">UserOperation</code>:</p>

<ul>
  <li><strong>Call the account with the <code class="language-plaintext highlighter-rouge">UserOperation</code>’s calldata</strong>. It’s up to the account to choose how to parse the calldata; an expected workflow is for the account to have an <code class="language-plaintext highlighter-rouge">execute</code> function that parses the remaining calldata as a series of one or more calls that the account should make.</li>
  <li>If the calldata starts with the methodsig <code class="language-plaintext highlighter-rouge">IAccountExecute.executeUserOp</code>, then the EntryPoint must build a calldata by encoding <code class="language-plaintext highlighter-rouge">executeUserOp(userOp,userOpHash)</code> and call the account using that calldata.</li>
  <li>After the call, refund the account’s deposit with the excess gas cost that was pre-charged.<br />
 A penalty of <code class="language-plaintext highlighter-rouge">10%</code> (<code class="language-plaintext highlighter-rouge">UNUSED_GAS_PENALTY_PERCENT</code>) is applied on the amount of gas that is refunded.<br />
 This penalty is necessary to prevent the UserOps from reserving large parts of the gas space in the bundle but leaving it unused and preventing the bundler from including other UserOperations.</li>
  <li>After the execution of all calls, pay the collected fees from all UserOperations to the bundler’s provided address</li>
</ul>

<p><img src="../assets/eip-4337/bundle-seq.svg" alt="" /></p>

<p>Before accepting a <code class="language-plaintext highlighter-rouge">UserOperation</code>, bundlers should use an RPC method to locally call the <code class="language-plaintext highlighter-rouge">simulateValidation</code> function on the entry point, to verify that the signature is correct and the operation actually pays fees; see the <a href="#simulation">Simulation section below</a> for details.
A node/bundler SHOULD drop (not add to the mempool) a <code class="language-plaintext highlighter-rouge">UserOperation</code> that fails the validation</p>

<h3 id="extension-paymasters">Extension: paymasters</h3>

<p>We extend the entry point logic to support <strong>paymasters</strong> that can sponsor transactions for other users. This feature can be used to allow application developers to subsidize fees for their users, allow users to pay fees with [ERC-20] tokens and many other use cases. When the paymasterAndData field in the UserOp is not empty, the entry point implements a different flow for that UserOperation:</p>

<p><img src="../assets/eip-4337/bundle-seq-pm.svg" alt="" /></p>

<p>During the verification loop, in addition to calling <code class="language-plaintext highlighter-rouge">validateUserOp</code>, the <code class="language-plaintext highlighter-rouge">handleOps</code> execution also must check that the paymaster has enough ETH deposited with the entry point to pay for the operation, and then call <code class="language-plaintext highlighter-rouge">validatePaymasterUserOp</code> on the paymaster to verify that the paymaster is willing to pay for the operation. Note that in this case, the <code class="language-plaintext highlighter-rouge">validateUserOp</code> is called with a <code class="language-plaintext highlighter-rouge">missingAccountFunds</code> of 0 to reflect that the account’s deposit is not used for payment for this userOp.</p>

<p>If the paymaster’s validatePaymasterUserOp returns a “context”, then <code class="language-plaintext highlighter-rouge">handleOps</code> must call <code class="language-plaintext highlighter-rouge">postOp</code> on the paymaster after making the main execution call.</p>

<p>Maliciously crafted paymasters <em>can</em> DoS the system. To prevent this, we use a reputation system. paymaster must either limit its storage usage, or have a stake. see the <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> for details.</p>

<p>The paymaster interface is as follows:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">validatePaymasterUserOp</span>
    <span class="p">(</span><span class="n">PackedUserOperation</span> <span class="k">calldata</span> <span class="n">userOp</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="n">userOpHash</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">maxCost</span><span class="p">)</span>
    <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">context</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">validationData</span><span class="p">);</span>

<span class="k">function</span> <span class="n">postOp</span>
    <span class="p">(</span><span class="n">PostOpMode</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">context</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">actualGasCost</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">actualUserOpFeePerGas</span><span class="p">)</span>
    <span class="k">external</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">PostOpMode</span> <span class="p">{</span>
    <span class="n">opSucceeded</span><span class="p">,</span> <span class="c1">// user op succeeded
</span>    <span class="n">opReverted</span><span class="p">,</span> <span class="c1">// user op reverted. still has to pay for gas.
</span>    <span class="n">postOpReverted</span> <span class="c1">// Regardless of the UserOp call status, the postOp reverted, and caused both executions to revert.
</span><span class="p">}</span>
</code></pre></div></div>

<p>The EntryPoint must implement the following API to let entities like paymasters to have a stake, and thus have more flexibility in their storage access (see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> for details.)</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// add a stake to the calling entity
</span><span class="k">function</span> <span class="n">addStake</span><span class="p">(</span><span class="kt">uint32</span> <span class="n">_unstakeDelaySec</span><span class="p">)</span> <span class="k">external</span> <span class="k">payable</span>

<span class="c1">// unlock the stake (must wait unstakeDelay before can withdraw)
</span><span class="k">function</span> <span class="n">unlockStake</span><span class="p">()</span> <span class="k">external</span>

<span class="c1">// withdraw the unlocked stake
</span><span class="k">function</span> <span class="n">withdrawStake</span><span class="p">(</span><span class="kt">address</span> <span class="k">payable</span> <span class="n">withdrawAddress</span><span class="p">)</span> <span class="k">external</span>
</code></pre></div></div>

<p>The paymaster must also have a deposit, which the entry point will charge UserOperation costs from.
The deposit (for paying gas fees) is separate from the stake (which is locked).</p>

<p>The EntryPoint must implement the following interface to allow paymasters (and optionally accounts) manage their deposit:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// return the deposit of an account</span>
<span class="n">function</span> <span class="n">balanceOf</span><span class="p">(</span><span class="n">address</span> <span class="n">account</span><span class="p">)</span> <span class="k">public</span> <span class="n">view</span> <span class="n">returns</span> <span class="p">(</span><span class="n">uint256</span><span class="p">)</span>

<span class="c1">// add to the deposit of the given account</span>
<span class="n">function</span> <span class="n">depositTo</span><span class="p">(</span><span class="n">address</span> <span class="n">account</span><span class="p">)</span> <span class="k">public</span> <span class="n">payable</span>

<span class="c1">// withdraw from the deposit of the current account</span>
<span class="n">function</span> <span class="n">withdrawTo</span><span class="p">(</span><span class="n">address</span> <span class="n">payable</span> <span class="n">withdrawAddress</span><span class="p">,</span> <span class="n">uint256</span> <span class="n">withdrawAmount</span><span class="p">)</span> <span class="n">external</span>
</code></pre></div></div>

<h3 id="client-behavior-upon-receiving-a-useroperation">Client behavior upon receiving a UserOperation</h3>

<p>When a client receives a <code class="language-plaintext highlighter-rouge">UserOperation</code>, it must first run some basic sanity checks, namely that:</p>

<ul>
  <li>Either the <code class="language-plaintext highlighter-rouge">sender</code> is an existing contract, or the <code class="language-plaintext highlighter-rouge">initCode</code> is not empty (but not both)</li>
  <li>If <code class="language-plaintext highlighter-rouge">initCode</code> is not empty, parse its first 20 bytes as a factory address.  Record whether the factory is staked, in case the later simulation indicates that it needs to be.  If the factory accesses global state, it must be staked - see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> for details.</li>
  <li>The <code class="language-plaintext highlighter-rouge">verificationGasLimit</code> is sufficiently low (<code class="language-plaintext highlighter-rouge">&lt;= MAX_VERIFICATION_GAS</code>) and the <code class="language-plaintext highlighter-rouge">preVerificationGas</code> is sufficiently high (enough to pay for the calldata gas cost of serializing the <code class="language-plaintext highlighter-rouge">UserOperation</code> plus <code class="language-plaintext highlighter-rouge">PRE_VERIFICATION_OVERHEAD_GAS</code>)</li>
  <li>The <code class="language-plaintext highlighter-rouge">paymasterAndData</code> is either empty, or start with the <strong>paymaster</strong> address, which is a contract that (i) currently has nonempty code on chain, (ii) has a sufficient deposit to pay for the UserOperation, and (iii) is not currently banned. During simulation, the paymaster’s stake is also checked, depending on its storage usage - see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> for details.</li>
  <li>The callgas is at least the cost of a <code class="language-plaintext highlighter-rouge">CALL</code> with non-zero value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">maxFeePerGas</code> and <code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code> are above a configurable minimum value that the client is willing to accept. At the minimum, they are sufficiently high to be included with the current <code class="language-plaintext highlighter-rouge">block.basefee</code>.</li>
  <li>The sender doesn’t have another <code class="language-plaintext highlighter-rouge">UserOperation</code> already present in the pool (or it replaces an existing entry with the same sender and nonce, with a higher <code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code> and an equally increased <code class="language-plaintext highlighter-rouge">maxFeePerGas</code>). Only one <code class="language-plaintext highlighter-rouge">UserOperation</code> per sender may be included in a single batch. A sender is exempt from this rule and may have multiple <code class="language-plaintext highlighter-rouge">UserOperations</code> in the pool and in a batch if it is staked (see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> below), but this exception is of limited use to normal accounts.</li>
</ul>

<p>If the <code class="language-plaintext highlighter-rouge">UserOperation</code> object passes these sanity checks, the client must next run the first op simulation, and if the simulation succeeds, the client must add the op to the pool. A second simulation must also happen during bundling to make sure the UserOperation is still valid.</p>

<h3 id="using-signature-aggregator">Using Signature Aggregator</h3>

<p>A signature aggregator exposes the following interface</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IAggregator</span> <span class="p">{</span>

  <span class="k">function</span> <span class="n">validateUserOpSignature</span><span class="p">(</span><span class="n">PackedUserOperation</span> <span class="k">calldata</span> <span class="n">userOp</span><span class="p">)</span>
  <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">sigForUserOp</span><span class="p">);</span>

  <span class="k">function</span> <span class="n">aggregateSignatures</span><span class="p">(</span><span class="n">PackedUserOperation</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">userOps</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">aggregatesSignature</span><span class="p">);</span>

  <span class="k">function</span> <span class="n">validateSignatures</span><span class="p">(</span><span class="n">PackedUserOperation</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">userOps</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">signature</span><span class="p">)</span> <span class="k">view</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>An account signifies it uses signature aggregation returning its address from <code class="language-plaintext highlighter-rouge">validateUserOp</code>.</li>
  <li>During <code class="language-plaintext highlighter-rouge">simulateValidation</code>, this aggregator is returned to the bundler as part of the <code class="language-plaintext highlighter-rouge">aggregatorInfo</code> struct.</li>
  <li>The bundler should first accept the aggregator (aggregators must be staked. bundler should verify it is not throttle/banned)</li>
  <li>To accept the UserOp, the bundler must call <strong>validateUserOpSignature()</strong> to validate the userOp’s signature.
This method returned an alternate signature (usually empty) that should be used during bundling.</li>
  <li>The bundler MUST call <code class="language-plaintext highlighter-rouge">validateUserOp</code> a second time on the account with the UserOperation using that returned signature, and make sure it returns the same value.</li>
  <li><strong>aggregateSignatures()</strong> must aggregate all UserOp signatures into a single value.</li>
  <li>Note that the above methods are helper method for the bundler. The bundler MAY use a native library to perform the same validation and aggregation logic.</li>
  <li><strong>validateSignatures()</strong> MUST validate the aggregated signature matches for all UserOperations in the array, and revert otherwise.
This method is called on-chain by <code class="language-plaintext highlighter-rouge">handleOps()</code></li>
</ul>

<h3 id="simulation">Simulation</h3>

<h4 id="simulation-rationale">Simulation Rationale</h4>

<p>In order to add a UserOperation into the mempool (and later to add it into a bundle) we need to “simulate” its validation to make sure it is valid, and that it is capable of paying for its own execution.
In addition, we need to verify that the same will hold true when executed on-chain.
For this purpose, a UserOperation is not allowed to access any information that might change between simulation and execution, such as current block time, number, hash etc.
In addition, a UserOperation is only allowed to access data related to this sender address: Multiple UserOperations should not access the same storage, so that it is impossible to invalidate a large number of UserOperations with a single state change.
There are 3 special contracts that interact with the account: the factory (initCode) that deploys the contract, the paymaster that can pay for the gas, and signature aggregator (described later)
Each of these contracts is also restricted in its storage access, to make sure UserOperation validations are isolated.</p>

<h4 id="simulation-specification">Simulation Specification:</h4>

<p>To simulate a <code class="language-plaintext highlighter-rouge">UserOperation</code> validation, the client makes a view call to <code class="language-plaintext highlighter-rouge">simulateValidation(userop)</code>.</p>

<p>The EntryPoint itself does not implement the simulation methods. Instead, when making the simulation view call,
The bundler should provide the alternate EntryPointSimulations code, which extends the EntryPoint with the simulation methods.</p>

<p>The simulation core methods:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span> <span class="n">ValidationResult</span> <span class="p">{</span>
    <span class="n">ReturnInfo</span> <span class="n">returnInfo</span><span class="p">;</span>
    <span class="n">StakeInfo</span> <span class="n">senderInfo</span><span class="p">;</span>
    <span class="n">StakeInfo</span> <span class="n">factoryInfo</span><span class="p">;</span>
    <span class="n">StakeInfo</span> <span class="n">paymasterInfo</span><span class="p">;</span>
    <span class="n">AggregatorStakeInfo</span> <span class="n">aggregatorInfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">function</span> <span class="n">simulateValidation</span><span class="p">(</span><span class="n">PackedUserOperation</span> <span class="k">calldata</span> <span class="n">userOp</span><span class="p">)</span>
<span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="n">ValidationResult</span> <span class="k">memory</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ReturnInfo</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="n">preOpGas</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">prefund</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">accountValidationData</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">paymasterValidationData</span><span class="p">;</span>
    <span class="kt">bytes</span> <span class="n">paymasterContext</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">AggregatorStakeInfo</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="n">aggregator</span><span class="p">;</span>
    <span class="n">StakeInfo</span> <span class="n">stakeInfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">StakeInfo</span> <span class="p">{</span>
  <span class="kt">uint256</span> <span class="n">stake</span><span class="p">;</span>
  <span class="kt">uint256</span> <span class="n">unstakeDelaySec</span><span class="p">;</span>
<span class="p">}</span>


</code></pre></div></div>

<p>This method returns <code class="language-plaintext highlighter-rouge">ValidationResult</code> or revert on validation failure.
The node should drop the UserOperation if the simulation fails (either by revert or by “signature failure”)</p>

<p>The simulated call performs the full validation, by calling:</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">initCode</code> is present, create the account.</li>
  <li><code class="language-plaintext highlighter-rouge">account.validateUserOp</code>.</li>
  <li>if specified a paymaster: <code class="language-plaintext highlighter-rouge">paymaster.validatePaymasterUserOp</code>.</li>
</ol>

<p>The simulateValidation should validate the return value (validationData) returned by the account’s <code class="language-plaintext highlighter-rouge">validateUserOp</code> and paymaster’s <code class="language-plaintext highlighter-rouge">validatePaymasterUserOp</code>.
The account MAY return an aggregator. See <a href="#using-signature-aggregator">Using Signature Aggregator</a>
The paymaster MUST return either “0” (success) or SIG_VALIDATION_FAILED for aggregator, and not an address.
Either return value may contain a “validAfter” and “validUntil” timestamps, which is the time-range that this UserOperation is valid on-chain.
A node MAY drop a UserOperation if it expires too soon (e.g. wouldn’t make it to the next block) by either the account or paymaster.
If the <code class="language-plaintext highlighter-rouge">ValidationResult</code> includes <code class="language-plaintext highlighter-rouge">sigFail</code>, the client SHOULD drop the <code class="language-plaintext highlighter-rouge">UserOperation</code>.</p>

<p>In order to prevent DoS attack on bundlers, they must make sure the validation methods above pass the validation rules, which constraint their usage of opcodes and storage.
For the complete procedure see <a href="./eip-7562.md">ERC-7562</a></p>

<h3 id="alternative-mempools">Alternative Mempools</h3>

<p>The simulation rules above are strict and prevent the ability of paymasters and signature aggregators to grief the system.
However, there might be use-cases where specific paymasters (and signature aggregators) can be validated
(through manual auditing) and verified that they cannot cause any problem, while still require relaxing of the opcode rules.
A bundler cannot simply “whitelist” request from a specific paymaster: if that paymaster is not accepted by all
bundlers, then its support will be sporadic at best.
Instead, we introduce the term “alternate mempool”: a modified validation rules, and procedure of propagating them to other bundlers.</p>

<p>The procedure of using alternate mempools is defined in <a href="./eip-7562.md#alt-mempools-rules">ERC-7562</a></p>

<h3 id="bundling">Bundling</h3>

<p>Bundling is the process where a node/bundler collects multiple UserOperations and create a single transaction to submit on-chain.</p>

<p>During bundling, the bundler should:</p>

<ul>
  <li>Exclude UserOps that access any sender address of another UserOp in the same batch.</li>
  <li>Exclude UserOps that access any address created by another UserOp validation in the same batch (via a factory).</li>
  <li>For each paymaster used in the batch, keep track of the balance while adding UserOps. Ensure that it has sufficient deposit to pay for all the UserOps that use it.</li>
  <li>Sort UserOps by aggregator, to create the lists of UserOps-per-aggregator.</li>
  <li>For each aggregator, run the aggregator-specific code to create aggregated signature, and update the UserOps</li>
</ul>

<p>After creating the batch, before including the transaction in a block, the bundler should:</p>

<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">debug_traceCall</code> with maximum possible gas, to enforce the validation rules on opcode and storage access,
as well as to verify the entire <code class="language-plaintext highlighter-rouge">handleOps</code> batch transaction,
and use the consumed gas for the actual transaction execution.</li>
  <li>If the call reverted, the bundler MUST use the trace result to find the entity that reverted the call. <br />
This is the last entity that is CALL’ed by the EntryPoint prior to the revert. <br />
(the bundler cannot assume the revert is <code class="language-plaintext highlighter-rouge">FailedOp</code>)</li>
  <li>If any verification context rule was violated the bundlers should treat it the same as
if this UserOperation reverted.</li>
  <li>Remove the offending UserOperation from the current bundle and from mempool.</li>
  <li>If the error is caused by a <code class="language-plaintext highlighter-rouge">factory</code> or a <code class="language-plaintext highlighter-rouge">paymaster</code>, and the <code class="language-plaintext highlighter-rouge">sender</code>
of the UserOp <strong>is not</strong> a staked entity, then issue a “ban” (see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">“Reputation, throttling and banning”</a>)
for the guilty factory or paymaster.</li>
  <li>If the error is caused by a <code class="language-plaintext highlighter-rouge">factory</code> or a <code class="language-plaintext highlighter-rouge">paymaster</code>, and the <code class="language-plaintext highlighter-rouge">sender</code>
of the UserOp <strong>is</strong> a staked entity, do not ban the <code class="language-plaintext highlighter-rouge">factory</code> / <code class="language-plaintext highlighter-rouge">paymaster</code> from the mempool.
Instead, issue a “ban” for the staked <code class="language-plaintext highlighter-rouge">sender</code> entity.</li>
  <li>Repeat until <code class="language-plaintext highlighter-rouge">debug_traceCall</code> succeeds.</li>
</ul>

<p>As staked entries may use some kind of transient storage to communicate data between UserOperations in the same bundle,
it is critical that the exact same opcode and precompile banning rules as well as storage access rules are enforced
for the <code class="language-plaintext highlighter-rouge">handleOps</code> validation in its entirety as for individual UserOperations.
Otherwise, attackers may be able to use the banned opcodes to detect running on-chain and trigger a <code class="language-plaintext highlighter-rouge">FailedOp</code> revert.</p>

<p>When a bundler includes a bundle in a block it must ensure that earlier transactions in the block don’t make any UserOperation fail. It should either use access lists to prevent conflicts, or place the bundle as the first transaction in the block.</p>

<h3 id="error-codes">Error codes.</h3>

<p>While performing validation, the EntryPoint must revert on failures. During simulation, the calling bundler MUST be able to determine which entity (factory, account or paymaster) caused the failure.
The attribution of revert to entity is done using the call-tracing: the last entity called by the EntryPoint prior the revert is the entity that caused the revert.</p>
<ul>
  <li>For diagnostic purposes, the EntryPoint must only revert with explicit FailedOp() or FailedOpWithRevert() errors.</li>
  <li>The message of the error starts with event code, AA##</li>
  <li>Event code starting with “AA1” signify an error during account creation</li>
  <li>Event code starting with “AA2” signify an error during account validation (validateUserOp)</li>
  <li>Event code starting with “AA3” signify an error during paymaster validation (validatePaymasterUserOp)</li>
</ul>

<h2 id="rationale">Rationale</h2>

<p>The main challenge with a purely smart contract wallet based account abstraction system is DoS safety: how can a block builder including an operation make sure that it will actually pay fees, without having to first execute the entire operation?
Requiring the block builder to execute the entire operation opens a DoS attack vector, as an attacker could easily send many operations that pretend to pay a fee but then revert at the last moment after a long execution.
Similarly, to prevent attackers from cheaply clogging the mempool, nodes in the P2P network need to check if an operation will pay a fee before they are willing to forward it.</p>

<p>The first step is clean separation between validation (acceptance of UserOperation, and acceptance to pay) and execution.
In this proposal, we expect accounts to have a <code class="language-plaintext highlighter-rouge">validateUserOp</code> method that takes as input a <code class="language-plaintext highlighter-rouge">UserOperation</code>, and verify the signature and pay the fee.
Only if this method returns successfully, the execution will happen.</p>

<p>The entry point-based approach allows for a clean separation between verification and execution, and keeps accounts’ logic simple. It enforces the simple rule that only after validation is successful (and the UserOp can pay), the execution is done, and also guarantees the fee payment.</p>

<h3 id="validation-rules-rationale">Validation Rules Rationale</h3>
<p>The next step is protecting the bundlers from denial-of-service attacks by a mass number of UserOperation that appear to be valid (and pay) but that eventually revert, and thus block the bundler from processing valid UserOperations.</p>

<p>There are two types of UserOperations that can fail validation:</p>
<ol>
  <li>UserOperations that succeed in initial validation (and accepted into the mempool), but relay on environment state to fail later when attempting to include them in a block.</li>
  <li>UserOperations that are valid when checked independently, by fail when bundled together to be put on-chain.
To prevent such rogue UserOperations, the bundler is required to follow a set of <a href="./eip-7562.md">restrictions on the validation function</a>, to prevent such denial-of-service attacks.</li>
</ol>

<h3 id="reputation-rationale">Reputation Rationale.</h3>

<p>UserOperation’s storage access rules prevent them from interfere with each other.
But “global” entities - paymasters, factories and aggregators are accessed by multiple UserOperations, and thus might invalidate multiple previously-valid UserOperations.</p>

<p>To prevent abuse, we throttle down (or completely ban for a period of time) an entity that causes invalidation of large number of UserOperations in the mempool.
To prevent such entities from “sybil-attack”, we require them to stake with the system, and thus make such DoS attack very expensive.
Note that this stake is never slashed, and can be withdrawn any time (after unstake delay)</p>

<p>Unstaked entities are allowed, under the rules below.</p>

<p>When staked, an entity is less restricted in its memory usage.</p>

<p>The stake value is not enforced on-chain, but specifically by each node while simulating a transaction.</p>

<h3 id="reputation-scoring-and-throttlingbanning-for-global-entities">Reputation scoring and throttling/banning for global entities</h3>

<p>[ERC-7562] defines a set of rules a bundler must follow when accepting UserOperations into the mempool.
It also descrbies the “reputation|”</p>

<h3 id="paymasters">Paymasters</h3>

<p>Paymaster contracts allow abstraction of gas: having a contract, that is not the sender of the transaction, pay for the transaction fees.</p>

<p>Paymaster architecture allows them to follow the model of “pre-charge, and later refund”.
E.g. a token-paymaster may pre-charge the user with the max possible price of the transaction, and refund the user with the excess afterwards.</p>

<h3 id="first-time-account-creation">First-time account creation</h3>

<p>It is an important design goal of this proposal to replicate the key property of EOAs that users do not need to perform some custom action or rely on an existing user to create their wallet; they can simply generate an address locally and immediately start accepting funds.</p>

<p>The wallet creation itself is done by a “factory” contract, with wallet-specific data.
The factory is expected to use CREATE2 (not CREATE) to create the wallet, so that the order of creation of wallets doesn’t interfere with the generated addresses.
The <code class="language-plaintext highlighter-rouge">initCode</code> field (if non-zero length) is parsed as a 20-byte address, followed by “calldata” to pass to this address.
This method call is expected to create a wallet and return its address.
If the factory does use CREATE2 or some other deterministic method to create the wallet, it’s expected to return the wallet address even if the wallet has already been created.  This is to make it easier for clients to query the address without knowing if the wallet has already been deployed, by simulating a call to <code class="language-plaintext highlighter-rouge">entryPoint.getSenderAddress()</code>, which calls the factory under the hood.
When <code class="language-plaintext highlighter-rouge">initCode</code> is specified, if either the <code class="language-plaintext highlighter-rouge">sender</code> address points to an existing contract, or (after calling the initCode) the <code class="language-plaintext highlighter-rouge">sender</code> address still does not exist,
then the operation is aborted.
The <code class="language-plaintext highlighter-rouge">initCode</code> MUST NOT be called directly from the entryPoint, but from another address.
The contract created by this factory method should accept a call to <code class="language-plaintext highlighter-rouge">validateUserOp</code> to validate the UserOp’s signature.
For security reasons, it is important that the generated contract address will depend on the initial signature.
This way, even if someone can create a wallet at that address, he can’t set different credentials to control it.
The factory has to be staked if it accesses global storage - see <a href="#reputation-scoring-and-throttlingbanning-for-global-entities">reputation, throttling and banning section</a> for details.</p>

<p>NOTE: In order for the wallet to determine the “counterfactual” address of the wallet (prior its creation),
it should make a static call to the <code class="language-plaintext highlighter-rouge">entryPoint.getSenderAddress()</code></p>

<h3 id="entry-point-upgrading">Entry point upgrading</h3>

<p>Accounts are encouraged to be DELEGATECALL forwarding contracts for gas efficiency and to allow account upgradability. The account code is expected to hard-code the entry point into their code for gas efficiency. If a new entry point is introduced, whether to add new functionality, improve gas efficiency, or fix a critical security bug, users can self-call to replace their account’s code address with a new code address containing code that points to a new entry point. During an upgrade process, it’s expected that two mempools will run in parallel.</p>

<h3 id="rpc-methods-eth-namespace">RPC methods (eth namespace)</h3>

<h4 id="-eth_senduseroperation">* eth_sendUserOperation</h4>

<p>eth_sendUserOperation submits a User Operation object to the User Operation pool of the client. The client MUST validate the UserOperation, and return a result accordingly.</p>

<p>The result <code class="language-plaintext highlighter-rouge">SHOULD</code> be set to the <strong>userOpHash</strong> if and only if the request passed simulation and was accepted in the client’s User Operation pool. If the validation, simulation, or User Operation pool inclusion fails, <code class="language-plaintext highlighter-rouge">result</code> <code class="language-plaintext highlighter-rouge">SHOULD NOT</code> be returned. Rather, the client <code class="language-plaintext highlighter-rouge">SHOULD</code> return the failure reason.</p>

<h5 id="parameters">Parameters:</h5>

<ol>
  <li><strong>UserOperation</strong> a full user-operation struct. All fields MUST be set as hex values. empty <code class="language-plaintext highlighter-rouge">bytes</code> block (e.g. empty <code class="language-plaintext highlighter-rouge">initCode</code>) MUST be set to <code class="language-plaintext highlighter-rouge">"0x"</code></li>
  <li><strong>factory</strong> and <strong>factoryData</strong> - either both exist, or none</li>
  <li>paymaster fields (<strong>paymaster</strong>, <strong>paymasterData</strong>, <strong>paymasterValidationGasLimit</strong>, <strong>paymasterPostOpGasLimit</strong>) either all exist, or none.</li>
  <li><strong>EntryPoint</strong> the entrypoint address the request should be sent through. this MUST be one of the entry points returned by the <code class="language-plaintext highlighter-rouge">supportedEntryPoints</code> rpc call.</li>
</ol>

<h5 id="return-value">Return value:</h5>

<ul>
  <li>If the UserOperation is valid, the client MUST return the calculated <strong>userOpHash</strong> for it</li>
  <li>in case of failure, MUST return an <code class="language-plaintext highlighter-rouge">error</code> result object, with <code class="language-plaintext highlighter-rouge">code</code> and <code class="language-plaintext highlighter-rouge">message</code>. The error code and message SHOULD be set as follows:
    <ul>
      <li><strong>code: -32602</strong> - invalid UserOperation struct/fields</li>
      <li><strong>code: -32500</strong> - transaction rejected by entryPoint’s simulateValidation, during wallet creation or validation
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">message</code> field MUST be set to the FailedOp’s “<code class="language-plaintext highlighter-rouge">AAxx</code>” error message from the EntryPoint</li>
        </ul>
      </li>
      <li><strong>code: -32501</strong> - transaction rejected by paymaster’s validatePaymasterUserOp
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">message</code> field SHOULD be set to the revert message from the paymaster</li>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field MUST contain a <code class="language-plaintext highlighter-rouge">paymaster</code> value</li>
        </ul>
      </li>
      <li><strong>code: -32502</strong> - transaction rejected because of opcode validation</li>
      <li><strong>code: -32503</strong> - UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon)
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain the <code class="language-plaintext highlighter-rouge">validUntil</code> and <code class="language-plaintext highlighter-rouge">validAfter</code> values</li>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain a <code class="language-plaintext highlighter-rouge">paymaster</code> value, if this error was triggered by the paymaster</li>
        </ul>
      </li>
      <li><strong>code: -32504</strong> - transaction rejected because paymaster (or signature aggregator) is throttled/banned
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain a <code class="language-plaintext highlighter-rouge">paymaster</code> or <code class="language-plaintext highlighter-rouge">aggregator</code> value, depending on the failed entity</li>
        </ul>
      </li>
      <li><strong>code: -32505</strong> - transaction rejected because paymaster (or signature aggregator) stake or unstake-delay is too low
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain a <code class="language-plaintext highlighter-rouge">paymaster</code> or <code class="language-plaintext highlighter-rouge">aggregator</code> value, depending on the failed entity</li>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain a <code class="language-plaintext highlighter-rouge">minimumStake</code> and <code class="language-plaintext highlighter-rouge">minimumUnstakeDelay</code></li>
        </ul>
      </li>
      <li><strong>code: -32506</strong> - transaction rejected because wallet specified unsupported signature aggregator
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">data</code> field SHOULD contain an <code class="language-plaintext highlighter-rouge">aggregator</code> value</li>
        </ul>
      </li>
      <li><strong>code: -32507</strong> - transaction rejected because of wallet signature check failed (or paymaster signature, if the paymaster uses its data as signature)</li>
    </ul>
  </li>
</ul>

<h5 id="example">Example:</h5>

<p>Request:</p>

<pre><code class="language-json=">{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "eth_sendUserOperation",
  "params": [
    {
      sender, // address
      nonce, // uint256
      factory, // address
      factoryData, // bytes
      callData, // bytes
      callGasLimit, // uint256
      verificationGasLimit, // uint256
      preVerificationGas, // uint256
      maxFeePerGas, // uint256
      maxPriorityFeePerGas, // uint256
      paymaster, // address
      paymasterVerificationGasLimit, // uint256
      paymasterPostOpGasLimit, // uint256
      paymasterData, // bytes
      signature // bytes
    },
    entryPoint // address
  ]
}

</code></pre>

<p>Response:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0x1234...5678"
}
</code></pre></div></div>

<h5 id="example-failure-responses">Example failure responses:</h5>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"jsonrpc"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"error"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AA21 didn't pay prefund"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">-32500</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"jsonrpc"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"error"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"paymaster stake too low"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"paymaster"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0x123456789012345678901234567890123456790"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"minimumStake"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0xde0b6b3a7640000"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"minimumUnstakeDelay"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0x15180"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"code"</span><span class="p">:</span><span class="w"> </span><span class="mi">-32504</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="-eth_estimateuseroperationgas">* eth_estimateUserOperationGas</h4>

<p>Estimate the gas values for a UserOperation.
Given UserOperation optionally without gas limits and gas prices, return the needed gas limits.
The signature field is ignored by the wallet, so that the operation will not require user’s approval.
Still, it might require putting a “semi-valid” signature (e.g. a signature in the right length)</p>

<p><strong>Parameters</strong>:</p>
<ul>
  <li>Same as <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code><br />
gas limits (and prices) parameters are optional, but are used if specified.
<code class="language-plaintext highlighter-rouge">maxFeePerGas</code> and <code class="language-plaintext highlighter-rouge">maxPriorityFeePerGas</code> default to zero, so no payment is required by neither account nor paymaster.</li>
  <li>Optionally accepts the <code class="language-plaintext highlighter-rouge">State Override Set</code> to allow users to modify the state during the gas estimation.<br />
This field as well as its behavior is equivalent to the ones defined for <code class="language-plaintext highlighter-rouge">eth_call</code> RPC method.</li>
</ul>

<p><strong>Return Values:</strong></p>

<ul>
  <li><strong>preVerificationGas</strong> gas overhead of this UserOperation</li>
  <li><strong>verificationGasLimit</strong> actual gas used by the validation of this UserOperation</li>
  <li><strong>callGasLimit</strong> value used by inner account execution</li>
  <li><strong>paymasterVerificationGasLimit</strong> value used for paymaster verification (if paymaster exists in the UserOperation)</li>
  <li><strong>paymasterPostOpGasLimit</strong> value used for paymaster post op execution (if paymaster exists in the UserOperation)</li>
</ul>

<h5 id="error-codes-1">Error Codes:</h5>

<p>Same as <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code>
This operation may also return an error if the inner call to the account contract reverts.</p>

<h4 id="-eth_getuseroperationbyhash">* eth_getUserOperationByHash</h4>

<p>Return a UserOperation based on a hash (userOpHash) returned by <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code></p>

<p><strong>Parameters</strong></p>

<ul>
  <li><strong>hash</strong> a userOpHash value returned by <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code></li>
</ul>

<p><strong>Return value</strong>:</p>

<ul>
  <li>If the UserOperation is included in a block:
    <ul>
      <li>Return a full UserOperation, with the addition of <code class="language-plaintext highlighter-rouge">entryPoint</code>, <code class="language-plaintext highlighter-rouge">blockNumber</code>, <code class="language-plaintext highlighter-rouge">blockHash</code> and <code class="language-plaintext highlighter-rouge">transactionHash</code>.</li>
    </ul>
  </li>
  <li>Else if the UserOperation is pending in the bundler’s mempool:
    <ul>
      <li>MAY return <code class="language-plaintext highlighter-rouge">null</code>, or: a full UserOperation, with the addition of the <code class="language-plaintext highlighter-rouge">entryPoint</code> field and a <code class="language-plaintext highlighter-rouge">null</code> value for <code class="language-plaintext highlighter-rouge">blockNumber</code>, <code class="language-plaintext highlighter-rouge">blockHash</code> and <code class="language-plaintext highlighter-rouge">transactionHash</code>.</li>
    </ul>
  </li>
  <li>Else:
    <ul>
      <li>Return <code class="language-plaintext highlighter-rouge">null</code></li>
    </ul>
  </li>
</ul>

<h4 id="-eth_getuseroperationreceipt">* eth_getUserOperationReceipt</h4>

<p>Return a UserOperation receipt based on a hash (userOpHash) returned by <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code></p>

<p><strong>Parameters</strong></p>

<ul>
  <li><strong>hash</strong> a userOpHash value returned by <code class="language-plaintext highlighter-rouge">eth_sendUserOperation</code></li>
</ul>

<p><strong>Return value</strong>:</p>

<p><code class="language-plaintext highlighter-rouge">null</code> in case the UserOperation is not yet included in a block, or:</p>

<ul>
  <li><strong>userOpHash</strong> the request hash</li>
  <li><strong>entryPoint</strong></li>
  <li><strong>sender</strong></li>
  <li><strong>nonce</strong></li>
  <li><strong>paymaster</strong> the paymaster used for this userOp (or empty)</li>
  <li><strong>actualGasCost</strong> - actual amount paid (by account or paymaster) for this UserOperation</li>
  <li><strong>actualGasUsed</strong> - total gas used by this UserOperation (including preVerification, creation, validation and execution)</li>
  <li><strong>success</strong> boolean - did this execution completed without revert</li>
  <li><strong>reason</strong> in case of revert, this is the revert reason</li>
  <li><strong>logs</strong> the logs generated by this UserOperation (not including logs of other UserOperations in the same bundle)</li>
  <li><strong>receipt</strong> the TransactionReceipt object.
Note that the returned TransactionReceipt is for the entire bundle, not only for this UserOperation.</li>
</ul>

<h4 id="-eth_supportedentrypoints">* eth_supportedEntryPoints</h4>

<p>Returns an array of the entryPoint addresses supported by the client. The first element of the array <code class="language-plaintext highlighter-rouge">SHOULD</code> be the entryPoint addressed preferred by the client.</p>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "eth_supportedEntryPoints",
  "params": []
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [
    "0xcd01C8aa8995A59eB7B2627E69b40e0524B5ecf8",
    "0x7A0A0d159218E6a2f407B99173A2b12A6DDfC2a6"
  ]
}
</code></pre>

<h4 id="-eth_chainid">* eth_chainId</h4>

<p>Returns <a href="./eip-155.md">EIP-155</a> Chain ID.</p>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "eth_chainId",
  "params": []
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0x1"
}
</code></pre>

<h3 id="rpc-methods-debug-namespace">RPC methods (debug Namespace)</h3>

<p>This api must only be available on testing mode and is required by the compatibility test suite. In production, any <code class="language-plaintext highlighter-rouge">debug_*</code> rpc calls should be blocked.</p>

<h4 id="-debug_bundler_clearstate">* debug_bundler_clearState</h4>

<p>Clears the bundler mempool and reputation data of paymasters/accounts/factories/aggregators.</p>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_clearState",
  "params": []
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "ok"
}
</code></pre>

<h4 id="-debug_bundler_dumpmempool">* debug_bundler_dumpMempool</h4>

<p>Dumps the current UserOperations mempool</p>

<p><strong>Parameters:</strong></p>

<ul>
  <li><strong>EntryPoint</strong> the entrypoint used by eth_sendUserOperation</li>
</ul>

<p><strong>Returns:</strong></p>

<p><code class="language-plaintext highlighter-rouge">array</code> - Array of UserOperations currently in the mempool.</p>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_dumpMempool",
  "params": ["0x1306b01bC3e4AD202612D3843387e94737673F53"]
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [
    {
        sender, // address
        nonce, // uint256
        factory, // address
        factoryData, // bytes
        callData, // bytes
        callGasLimit, // uint256
        verificationGasLimit, // uint256
        preVerificationGas, // uint256
        maxFeePerGas, // uint256
        maxPriorityFeePerGas, // uint256
        signature // bytes
    }
  ]
}
</code></pre>

<h4 id="-debug_bundler_sendbundlenow">* debug_bundler_sendBundleNow</h4>

<p>Forces the bundler to build and execute a bundle from the mempool as <code class="language-plaintext highlighter-rouge">handleOps()</code> transaction.</p>

<p>Returns: <code class="language-plaintext highlighter-rouge">transactionHash</code></p>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_sendBundleNow",
  "params": []
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0xdead9e43632ac70c46b4003434058b18db0ad809617bd29f3448d46ca9085576"
}
</code></pre>

<h4 id="-debug_bundler_setbundlingmode">* debug_bundler_setBundlingMode</h4>

<p>Sets bundling mode.</p>

<p>After setting mode to “manual”, an explicit call to debug_bundler_sendBundleNow is required to send a bundle.</p>

<h5 id="parameters-1">parameters:</h5>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">mode</code> - ‘manual’</td>
      <td>‘auto’</td>
    </tr>
  </tbody>
</table>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_setBundlingMode",
  "params": ["manual"]
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "ok"
}
</code></pre>

<h4 id="-debug_bundler_setreputation">* debug_bundler_setReputation</h4>

<p>Sets reputation of given addresses. parameters:</p>

<p><strong>Parameters:</strong></p>

<ul>
  <li>
    <p>An array of reputation entries to add/replace, with the fields:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">address</code> - The address to set the reputation for.</li>
      <li><code class="language-plaintext highlighter-rouge">opsSeen</code> - number of times a user operations with that entity was seen and added to the mempool</li>
      <li><code class="language-plaintext highlighter-rouge">opsIncluded</code> - number of times a user operations that uses this entity was included on-chain</li>
    </ul>
  </li>
  <li>
    <p><strong>EntryPoint</strong> the entrypoint used by eth_sendUserOperation</p>
  </li>
</ul>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_setReputation",
  "params": [
    [
      {
        "address": "0x7A0A0d159218E6a2f407B99173A2b12A6DDfC2a6",
        "opsSeen": "0x14",
        "opsIncluded": "0x0D"
      }
    ],
    "0x1306b01bC3e4AD202612D3843387e94737673F53"
  ]
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "ok"
}
</code></pre>

<h4 id="-debug_bundler_dumpreputation">* debug_bundler_dumpReputation</h4>

<p>Returns the reputation data of all observed addresses.
Returns an array of reputation objects, each with the fields described above in <code class="language-plaintext highlighter-rouge">debug_bundler_setReputation</code> with the</p>

<p><strong>Parameters:</strong></p>

<ul>
  <li><strong>EntryPoint</strong> the entrypoint used by eth_sendUserOperation</li>
</ul>

<p><strong>Return value:</strong></p>

<p>An array of reputation entries with the fields:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">address</code> - The address to set the reputation for.</li>
  <li><code class="language-plaintext highlighter-rouge">opsSeen</code> - number of times a user operations with that entity was seen and added to the mempool</li>
  <li><code class="language-plaintext highlighter-rouge">opsIncluded</code> - number of times a user operations that uses this entity was included on-chain</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">status</code> - (string) The status of the address in the bundler ‘ok’</td>
          <td>‘throttled’</td>
          <td>‘banned’.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_dumpReputation",
  "params": ["0x1306b01bC3e4AD202612D3843387e94737673F53"]
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [
    { "address": "0x7A0A0d159218E6a2f407B99173A2b12A6DDfC2a6",
      "opsSeen": "0x14",
      "opsIncluded": "0x13",
      "status": "ok"
    }
  ]
}
</code></pre>

<h4 id="-debug_bundler_adduserops">* debug_bundler_addUserOps</h4>

<p>Accept UserOperations into the mempool.
Assume the given UserOperations all pass validation (without actually validating them), and accept them directly into th mempool</p>

<p><strong>Parameters:</strong></p>

<ul>
  <li>An array of UserOperations</li>
</ul>

<pre><code class="language-json="># Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "debug_bundler_addUserOps",
  "params": [
    [
      { sender: "0xa...", ... },
      { sender: "0xb...", ... }
    ]
  ]
}

# Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "ok"
}
</code></pre>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>This ERC does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole. Unfortunately it is not easily compatible with pre-<a href="./eip-4337.md">ERC-4337</a> accounts, because those accounts do not have a <code class="language-plaintext highlighter-rouge">validateUserOp</code> function. If the account has a function for authorizing a trusted op submitter, then this could be fixed by creating an <a href="./eip-4337.md">ERC-4337</a> compatible account that re-implements the verification logic as a wrapper and setting it to be the original account’s trusted op submitter.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>See <code class="language-plaintext highlighter-rouge">https://github.com/eth-infinitism/account-abstraction/tree/main/contracts</code></p>

<h2 id="security-considerations">Security Considerations</h2>

<p>The entry point contract will need to be very heavily audited and formally verified, because it will serve as a central trust point for <em>all</em> [ERC-4337]. In total, this architecture reduces auditing and formal verification load for the ecosystem, because the amount of work that individual <em>accounts</em> have to do becomes much smaller (they need only verify the <code class="language-plaintext highlighter-rouge">validateUserOp</code> function and its “check signature and pay fees” logic) and check that other functions are <code class="language-plaintext highlighter-rouge">msg.sender == ENTRY_POINT</code> gated (perhaps also allowing <code class="language-plaintext highlighter-rouge">msg.sender == self</code>), but it is nevertheless the case that this is done precisely by concentrating security risk in the entry point contract that needs to be verified to be very robust.</p>

<p>Verification would need to cover two primary claims (not including claims needed to protect paymasters, and claims needed to establish p2p-level DoS resistance):</p>

<ul>
  <li><strong>Safety against arbitrary hijacking</strong>: The entry point only calls an account generically if <code class="language-plaintext highlighter-rouge">validateUserOp</code> to that specific account has passed (and with <code class="language-plaintext highlighter-rouge">op.calldata</code> equal to the generic call’s calldata)</li>
  <li><strong>Safety against fee draining</strong>: If the entry point calls <code class="language-plaintext highlighter-rouge">validateUserOp</code> and passes, it also must make the generic call with calldata equal to <code class="language-plaintext highlighter-rouge">op.calldata</code></li>
</ul>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
