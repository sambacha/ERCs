<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Royalty Bearing NFTs | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Royalty Bearing NFTs | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-4910" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-4910" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Royalty Bearing NFTs</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>The proposal directly connects NFTs and royalties in a smart contract architecture extending the <a href="./eip-721.md">ERC-721</a> standard, with the aim of precluding central authorities from manipulating or circumventing payments to those who are legally entitled to them.</p>

<p>The proposal builds upon the OpenZeppelin Smart Contract Toolbox architecture, and extends it to include royalty account management (CRUD), royalty balance and payments management, simple trading capabilities – Listing/De-Listing/Buying – and capabilities to trace trading on exchanges. The royalty management capabilities allow for hierarchical royalty structures, referred to herein as royalty trees, to be established by logically connecting a “parent” NFT to its “children”, and recursively enabling NFT “children” to have more children.</p>

<h2 id="motivation">Motivation</h2>

<p>The management of royalties is an age-old problem characterized by complex contracts, opaque management, plenty of cheating and fraud.</p>

<p>The above is especially true for a hierarchy of royalties, where one or more assets is derived from an original asset such as a print from an original painting, or a song is used in the creation of another song, or distribution rights and compensation are managed through a series of affiliates.</p>

<p>In the example below, the artist who created the original is eligible to receive proceeds from every sale, and resale, of a print.</p>

<p><img src="../assets/eip-4910/eip-4910-print-families.png" alt="Fig1" /></p>

<p>The basic concept for hierarchical royalties utilizing the above “ancestry concept” is demonstrated in the figure below.</p>

<p><img src="../assets/eip-4910/eip-4910-royalties.png" alt="Fig2" /></p>

<p>In order to solve for the complicated inheritance problem, this proposal breaks down the recursive problem of the hierarchy tree of depth N into N separate problems, one for each layer. This allows us to traverse the tree from its lowest level upwards to its root most efficiently.</p>

<p>This affords creators, and the distributors of art derived from the original, the opportunity to achieve passive income from the creative process, enhancing the value of an NFT, since it now not only has intrinsic value but also comes with an attached cash flow.</p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<h3 id="outline">Outline</h3>

<p>This proposal introduces several new concepts as extensions to the ERC-721 standard that warrant explanation:</p>

<ul>
  <li><strong>Royalty Account (RA)</strong>
    <ul>
      <li>A Royalty Account is attached to each NFT through its <code class="language-plaintext highlighter-rouge">tokenId</code> and consists of several sub-accounts which can be accounts of individuals or other RAs. A Royalty Account is identified by an account identifier.</li>
    </ul>
  </li>
  <li><strong>Account Type</strong>
    <ul>
      <li>This specifies if an RA Sub Account belongs to an individual (user) or is another RA. If there is another RA as an RA Sub Account, the allocated balance needs to be reallocated to the Sub Accounts making up the referenced RA.</li>
    </ul>
  </li>
  <li><strong>Royalty Split</strong>
    <ul>
      <li>The percentage each Sub Account receives based on a sale of an NFT that is associated with an RA</li>
    </ul>
  </li>
  <li><strong>Royalty Balance</strong>
    <ul>
      <li>The royalty balance associated with an RA</li>
    </ul>
  </li>
  <li><strong>Sub Account Royalty Balance</strong>
    <ul>
      <li>The royalty balance associated to each RA Sub Account. Note that only individual accounts can carry a balance that can be paid out. That means that if an RA Sub Account is an RA, its final Sub Account balance must be zero, since all RA balances must be allocated to individual accounts.</li>
    </ul>
  </li>
  <li><strong>Token Type</strong>
    <ul>
      <li>Token Type is given as either ETH or the symbol of the supported utility tokens such as <code class="language-plaintext highlighter-rouge">DAI</code></li>
    </ul>
  </li>
  <li><strong>Asset ID</strong>
    <ul>
      <li>This is the <code class="language-plaintext highlighter-rouge">tokenId</code> the RA belongs to.</li>
    </ul>
  </li>
  <li><strong>Parent</strong>
    <ul>
      <li>This indicates which <code class="language-plaintext highlighter-rouge">tokenId</code> is the immediate parent of the <code class="language-plaintext highlighter-rouge">tokenId</code> to which an RA belongs.</li>
    </ul>
  </li>
</ul>

<p>Below a non-normative overview is given of the data structures and functionality that are covered by the requirements in this document.</p>

<h4 id="data-structures">Data Structures</h4>

<p>In order to create an interconnected data structure linking NFTs to RAs certain global data structures are required:</p>

<ul>
  <li>A Royalty Account and associated Royalty Sub Accounts to establish the concept of a Royalty Account with sub accounts.</li>
  <li>Connecting a <code class="language-plaintext highlighter-rouge">tokenId</code> to a Royalty Account identifier.</li>
  <li>A structure mapping parent-to-child NFT relationships.</li>
  <li>A listing of token types and last validated balance (for trading and royalty payment purposes)</li>
  <li>A listing of registered payments to be made in the <code class="language-plaintext highlighter-rouge">executePayment</code> function and validated in <code class="language-plaintext highlighter-rouge">safeTransferFrom</code>. This is sufficient, because a payment once received and distributed in the <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> function will be removed from the listing.</li>
  <li>A listing of NFTs to be sold</li>
</ul>

<h4 id="royalty-account-functions">Royalty Account Functions</h4>

<p>Definitions and interfaces for the Royalty Account RUD (Read-Update-Delete) functions. Because the RA is created in the minting function, there is no need to have a function to create a royalty account separately.</p>

<h4 id="minting-of-a-royalty-bearing-nft">Minting of a Royalty Bearing NFT</h4>

<p>When an NFT is minted, an RA must be created and associated with the NFT and the NFT owner, and, if there is an ancestor, with the ancestor’s RA. To this end the specification utilizes the <code class="language-plaintext highlighter-rouge">_safemint</code> function in a newly defined <code class="language-plaintext highlighter-rouge">mint</code> function and applies various business rules on the input variables.</p>

<h4 id="listing-nfts-for-sale-and-removing-a-listing">Listing NFTs for Sale and removing a Listing</h4>

<p>Authorized user addresses can list NFTs for sale for non-exchange mediated NFT purchases.</p>

<h4 id="payment-function-from-buyer-to-seller">Payment Function from Buyer to Seller</h4>

<p>To avoid royalty circumvention, a buyer will always pay the NFT contract directly and not the seller. The seller is paid through the royalty distribution and can later request a payout.</p>

<p>The payment process depends on whether the payment is received in ETH or an <a href="./eip-20.md">ERC-20</a> token:</p>

<ul>
  <li>ERC-20 Token
    <ol>
      <li>The Buyer must <code class="language-plaintext highlighter-rouge">approve</code> the NFT contract for the purchase price, <code class="language-plaintext highlighter-rouge">payment</code> for the selected payment token (ERC-20 contract address).</li>
      <li>For an ERC-20 payment token, the Buyer must then call the <code class="language-plaintext highlighter-rouge">executePayment</code> in the NFT contract – the ERC-20 is not directly involved.</li>
    </ol>
  </li>
  <li>For a non-ERC-20 payment, the Buyer must send a protocol token (ETH) to the NFT contract, and is required to send <code class="language-plaintext highlighter-rouge">msg.data</code> encoded as an array of purchased NFTs <code class="language-plaintext highlighter-rouge">uint256[] tokenId</code>.</li>
</ul>

<h4 id="modified-nft-transfer-function-including-required-trade-data-to-allocate-royalties">Modified NFT Transfer Function including required Trade data to allocate Royalties</h4>

<p>The input parameters must satisfy several requirements for the NFT to be transferred AFTER the royalties have been properly distributed. Furthermore, the ability to transfer more than one token at a time is also considered.</p>

<p>The proposal defines:</p>

<ul>
  <li>Input parameter validation</li>
  <li>Payment Parameter Validation</li>
  <li>Distributing Royalties</li>
  <li>Update Royalty Account ownership with payout</li>
  <li>Transferring Ownership of the NFT</li>
  <li>Removing the Payment entry in <code class="language-plaintext highlighter-rouge">registeredPayment</code> after successful transfer</li>
</ul>

<p>Lastly, the approach to distributing royalties is to break down the hierarchical structure of interconnected Royalty Accounts into layers and then process one layer at time, where each relationship between a token and its ancestor is utilized to traverse the Royalty Account chain until the root ancestor and associated RA is reached.</p>

<h4 id="paying-out-royalties-to-the-nft-owner--from-address-in-safetransferfrom-function">Paying out Royalties to the NFT Owner – <code class="language-plaintext highlighter-rouge">from</code> address in <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> Function</h4>

<p>This is the final part of the proposal.</p>

<p>There are two versions of the payout function – a <code class="language-plaintext highlighter-rouge">public</code> function and an <code class="language-plaintext highlighter-rouge">internal</code> function.</p>

<p>The public function has the following interface:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual nonReentrant returns (bool)
</code></pre></div></div>

<p>where we only need the <code class="language-plaintext highlighter-rouge">tokenId</code>, the RA Sub Account address, <code class="language-plaintext highlighter-rouge">_RAsubaccount</code> which is the <code class="language-plaintext highlighter-rouge">owner</code>, and the amount to be paid out, <code class="language-plaintext highlighter-rouge">_amount</code>. Note that the function has <code class="language-plaintext highlighter-rouge">nonReentrant</code> modifier protection, because funds are being payed out.</p>

<p>To finally send a Payout payment, the following steps need to be taken:</p>

<ul>
  <li>find the RA Sub Account based on <code class="language-plaintext highlighter-rouge">RAaccount</code> and the <code class="language-plaintext highlighter-rouge">subaccountPos</code> and extract the balance</li>
  <li>extract <code class="language-plaintext highlighter-rouge">tokenType</code> from the Sub Account</li>
  <li>based on the token type, send the payout payment (not exceeding the available balance)</li>
</ul>

<h3 id="data-structures-1">Data Structures</h3>

<h4 id="royalty-account-and-royalty-sub-accounts">Royalty Account and Royalty Sub Accounts</h4>

<p>In order to create an interconnected data structure linking NFTs to RAs that is search optimized requires to make the following additions to the global data structures of an ERC-721.</p>

<p>Note, a Royalty Account is defined as a collection of Royalty Sub Accounts linked to a meta account. This meta account is comprised of general account identifiers particular to the NFT it is linked to such as asset identifier, parent identifier etc.</p>

<p><a name="r1"><strong>[R1]</strong></a> <em>One or more Royalty Sub-Account MUST be linked to a Royalty Account.</em></p>

<p><a name="r2"><strong>[R2]</strong></a> <em>The account identifier of a Royalty Account, <code class="language-plaintext highlighter-rouge">raAccountId</code>, MUST be unique.</em></p>

<p><a name="r3"><strong>[R3]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">tokenId</code> of a NFT MUST be linked to a <code class="language-plaintext highlighter-rouge">raAccountID</code> in order to connect an <code class="language-plaintext highlighter-rouge">raAccountId</code> to a <code class="language-plaintext highlighter-rouge">tokenId</code>.</em></p>

<h4 id="print-child-nfts">Print (Child) NFTs</h4>

<p>The set of requirement to manage Parent-Child NFT Relationships and constraints at each level of the NFT (family) tree e.g. number of children permitted, NFT parents have to be linked to their immediate NFT children are as follows.</p>

<p><a name="r4"><strong>[R4]</strong></a> <em>There MUST be a link for direct parent-child relationships</em></p>

<h4 id="nft-payment-tokens">NFT Payment Tokens</h4>

<p>In order to capture royalties, an NFT contract must be involved in NFT trading. Therefore, the NFT contract needs to be aware of NFT payments, which in turn requires the NFT contract to be aware which tokens can be used for trading.</p>

<p><a name="r5"><strong>[R5]</strong></a> <em>There MUST be a listing of supported token types</em></p>

<p>Since the NFT contract is managing royalty distributions and payouts as well as sales, it needs to track the last available balances of the allowed token types owned by the contract.</p>

<p><a name="r6"><strong>[R6]</strong></a> <em>There MUST be a link of the last validated balance of an allowed token type in the contract to the respective allowed token contract.</em></p>

<h4 id="nft-listings-and-payments">NFT Listings and Payments</h4>

<p>Since the contract is directly involved in the sales process, a capability to list one or more NFTs for sale is required.</p>

<p><a name="r7"><strong>[R7]</strong></a> <em>There MUST be a list of NFTs for sale.</em></p>

<p><a name="r8"><strong>[R8]</strong></a> <em>A sales listing MUST have a unique identifier.</em></p>

<p>Besides listings, the contract is required to manage sales as well. This requires the capability to register a payment, either for immediate execution or for later payment such as in an auction situation.</p>

<p><a name="r9"><strong>[R9]</strong></a> <em>There MUST be a listing for registered payments</em></p>

<p><a name="r10"><strong>[R10]</strong></a> <em>A registered payment MUST have a unique identifier.</em></p>

<h4 id="contract-constructor-and-global-variables-and-their-update-functions">Contract Constructor and Global Variables and their update functions</h4>

<p>This standard extends the current ERC-721 constructor, and adds several global variables to recognize the special role of the creator of an NFT, and the fact that the contract is now directly involved in managing sales and royalties.</p>

<p><a name="r11"><strong>[R11]</strong></a> <em>The minimal contract constructor MUST contain the following input elements.</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>///
/// @dev Definition of the contract constructor
///
/// @param name as in ERC-721
/// @param symbol as in ERC-721
/// @param baseTokenURI as in ERC-721
/// @param allowedTokenTypes is the array of allowed tokens for payment

constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI,
        address[] memory allowedTokenTypes
    ) ERC721(name, symbol) {...}
</code></pre></div></div>

<h3 id="royalty-account-management">Royalty Account Management</h3>

<p>Below are the definitions and interfaces for the Royalty Account RUD (Read-Update-Delete) functions. Since a Royalty Account is created in the NFT minting function, there is no need to have a separate function to create a royalty account.</p>

<h4 id="get-a-royalty-account">Get a Royalty Account</h4>

<p>There is only one get function required because a Royalty Account and its sub accounts can be retrieved through the <code class="language-plaintext highlighter-rouge">tokenId</code> in the <code class="language-plaintext highlighter-rouge">ancestry</code> field of the Royalty Account.</p>

<p><a name="r12"><strong>[R12]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">getRoyaltyAccount</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to fetch a Royalty Account for a given tokenId
/// @param tokenId is the identifier of the NFT to which a Royalty Account is attached
/// @param RoyaltyAccount is a data structure containing the royalty account information
/// @param RASubAccount[] is an array of data structures containing the information of the royalty sub accounts associated with the royalty account

function getRoyaltyAccount (uint256 tokenId) public view virtual returns (address,
            RoyaltyAccount memory,
            RASubAccount[] memory);
</code></pre></div></div>

<p><a name="r13"><strong>[R13]</strong></a> <em>The following business rules MUST be enforced in the <code class="language-plaintext highlighter-rouge">getRoyaltyAccount</code> function:</em></p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">tokenId</code> exists and is not burned</em></li>
</ul>

<h4 id="update-a-royalty-account">Update a Royalty Account</h4>

<p>In order to update a Royalty Account, the caller must have both the ‘tokenId’ and the <code class="language-plaintext highlighter-rouge">RoyaltyAccount</code> itself which can be obtained from the Royalty Account getter function.</p>

<p><a name="r14"><strong>[R14]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">updateRoyaltyAccount</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to update a Royalty Account and its Sub Accounts
/// @param tokenId is the identifier of the NFT to which the Royalty Account to be updated is attached
/// @param RoyaltyAccount is the Royalty Account and associated Royalty Sub Accounts with updated values  

function updateRoyaltyAccount (uint256 _tokenId, `RoyaltyAccount memory _raAccount) public virtual returns (bool)
</code></pre></div></div>

<p>The update functionality of a Royalty Account, while straightforward, is also highly nuanced. To avoid complicated change control rules such as multi-signature rules, Royalty Account changes are kept simple.</p>

<p><a name="r15"><strong>[R15]</strong></a> <em>The business rules for the update function are as follows:</em></p>

<ol>
  <li><em>An NFTs asset identifier MUST NOT be changed.</em></li>
  <li><em>An NFTs ancestor MUST NOT be updated.</em></li>
  <li><em>An NFTs token type accepted for payment MUST NOT be updated.</em></li>
  <li><em>The royalty balance in a Royalty Sub Account MUST NOT be changed.</em></li>
  <li><em>The royalty split inherited by the children from the NFT parent MUST NOT be changed.</em></li>
  <li><em>New royalty split values MUST be larger than, or less than, or equal to any established boundary value for royalty splits, if it exists.</em></li>
  <li><em>The number of existing Royalty Sub Account plus the number of new Royalty Sub Accounts to be added MUST be smaller or equal to an established boundary value, if it exists.</em></li>
  <li><em>The sum of all royalty splits across all existing and new Royalty Sub Accounts MUST equal to 1 or its equivalent numerical value at all times.</em></li>
  <li>
    <p><em>‘msg.sender` MUST be equal to an account identifier in the Royalty Sub Account of the Royalty Account to be modified and that royalty sub account must be identified as not belonging to the parent NFT</em></p>

    <p>9.1 <em>the Sub Account belonging to the account identifier MUST NOT be removed</em></p>

    <p>9.2 <em>A royalty split MUST only be decreased, and either the existing sub account’s  royalty split MUST be increased accordingly such that the sum of all royalty splits remains equal to 1 or its numerical equivalent, or one or more new Royalty Sub Accounts MUST be added according to rule 10.</em></p>

    <p>9.3 <em>a royalty balance MUST NOT be changed</em></p>

    <p>9.4 <em>an account identifier MUST NOT be NULL</em></p>
  </li>
  <li>
    <p><em>If <code class="language-plaintext highlighter-rouge">msg.sender</code> is equal to the account identifier of one of the Sub Account owners which is not the parent NFT, an additional Royalty Sub Accounts MAY be added</em></p>

    <p>10.1 <em>if the royalty split of the Royalty Sub Account belonging to <code class="language-plaintext highlighter-rouge">msg.sender</code> is reduced</em></p>

    <ul>
      <li>
        <p>then the royalty balance in each new Royalty Sub Account MUST be zero</p>
      </li>
      <li>
        <p>and the sum of the new royalty splits data MUST be equal to the royalty split of the Royalty Sub Account of <code class="language-plaintext highlighter-rouge">msg.sender</code> before it was modified</p>
      </li>
    </ul>

    <p>10.2 <em>new account identifier MUST not be NULL</em></p>
  </li>
  <li><em>If the Royalty Account update is correct, the function returns <code class="language-plaintext highlighter-rouge">true</code>, otherwise <code class="language-plaintext highlighter-rouge">false</code>.</em></li>
</ol>

<h4 id="deleting-a-royalty-account">Deleting a Royalty Account</h4>

<p>While sometimes deleting a Royalty Account is necessary, even convenient, it is a very costly function in terms of gas, and should not be used unless one is absolutely sure that the conditions enumerated below are met.</p>

<p><a name="r16"><strong>[R16]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">deleteRoyaltyAccount</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to delete a Royalty Account
/// @param tokenId is the identifier of the NFT to which the Royalty Account to be updated is attached

function deleteRoyaltyAccount (uint256 _tokenId) public virtual returns (bool)
</code></pre></div></div>

<p><a name="r17"><strong>[R17]</strong></a> <em>The business rules for this function are as follows:</em></p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">_tokenId</code> MUST be burned, i.e., have owner <code class="language-plaintext highlighter-rouge">address(0)</code>.</em></li>
  <li><em>all <code class="language-plaintext highlighter-rouge">tokenId</code> numbers genealogically related to <code class="language-plaintext highlighter-rouge">_tokenId</code> either as ancestors or offspring MUST also be burnt.</em></li>
  <li><em>all balances in the Royalty Sub Accounts MUST be zero.</em></li>
</ul>

<h3 id="nft-minting">NFT Minting</h3>

<p>In extension to the ERC-721 minting capability, a Royalty Account with Royalty Sub Accounts are required to be added during the minting, besides establishing the NFT token specific data structures supporting constraints such as the maximum number of children an NFT can have.</p>

<p><a name="r18"><strong>[R18]</strong></a> <em>When a new NFT is minted a Royalty Account with one or more Royalty Sub Accounts MUST be created and associated with the NFT and the NFT owner, and, if there is an ancestor, with the ancestor’s Royalty Account.</em></p>

<p>To this end the specification utilizes the ERC-721 <code class="language-plaintext highlighter-rouge">_safemint</code> function in a newly defined <code class="language-plaintext highlighter-rouge">mint</code> function, and applies various business rules on the function’s input variables.</p>

<p><a name="d1"><strong>[D1]</strong></a> <em>Note, that the <code class="language-plaintext highlighter-rouge">mint</code> function SHOULD have the ability to mint more than one NFT at a time.</em></p>

<p><a name="r19"><strong>[R19]</strong></a> <em>Also, note that the <code class="language-plaintext highlighter-rouge">owner</code> of a new NFT MUST be the NFT contract itself.</em></p>

<p><a name="r20"><strong>[R20]</strong></a> <em>The non-contract owner of the NFT MUST be set as <code class="language-plaintext highlighter-rouge">isApproved</code> which allows the non-contract owner to operate just like the <code class="language-plaintext highlighter-rouge">owner</code>.</em></p>

<p>This strange choice in the two requirements above is necessary, because the NFT contract functions as an escrow for payments and royalties, and, hence, needs to be able to track payments received from buyers and royalties due to recipients, and to associate them with a valid <code class="language-plaintext highlighter-rouge">tokenId</code>.</p>

<p><a name="r21"><strong>[R21]</strong></a> <em>For compactness of the input, and since the token meta data might vary from token to token the MUST be a minimal data structure containing:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @param parent is the parent tokenId of the (child) token, and if set to 0 then there is no parent.
/// @param canBeParent indicates if a tokenId can have children or not.
/// @param maxChildren defines how many children an NFT can have.
/// @param royaltySplitForItsChildren is the royalty percentage split that a child has to pay to its parent.
/// @param uri is the unique token URI of the NFT
</code></pre></div></div>

<p><a name="r22"><strong>[R22]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">mint</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function creates one or more new NFTs with its relevant meta data necessary for royalties, and a Royalty Account with its associated met data for `to` address. The tokenId(s) will be automatically assigned (and available on the emitted {IERC-721-Transfer} event).
/// @param to is the address to which the NFT(s) are minted
/// @param nfttoken is an array of struct type NFTToken for the meta data of the minted NFT(s)
/// @param tokenType is the type of allowed payment token for the NFT

function mint(address to, NFTToken[] memory nfttoken, address tokenType) public virtual
</code></pre></div></div>

<p><a name="r23"><strong>[R23]</strong></a> <em>The following business rules for the <code class="language-plaintext highlighter-rouge">mint</code> function’s input data MUST be fulfilled:</em></p>

<ul>
  <li><em>The number of tokens to be minted MUST NOT be zero.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender</code> MUST have either the <code class="language-plaintext highlighter-rouge">MINTER_ROLE</code> or the <code class="language-plaintext highlighter-rouge">CREATOR_Role</code> identifying the creator of the first NFT.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">to</code> address MUST NOT be the zero address.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">to</code> address MUST NOT be a contract, unless it has been whitelisted – see <a href="#security-considerations">Security Considerations</a> for more details.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenType</code> MUST be a token type supported by the contract.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">royaltySplitForItsChildren</code> MUST be less or equal to 100% or numerical equivalent thereof less any constraints such as platform fees</em></li>
  <li><em>If the new NFT(s) cannot have children, <code class="language-plaintext highlighter-rouge">royaltySplitForItsChildren</code> MUST be zero.</em></li>
  <li><em>If the new NFT(s) has a parent, the parent NFT <code class="language-plaintext highlighter-rouge">tokenId</code> MUST exist.</em></li>
  <li><em>The ancestry level of the parent MUST be less than the maximum number of allowed NFT generations, if specified.</em></li>
  <li><em>The number of allowed children for an NFT to be minted MUST be less than the maximum number of allowed children, if specified.</em></li>
</ul>

<h3 id="listing-and-de-listing-of-nfts-for-direct-sales">Listing and De-Listing of NFTs for Direct Sales</h3>

<p>In the sales process, we need to minimally distinguish two types of transactions</p>

<ul>
  <li>Exchange-mediated sales</li>
  <li>Direct sales</li>
</ul>

<p>The first type of transaction does not require that the smart contract is aware of a sales listing since the exchange contract will trigger payment and transfer transactions directly with the NFT contract as the owner. However, for the latter transaction type it is essential, since direct sales are required to be mediated at every step by the smart contract.</p>

<p><a name="r24"><strong>[R24]</strong></a> <em>For direct sales, NFT listing, und de-listing, transactions MUST be executed through the NFT smart contract.</em></p>

<p>Exchange-mediated sales will be discussed when this document discusses payments.</p>

<p>In direct sales, authorized user addresses can list NFTs for sale, see the business rules below.</p>

<p><a name="r25"><strong>[R25]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">listNFT</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to list one or more NFTs for direct sales
/// @param tokenIds is the array of tokenIds to be included in the listing
/// @param price is the price set by the owner for the listed NFT(s)
/// @param tokenType is the payment token type allowed for the listing

function listNFT (uint256[] calldata tokenIds, uint256 price, address tokenType) public virtual returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p><a name="r26"><strong>[R26]</strong></a> <em>The business rules of the <code class="language-plaintext highlighter-rouge">listNFT</code> function are as follows:</em></p>

<ul>
  <li>there MUST NOT already be a listing for one or more NFTs in the <code class="language-plaintext highlighter-rouge">listedNFT</code> mapping of the proposed listing.</li>
  <li><code class="language-plaintext highlighter-rouge">seller</code> MUST be equal to <code class="language-plaintext highlighter-rouge">getApproved(tokenId[i])</code> for all NFTs in the proposed listing.</li>
  <li><code class="language-plaintext highlighter-rouge">tokenType</code> MUST be supported by the smart contract.</li>
  <li><code class="language-plaintext highlighter-rouge">price</code> MUST be larger than <code class="language-plaintext highlighter-rouge">0</code>.</li>
</ul>

<p><a name="r27"><strong>[R27]</strong></a> <em>If the conditions in <a href="#r26"><strong>[R26]</strong></a> are met, then the NFT sales list MUST be updated.</em></p>

<p>Authorized user addresses can also remove a direct sale listing of NFTs.</p>

<p><a name="r28"><strong>[R28]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">removeNFTListing</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to de-list one or more NFTs for direct sales
/// @param listingId is the identifier of the NFT listing

function removeNFTListing (uint256 listingId) public virtual returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p><a name="r29"><strong>[R29]</strong></a> <em>The business rules of the <code class="language-plaintext highlighter-rouge">removeNFTListing</code> function below MUST be adhered to:</em></p>

<ul>
  <li><em>the registered payment entry MUST be NULL</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender = getApproved(tokenId)</code> for the NFT listing</em></li>
</ul>

<p><a name="r30"><strong>[R30]</strong></a> <em>If the conditions in <a href="#r29"><strong>[R29]</strong></a> are met, then the NFT sales listing MUST be removed.</em></p>

<h3 id="payments-for-nft-sales">Payments for NFT Sales</h3>

<p>As noted before, a buyer will always pay the NFT contract directly and not the seller. The seller is paid through the royalty distribution and can later request a payout to their wallet.</p>

<p><a name="r31"><strong>[R31]</strong></a> <em>The payment process requires either one or two steps:</em></p>

<ol>
  <li><em>For an ERC-20 token</em>
    <ul>
      <li><em>The buyer MUST <code class="language-plaintext highlighter-rouge">approve</code> the NFT contract for the purchase price, <code class="language-plaintext highlighter-rouge">payment</code>, for the selected payment token type.</em></li>
      <li><em>The buyer MUST call the <code class="language-plaintext highlighter-rouge">executePayment</code> function.</em></li>
    </ul>
  </li>
  <li><em>For a protocol token</em>
    <ul>
      <li><em>The buyer MUST call a payment fallback function with <code class="language-plaintext highlighter-rouge">msg.data</code> not NULL.</em></li>
    </ul>
  </li>
</ol>

<p><a name="r32"><strong>[R32]</strong></a> <em>For an ERC-20 token type, the required <code class="language-plaintext highlighter-rouge">executePayment</code> function interface MUST adhere to the definition below</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to make a NFT direct sales or exchange-mediate sales payment
/// @param receiver is the address of the receiver of the payment
/// @param seller is the address of the NFT seller 
/// @param tokenIds are the tokenIds of the NFT to be bought
/// @param payment is the amount of that payment to be made
/// @param tokenType is the type of payment token
/// @param trxnType is the type of payment transaction -- minimally direct sales or exchange-mediated

function executePayment (address receiver, address seller, uint 256[] tokenIds, uint256 payment, string tokenType, int256 trxnType) public virtual nonReentrant returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p><a name="r33"><strong>[R33]</strong></a> <em>Independent of <code class="language-plaintext highlighter-rouge">trxnType</code>, the business rules for the input data are as follows:</em></p>

<ul>
  <li><em>All purchased NFTs in the <code class="language-plaintext highlighter-rouge">tokenIds</code> array MUST exist and MUST NOT be burned.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenType</code> MUST be a supported token.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">trxnType</code> MUST be set to either <code class="language-plaintext highlighter-rouge">0</code> (direct sale) or <code class="language-plaintext highlighter-rouge">1</code> (exchange-mediate sale), or another supported type.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">receiver</code> MAY be NULL but MUST NOT be the Zero Address.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">seller</code> MUST be the address in the corresponding listing.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender</code> MUST not be a contract, unless it is whitelisted in the NFT contract.</em></li>
</ul>

<p>In the following, this document will only discuss the differences between the two minimally required transaction types.</p>

<p><a name="r34"><strong>[R34]</strong></a> <em>For <code class="language-plaintext highlighter-rouge">trxnType = 0</code>, the payment data MUST to be validated against the listing, based on the following rules:</em></p>

<ul>
  <li><em>NFT(s) MUST be listed</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">payment</code> MUST be larger or equal to the listing price.</em></li>
  <li><em>The listed NFT(s) MUST match the NFT(s) in the payment data.</em></li>
  <li><em>The listed NFT(s) MUST be controlled by <code class="language-plaintext highlighter-rouge">seller</code>.</em></li>
</ul>

<p><a name="r35"><strong>[R35]</strong></a> <em>If all checks in <a href="#r33"><strong>[R33]</strong></a>, and in <a href="#r34"><strong>[R34]</strong></a> for <code class="language-plaintext highlighter-rouge">trxnType = 0</code>, are passed, the <code class="language-plaintext highlighter-rouge">executePayment</code> function MUST call the <code class="language-plaintext highlighter-rouge">transfer</code> function in the ERC-20 contract identified by <code class="language-plaintext highlighter-rouge">tokenType</code> with <code class="language-plaintext highlighter-rouge">recipient = address(this)</code> and <code class="language-plaintext highlighter-rouge">amount = payment</code>.</em></p>

<p>Note the NFT contract pays itself from the available allowance set in the <code class="language-plaintext highlighter-rouge">approve</code> transaction from the buyer.</p>

<p><a name="r36"><strong>[R36]</strong></a> <em>For <code class="language-plaintext highlighter-rouge">trxnType = 1</code>, and for a successful payment, the <code class="language-plaintext highlighter-rouge">registeredPayment</code> mapping MUST updated with the payment, such that it can be validated when the NFT is transferred in a separate <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> call, and <code class="language-plaintext highlighter-rouge">true</code> MUST be returned as the return value of the function, if successful, <code class="language-plaintext highlighter-rouge">false</code> otherwise.</em></p>

<p><a name="r37"><strong>[R37]</strong></a> <em>For <code class="language-plaintext highlighter-rouge">trxnType = 0</code>, an <code class="language-plaintext highlighter-rouge">internal</code> version of the <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> function with message data MUST be called to transfer the NFTs to the buyer, and upon success, the buyer MUST be given the <code class="language-plaintext highlighter-rouge">MINTER_ROLE</code>, unless the buyer already has that role.</em></p>

<p>Note, the <code class="language-plaintext highlighter-rouge">_safeTransferFrom</code> function has the same structure as <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> but skips the input data validation.</p>

<p><a name="r38"><strong>[R38]</strong></a> <em>For <code class="language-plaintext highlighter-rouge">trxnType = 0</code>, and if the NFT transfer is successful, the listing of the NFT MUST be removed.</em></p>

<p><a name="r39"><strong>[R39]</strong></a> <em>For a protocol token as a payment token, and independent of <code class="language-plaintext highlighter-rouge">trxnType</code>, the buyer MUST send protocol tokens to the NFT contract as the escrow, and <code class="language-plaintext highlighter-rouge">msg.data</code> MUST encode the array of paid for NFTs <code class="language-plaintext highlighter-rouge">uint256[] tokenIds</code>.</em></p>

<p><a name="r40"><strong>[R40]</strong></a> <em>For the NFT contract to receive a protocol token, a payable fallback function (<code class="language-plaintext highlighter-rouge">fallback() external payable</code>) MUST be implemented.</em></p>

<p>Note that since the information for which NFTs the payment was for must be passed, a simple <code class="language-plaintext highlighter-rouge">receive()</code> fallback function cannot be allowed since it does not allow for <code class="language-plaintext highlighter-rouge">msg.data</code> to be sent with the transaction.</p>

<p><a name="r41"><strong>[R41]</strong></a> <em><code class="language-plaintext highlighter-rouge">msg.data</code> for the fallback function MUST minimally contain the following data:
<code class="language-plaintext highlighter-rouge">address memory seller, uint256[] memory _tokenId, address memory receiver, int256 memory trxnType</code></em></p>

<p><a name="r42"><strong>[R42]</strong></a> <em>If <code class="language-plaintext highlighter-rouge">trxnType</code> is not equal to either ‘0’ or ‘1’, or another supported type, then the fallback function MUST <code class="language-plaintext highlighter-rouge">revert</code>.</em></p>

<p><a name="r43"><strong>[R43]</strong></a> <em>For <code class="language-plaintext highlighter-rouge">trxnType</code> equal to either ‘0’ or ‘1’, the requirements <a href="#r33"><strong>[R33]</strong></a> through <a href="#r38"><strong>[R38]</strong></a> MUST be satisfied for the fallback function to successfully execute, otherwise the fallback function MUST <code class="language-plaintext highlighter-rouge">revert</code>.</em></p>

<p><a name="r44"><strong>[R44]</strong></a> <em>In case of a transaction failure (for direct sales, <code class="language-plaintext highlighter-rouge">trxnType = 0</code>), or the buyer of the NFT listing changing their mind (for exchange-mediated sales, <code class="language-plaintext highlighter-rouge">trxnType = 1</code>), the submitted payment MUST be able to revert using the <code class="language-plaintext highlighter-rouge">reversePayment</code> function where the function interface is defined below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Definition of the function enabling the reversal of a payment before the sale is complete
/// @param paymentId is the unique identifier for which a payment was made
/// @param tokenType is the type of payment token used in the payment
function reversePayment(uint256 paymentId, string memory tokenType) public virtual returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p>Note, <code class="language-plaintext highlighter-rouge">reentrancy</code> protection through e.g. <code class="language-plaintext highlighter-rouge">nonReentrant</code> from the Open Zeppelin library is strongly advised since funds are being paid out.</p>

<p><a name="r45"><strong>[R45]</strong></a> <em>The business rules for the <code class="language-plaintext highlighter-rouge">reversePayment</code> function are as follows:</em></p>

<ul>
  <li><em>There MUST be registered payment for a given <code class="language-plaintext highlighter-rouge">paymentId</code> and <code class="language-plaintext highlighter-rouge">tokenType</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender</code> MUST be the buyer address in the registered payment.</em></li>
  <li><em>The payment amount must be larger than <code class="language-plaintext highlighter-rouge">0</code>.</em></li>
  <li><em>The registered payment MUST be removed when the payment has been successfully reverted, otherwise the function must fail.</em></li>
</ul>

<h3 id="modified-nft-transfer-function">Modified NFT Transfer function</h3>

<p>This document adheres to the ERC-721 interface format for the <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> function as given below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external virtual override
</code></pre></div></div>

<p>Note, that the input parameters must satisfy several requirements for the NFT(s) to be transferred AFTER royalties have been properly distributed. Note also, that the ability to transfer more than one token at a time is required. However, the standard interface only allows one token to be transferred at a time. In order to remain compliant with the ERC-721 standard, this document uses <code class="language-plaintext highlighter-rouge">tokenId</code> only for the first NFT to be transferred. All other transfer relevant data is encoded in <code class="language-plaintext highlighter-rouge">_data</code>.</p>

<p>The high-level requirements are as follows:</p>

<ul>
  <li>The payment parameters of the trade encoded in <code class="language-plaintext highlighter-rouge">_data</code> must be validated.</li>
  <li>The seller and the sold NFT token(s) must exist, and the seller must be the owner of the token.</li>
  <li><code class="language-plaintext highlighter-rouge">msg.sender</code> must be the seller address or an approved address.</li>
  <li>the payment of the trade received by the NFT smart contract is correctly disbursed to all Royalty Sub Account owners.</li>
  <li>the NFT token is transferred after all Royalty Sub Accounts and their holders associated with the NFT token(s) have been properly credited.</li>
</ul>

<p>Also, note that in order to avoid royalty circumvention attacks, there is only one NFT transfer function.</p>

<p><a name="r46"><strong>[R46]</strong></a> <em>Therefore, <code class="language-plaintext highlighter-rouge">transferFrom</code> and <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> without <code class="language-plaintext highlighter-rouge">data</code> MUST be disabled.</em></p>

<p>This can be achieved through for example a <code class="language-plaintext highlighter-rouge">revert</code> statement in an <code class="language-plaintext highlighter-rouge">override</code> function.</p>

<p><a name="r47"><strong>[R47]</strong></a> <em>The requirements on input parameters of the function are as follows</em>:</p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">from</code> MUST not be <code class="language-plaintext highlighter-rouge">address(0)</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">from</code> MUST be the owner or <code class="language-plaintext highlighter-rouge">approved</code> for <code class="language-plaintext highlighter-rouge">tokenId</code> and the other tokens included in <code class="language-plaintext highlighter-rouge">_data</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">from</code> MUST not be a smart contract unless whitelisted.</em></li>
  <li><em>a Royalty Account MUST be associated to <code class="language-plaintext highlighter-rouge">tokenId</code> and the other tokens included in <code class="language-plaintext highlighter-rouge">_data</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">_data</code> MUST NOT be NULL.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender</code> MUST be equal to <code class="language-plaintext highlighter-rouge">from</code> or an <code class="language-plaintext highlighter-rouge">approved</code> address, or a whitelisted contract.</em></li>
</ul>

<p>Note, that in the context of this document only the scenario where the calling contract is still being created, i.e., the constructor being executed is a possible attack vector, and should to be carefully treated in the transfer scenario.</p>

<p>Turning to the <code class="language-plaintext highlighter-rouge">_data</code> object.</p>

<p><a name="r48"><strong>[R48]</strong></a> <em>The <code class="language-plaintext highlighter-rouge">_data</code> object MUST minimally contain the following payment parameters:</em></p>

<ul>
  <li><em>Seller Address as <code class="language-plaintext highlighter-rouge">address</code>.</em></li>
  <li><em>Buyer Address as <code class="language-plaintext highlighter-rouge">address</code>.</em></li>
  <li><em>Receiver Address as `address.</em></li>
  <li><em>Token identifiers as <code class="language-plaintext highlighter-rouge">uint256[]</code>.</em></li>
  <li><em>Token type used for payment.</em></li>
  <li><em>Payment amount paid to NFT contract as <code class="language-plaintext highlighter-rouge">uint256</code>.</em></li>
  <li><em>a registered payment identifier.</em></li>
  <li><em>blockchain ID, <code class="language-plaintext highlighter-rouge">block.chainid</code>, of the underlying blockchain.</em></li>
</ul>

<p><a name="r49"><strong>[R49]</strong></a> <em>The following business rules MUST be met for the payment data in ‘_data’:</em></p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">seller == from</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenId[0] == tokenId</code>.</em></li>
  <li><em>Each token in <code class="language-plaintext highlighter-rouge">_tokenId</code> has an associated Royalty Account.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">chainid == block.chainid</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">buyer</code> is equal to the buyer address in the registered payment for the given ``paymentId.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">receiver == to</code>.</em></li>
  <li><em>the receiver of the token is not the seller.</em></li>
  <li><em>the receiver of the token is not a contract or is a whitelisted contract</em></li>
  <li><em>For all NFTs in the payment, <code class="language-plaintext highlighter-rouge">tokenId[i] = registeredPayment[paymentId].boughtTokens[i]</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenType</code> is supported in the contract.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">allowedToken[tokenType]</code> is not NULL.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenType = registeredPayment[paymentId].tokenType</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">payment &gt; lastBalanceAllowedToken[allowedToken[listingId]]</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">payment = registeredPayment[paymentId].payment</code>.</em></li>
</ul>

<h3 id="distributing-royalties-in-the-transfer-function">Distributing Royalties in the Transfer Function</h3>

<p>The approach to distributing royalties is to break down the hierarchical structure of interconnected Royalty Accounts into layers, and then process one layer at time, where each relationship between a NFT and its ancestor is utilized to traverse the Royalty Account chain until the root ancestor and its associated Royalty Account.</p>

<p>Note, that the distribution function assumes that the payment made is for ALL tokens in the requested transfer. That means, that <code class="language-plaintext highlighter-rouge">payment</code> for the distribution function is equally divided between all NFTs included in the payment.</p>

<p><a name="r5"><strong>[R50]</strong></a> *The <code class="language-plaintext highlighter-rouge">distributePayment</code> function interface MUST adhere to the definition below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to distribute a payment as royalties to a chain of Royalty Accounts
/// @param tokenId is a tokenId included in the sale and used to look up the associated Royalty Account
/// @param payment is the payment (portion) to be distributed as royalties

function distributePayment (uint256 tokenId, uint265 payment) internal virtual returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p>As mentioned before, the internal <code class="language-plaintext highlighter-rouge">distributePayment</code> function is called within the modified <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> function.</p>

<p>Note, that it is necessary to multiply two <code class="language-plaintext highlighter-rouge">uint256</code> numbers with each other – the payment amount with the royalty split percentage expressed as a whole number e.g. <code class="language-plaintext highlighter-rouge">10000 = 100%</code>. And then divide the result by the whole number representing <code class="language-plaintext highlighter-rouge">100%</code> in order to arrive at the correct application of the royalty split percentage to the payment amount. This requires careful treatment of numbers in the implementation to prevent issues such as buffer over or under runs.</p>

<p><a name="r51"><strong>[R51]</strong></a> <em>The processing logic of <code class="language-plaintext highlighter-rouge">distributePayment</code> function MUST be as follows:</em></p>

<ul>
  <li><em>Load the Royalty Account (<code class="language-plaintext highlighter-rouge">RA</code>) and associated Royalty Sub Accounts using the passed <code class="language-plaintext highlighter-rouge">tokenId</code>.</em></li>
  <li><em>For each Royalty Sub Account in <code class="language-plaintext highlighter-rouge">RA</code> apply the following rules:</em>
    <ul>
      <li><em>If a Royalty Sub Account in <code class="language-plaintext highlighter-rouge">RA</code> has <code class="language-plaintext highlighter-rouge">isIndividual</code> set to <code class="language-plaintext highlighter-rouge">true</code> then</em>
        <ul>
          <li><em>apply the royalty percentage of that Royalty Sub Account to <code class="language-plaintext highlighter-rouge">payment</code> and add the calculated amount, e.g. <code class="language-plaintext highlighter-rouge">royaltyAmountTemp</code>, to the <code class="language-plaintext highlighter-rouge">royaltybalance</code> of that Royalty Sub Account.</em></li>
          <li><em>emit an event as a notification of payment to the <code class="language-plaintext highlighter-rouge">accountId</code> of the Royalty Sub Account containing: assetId, accountId, tokenType, royaltybalance.</em></li>
          <li><em>in the RA add <code class="language-plaintext highlighter-rouge">royaltyamountTemp</code> amount to <code class="language-plaintext highlighter-rouge">balance</code></em></li>
        </ul>
      </li>
      <li><em>If a Royalty Sub Account in <code class="language-plaintext highlighter-rouge">RA</code> has <code class="language-plaintext highlighter-rouge">isIndividual</code> set to <code class="language-plaintext highlighter-rouge">false</code> then</em>
        <ul>
          <li><em>apply the royalty percentage of that Royalty Sub Account to <code class="language-plaintext highlighter-rouge">payment</code> and store temporarily in a new variable e.g. <code class="language-plaintext highlighter-rouge">RApaymenttemp</code>, but do not update the <code class="language-plaintext highlighter-rouge">royaltybalance</code> of the Royalty Sub Account which remains <code class="language-plaintext highlighter-rouge">0</code>.</em></li>
        </ul>
      </li>
      <li><em>then use <code class="language-plaintext highlighter-rouge">ancestor</code> to obtain the <code class="language-plaintext highlighter-rouge">RA</code> connected to <code class="language-plaintext highlighter-rouge">ancestor</code> e.g. via a look up through a Royalty Account mapping.</em></li>
      <li><em>load the new RA</em>
        <ul>
          <li><em>if <code class="language-plaintext highlighter-rouge">isIndividual</code> of the Royalty Sub Account is set to <code class="language-plaintext highlighter-rouge">true</code>, pass through the Royalty Sub Accounts of the next <code class="language-plaintext highlighter-rouge">RA</code>, and apply the rule for <code class="language-plaintext highlighter-rouge">isIndividual = true</code>.</em></li>
          <li><em>if <code class="language-plaintext highlighter-rouge">isIndividual</code> of the Royalty Sub Account is set to <code class="language-plaintext highlighter-rouge">false</code>, pass through the Royalty Sub Accounts of the next <code class="language-plaintext highlighter-rouge">RA</code>, and apply the rule for <code class="language-plaintext highlighter-rouge">isIndividual = false</code>.</em></li>
        </ul>
      </li>
      <li><em>Repeat the procedures for <code class="language-plaintext highlighter-rouge">isIndividual</code> equal to <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code> until a <code class="language-plaintext highlighter-rouge">RA</code> is reached that does not have an <code class="language-plaintext highlighter-rouge">ancestor</code>, and where all Royalty Sub Accounts have<code class="language-plaintext highlighter-rouge">isIndividual</code> set to <code class="language-plaintext highlighter-rouge">true</code>, and apply the rule for a Royalty Sub Account that has <code class="language-plaintext highlighter-rouge">isIndividual</code> set to <code class="language-plaintext highlighter-rouge">true</code> to all Royalty Sub Accounts in that <code class="language-plaintext highlighter-rouge">RA</code>.</em></li>
    </ul>
  </li>
</ul>

<h3 id="update-royalty-sub-account-ownership-with-payout-to-approved-address-from">Update Royalty Sub Account Ownership with Payout to approved Address (<code class="language-plaintext highlighter-rouge">from</code>)</h3>

<p>In order to simplify the ownership transfer, first the approved address – the non-contract NFT owner –, <code class="language-plaintext highlighter-rouge">from</code>, is paid out its share of the royalties. And then the Royalty Sub Account is updated with the new owner, <code class="language-plaintext highlighter-rouge">to</code>. This step repeats for each token to be transferred.</p>

<p><a name="r52"><strong>[R52]</strong></a> <em>The business rules are as follows:</em></p>

<ul>
  <li><em>the internal version of the<code class="language-plaintext highlighter-rouge">royaltyPayOut</code> function MUST pay out the entire royalty balance of the Royalty Sub Account owned by the <code class="language-plaintext highlighter-rouge">from</code> address to the <code class="language-plaintext highlighter-rouge">from</code> address.</em></li>
  <li><em>the Royalty Sub Account MUST only be updated with the new owner only once the payout function has successfully completed and the <code class="language-plaintext highlighter-rouge">royaltybalance = 0</code>.</em></li>
</ul>

<p>The last step in the process chain is transferring the NFTs in the purchase to the <code class="language-plaintext highlighter-rouge">to</code> address.</p>

<p><a name="r53"><strong>[R53]</strong></a> <em>For every NFT (in the batch) the ‘to’ address MUST be `approved’ (ERC-721 function) to complete the ownership transfer:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_approve(to, tokenId[i]);
</code></pre></div></div>

<p>The technical NFT owner remains the NFT contract.</p>

<h3 id="removing-the-payment-entry-after-successful-transfer">Removing the Payment Entry after successful Transfer</h3>

<p>Only after the real ownership of the NFT, the approved address, has been updated, the payment registry entry can be removed to allow the transferred NFTs to be sold again.</p>

<p><a name="r54"><strong>[R54]</strong></a> <em>After the <code class="language-plaintext highlighter-rouge">approve</code> relationship has been successfully updated to the <code class="language-plaintext highlighter-rouge">to</code> address, the registered payment MUST be removed.</em></p>

<h3 id="paying-out-royalties-to-the-from-address-in-safetransferfrom-function">Paying out Royalties to the <code class="language-plaintext highlighter-rouge">from</code> Address in <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> Function</h3>

<p>There are two versions of the payout function – a <code class="language-plaintext highlighter-rouge">public</code> and an <code class="language-plaintext highlighter-rouge">internal</code> function – depending on whether there is a payout during a purchase, or a payout is requested by a Royalty Sub Account owner.</p>

<p><a name="r55"><strong>[R55]</strong></a> <em>The public <code class="language-plaintext highlighter-rouge">royaltyPayOut</code> function interface MUST adhere to the definition below:</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// @dev Function to payout a royalty payment
/// @param tokenId is the identifier of the NFT token
/// @param RAsubaccount is the address of the Royalty Sub Account from which the payout should happen
/// @param receiver is the address to receive the payout
/// @param amount is the amount to be paid out

function royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual nonReentrant returns (bool)
</code></pre></div></div>

<p>The Boolean return value is <code class="language-plaintext highlighter-rouge">true</code> for a successful function execution, and <code class="language-plaintext highlighter-rouge">false</code> for an unsuccessful function execution.</p>

<p>Note, that the function has <code class="language-plaintext highlighter-rouge">reentrancy</code> protection through <code class="language-plaintext highlighter-rouge">nonReentrant</code> from the Open Zeppelin library since funds are being paid out.</p>

<p><a name="r56"><strong>[R56]</strong></a> <em>The input parameters of the <code class="language-plaintext highlighter-rouge">royaltyPayOut</code> function MUST satisfy the following requirements:</em></p>

<ul>
  <li><em><code class="language-plaintext highlighter-rouge">msg.sender == RAsubaccount</code>.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenId</code> must exist and must not be burned.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">tokenId</code> must be associated with a Royalty Account.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">RAsubaccount</code> must be a valid <code class="language-plaintext highlighter-rouge">accountId</code> in a Royalty Sub Account of the Royalty Account of the `tokenId’.</em></li>
  <li><em><code class="language-plaintext highlighter-rouge">isIndividual == true</code> for the Royalty Sub Account, <code class="language-plaintext highlighter-rouge">RAsubaccount</code>.</em></li>
  <li>*<code class="language-plaintext highlighter-rouge">amount &lt;= royaltybalance</code> of the Royalty Sub Account, <code class="language-plaintext highlighter-rouge">RAsubaccount.*</code></li>
</ul>

<p><a name="r57"><strong>[R57]</strong></a> <em>The internal <code class="language-plaintext highlighter-rouge">_royaltyPayOut</code> function interface MUST adhere to the definition below</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function _royaltyPayOut (uint256 tokenId, address RAsubaccount, address payable payoutAccount, uint256 amount) public virtual returns (bool)
</code></pre></div></div>

<p><a name="r58"><strong>[R58]</strong></a> *The internal <code class="language-plaintext highlighter-rouge">_royaltyPayOut</code> function MUST perform the following actions:</p>

<ul>
  <li><em>send the payment to the <code class="language-plaintext highlighter-rouge">payoutaccount</code>.</em></li>
  <li><em>update the <code class="language-plaintext highlighter-rouge">royaltybalance</code> of the <code class="language-plaintext highlighter-rouge">RAsubaccount</code> of the Royalty Account upon successful transfer.</em></li>
</ul>

<p><a name="r59"><strong>[R59]</strong></a> <em>The following steps MUST be taken to send out a royalty payment to its recipient:</em></p>

<ul>
  <li><em>find the Royalty Sub Account.</em></li>
  <li><em>extract <code class="language-plaintext highlighter-rouge">tokenType</code> from the Royalty Sub Account.</em></li>
  <li><em>based on the token type send to the <code class="language-plaintext highlighter-rouge">payoutAccount</code> either</em>
    <ul>
      <li><em>‘ETH’ / relevant protocol token or</em></li>
      <li><em>another token based on token type</em></li>
    </ul>
  </li>
  <li><em>and only if the payout transaction is successful, deduct <code class="language-plaintext highlighter-rouge">amount</code> from <code class="language-plaintext highlighter-rouge">royaltybalance</code> of the Royalty Sub Account,<code class="language-plaintext highlighter-rouge">RAsubaccount</code>, and then return <code class="language-plaintext highlighter-rouge">true</code> as the function return parameter, otherwise return <code class="language-plaintext highlighter-rouge">false</code>.</em></li>
</ul>

<h2 id="rationale">Rationale</h2>

<p>Royalties for NFTs is at its core a distribution licensing problem. A buyer obtains the right to an asset/content which might or might not be reproducible, alterable etc. by the buyer or agents of the buyer. Therefore, a comprehensive specification must address a hierarchy of royalties, where one or more assets are derived from an original asset as described in the Motivation section in detail. Consequently, a design must solve for a multi-level inheritance, and thus, recursion problem.</p>

<p>In order to solve for the complicated inheritance problem, this proposal design breaks down the recursive problem of the hierarchy first into a tree of depth N. And the further breaks down the tree structure into N separate problems, one for each layer. This design allows one to traverse the tree from its lowest level upwards to its root most efficiently. This is achieved with the design for the <code class="language-plaintext highlighter-rouge">distributePayment</code> function and the NFT data structures allowing for the tree structure e.g. <code class="language-plaintext highlighter-rouge">ancestry</code>,<code class="language-plaintext highlighter-rouge">royaltyAccount</code>, <code class="language-plaintext highlighter-rouge">RAsubaccount</code>.</p>

<p>In order to avoid massive gas costs during the payout of royalties, possibly exceeding block gas limits for large royalty trees, the design needed to create a royalty accounting system to maintain royalty balances for recipients as done with the <code class="language-plaintext highlighter-rouge">royaltyAccount</code>, ‘RAsubaccount’ data structures and the associated CRUD operations, as well as require that royalty payouts are done by individual and by request, only, as is achieved with the <code class="language-plaintext highlighter-rouge">royaltyPayout</code> function design.</p>

<p>Furthermore, the design had to ensure that in order to account for and payout royalties the smart contract must be in the “know” of all buying and selling of an NFT including the exchange of monies. This buying and selling can be either direct through the NFT contract or can be exchange-mediated as is most often the case today – which is a centralizing factor! The chosen design for purchasing is accounting for those two modes.</p>

<p>Keeping the NFT contract in the “know” at the beginning of the purchase process requires that authorized user addresses can list NFTs for sale for direct sales , whereas for exchange-mediated purchases, a payment must be registered with the NFT contract before the purchase can be completed.</p>

<p>The design needed to avoid royalty circumvention during the purchase process, therefore, the NFT must be kept in the “know”, a buyer will always have to pay the NFT contract directly and not the seller for both purchasing modes. The seller is subsequently paid through the royalty distribution function in the NFT contract. As a consequence, and a key design choice, and to stay compliant with ERC-721, the NFT contract must be the owner of the NFT, and the actual owner is an <code class="language-plaintext highlighter-rouge">approved</code> address.</p>

<p>The specification design also needed to account for that the payment process depends on whether the payment is received in ETH or an ERC-20 token:</p>

<ul>
  <li>ERC-20 Token
    <ol>
      <li>The Buyer must <code class="language-plaintext highlighter-rouge">approve</code> the NFT contract for the purchase price, <code class="language-plaintext highlighter-rouge">payment</code> for the selected payment token (ERC-20 contract address).</li>
      <li>For an ERC-20 payment token, the Buyer must then call the <code class="language-plaintext highlighter-rouge">executePayment</code> in the NFT contract – the ERC-20 is not directly involved.</li>
    </ol>
  </li>
  <li>For a non-ERC-20 payment, the Buyer must send a protocol token (ETH) to the NFT contract, and is required to send encoded listing and payment information.</li>
</ul>

<p>In addition, the <code class="language-plaintext highlighter-rouge">executePayment</code> function had to be designed to handle both direct sales (through the NFT contract) and exchange-mediated sales which required the introduction of an indicator whether the purchase is direct or exchange-mediated.</p>

<p>The <code class="language-plaintext highlighter-rouge">executePayment</code> function also has to  handle the NFT transfer and purchase clean up – removal  of a listing, or removal of a registered payment, distribution of royalties, payment to the seller, and finally transfer to the seller.</p>

<p>To stay compliant with the ERC-721 design but avoid royalty circumvention, all transfer functions must be disabled save the one that allows for additional information to be submitted with the function in order to manage the complicated purchase cleanup process – <code class="language-plaintext highlighter-rouge">safeTransferFrom</code>. To ensure safety, the design enforces that input parameters must satisfy several requirements for the NFT to be transferred AFTER the royalties have been properly distributed, not before. The design accounts for the fact that we need to treat transfer somewhat differently for direct sales versus exchange mediated sales.</p>

<p>Finally the specification needed to take into account that NFTs must be able to be <code class="language-plaintext highlighter-rouge">minted</code> and <code class="language-plaintext highlighter-rouge">burned</code> to maintain compliance with the ERC-721 specification while also having to set up all the data structures for the tree.</p>

<p>The design enforces that when an NFT is minted, a royalty account for that NFT must be created and associated with the NFT and the NFT owner, and, if there is an ancestor of the NFT with the ancestor’s royalty account to enforces the tree structure. To this end the specification utilizes the ERC-721 <code class="language-plaintext highlighter-rouge">_safemint</code> function in a newly defined <code class="language-plaintext highlighter-rouge">mint</code> function and applies various business rules on the input variables required to ensure proper set-up.</p>

<p>An NFT with a royalty account can be burned. However, several things have to be true to avoid locking funds not only for the royalty account of the NFT but also its descendants, if they exist. That means that all royalties for the NFT and its descendants, if they exists, must be paid out. Furthermore, if descendants exist, they must have been burned before an ancestor can be burned. If those rules are not enforced the cleanly, the hierarchical royalty structure in part of the tree can break down and lead to lost funds, not paid out royalties etc.</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>This EIP is backwards compatible to the ERC-721 standard introducing new interfaces and functionality but retaining the core interfaces and functionality of the ERC-721 standard.</p>

<h2 id="test-cases">Test Cases</h2>

<p>A full test suite is part of the reference implementation.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>The Treetrunk reference implementation of the standard can be found in the public treetrunkio Github repo under treetrunk-nft-reference-implementation.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>Given that this EIP introduces royalty collection, distribution, and payouts to the ERC-721 standard, the number of attack vectors increases. The most important attack vector categories and their mitigation are discussed below:</p>

<ul>
  <li><strong>Payments and Payouts</strong>:
    <ul>
      <li>Reentrancy attacks are mitigated through a reentrancy protection on all payment functions. See for example the Open Zeppelin reference implementation .</li>
      <li>Payouts from unauthorized accounts. Mitigation: Royalty Sub Accounts require at least that <code class="language-plaintext highlighter-rouge">msg.sender</code> is the Royalty Sub Account owner.</li>
      <li>Payments could get stuck in the NFT contract if the <code class="language-plaintext highlighter-rouge">executePayment</code> function fails. Mitigation: For exchange-mediated sales, a buyer can always reverse a payment with <code class="language-plaintext highlighter-rouge">reversePayment</code> if the <code class="language-plaintext highlighter-rouge">executePayment</code> function fails. For direct sales, <code class="language-plaintext highlighter-rouge">reversePayment</code> will be directly triggered in the <code class="language-plaintext highlighter-rouge">executePayment</code> function.</li>
    </ul>
  </li>
  <li><strong>Circumventing Royalties</strong>:
    <ul>
      <li>Offchain Key exchanges
        <ul>
          <li>Exchanging a private key for money off chain can not be prevented in any scenario.</li>
        </ul>
      </li>
      <li>Smart Contract Wallets as NFT owners
        <ul>
          <li>A Smart Contract Wallet controlled by multiple addresses could own an NFT and the owners could transfer the asset within the wallet with an off chain money exchange. Mitigation: Prohibit that Smart Contracts can own an NFT unless explicitly allowed to accommodate special scenarios such as collections.</li>
        </ul>
      </li>
      <li>Denial of Royalty Disbursement
        <ul>
          <li>An attacker who has purchased one or more NFTs in a given generation of an NFT family can cause out of gas errors or run time errors for the contract, if they add many spurious royalty sub-accounts with very low royalty split percentages, and then mint more prints of those purchased NFTs, and then repeat that step until the set <code class="language-plaintext highlighter-rouge">maxGeneration</code> limit is reached. An NFT trade at the bottom of the hierarchy will then require a lot of code cycles because of the recursive nature of the royalty distribution function. Mitigation: Limit the number of royalty sub-accounts per NFT and impose a royalty split percentage limit.</li>
          <li>Following the same approach as above but now targeting the <code class="language-plaintext highlighter-rouge">addListNFT</code> function, an attacker can force an out of gas error or run time errors in the <code class="language-plaintext highlighter-rouge">executePayment</code> function by listing many NFTs at a low price, and then performing a purchase from another account. Mitigation: Limit the number of NFTs that can be included in one listing.</li>
          <li>The creator of the NFT family could set the number of generations too high such that the royalty distribution function could incur and out of gas or run time error because of the recursive nature of the function. Mitigation: Limiting the <code class="language-plaintext highlighter-rouge">maxNumberGeneration</code> by the creator.</li>
        </ul>
      </li>
      <li>General Considerations: The creator of an NFT family must carefully consider the business model for the NFT family and then set the parameters such as maximum number of generations, royalty sub-accounts, number of prints per print, number of NFTs in a listing, and the maximum and minimum royalty split percentage allowed.</li>
    </ul>
  </li>
  <li><strong>Phishing Attacks</strong>
    <ul>
      <li>NFT phishing attacks often target the <code class="language-plaintext highlighter-rouge">approve</code> and <code class="language-plaintext highlighter-rouge">setApprovalForAll</code> functions by tricking owners of NFTs to sign transactions adding the attacker account as approved for one or all NFTs of the victim. Mitigation: This contract is not vulnerable to these type of phishing attacks because all NFT transfers are sales, and the NFT contract itself is the owner of all NFTs. This means that transfers after a purchase are achieved by setting the new owner in the <code class="language-plaintext highlighter-rouge">_approve</code> function. Calling the public <code class="language-plaintext highlighter-rouge">approve</code> function will cause the function call to error out because <code class="language-plaintext highlighter-rouge">msg.sender</code> of the malicious transaction cannot be the NFT owner.</li>
      <li>NFT phishing attack targeting the <code class="language-plaintext highlighter-rouge">addListNFT</code> function to trick victim to list one or more NFTs at a very low price and the attacker immediately registering a payment, and executing that payment right away. Mitigation: Implement a waiting period for a purchase can be affected giving the victim time to call the <code class="language-plaintext highlighter-rouge">removeListNFT</code> function. In addition, an implementer could require Two-Factor-Authentication either built into the contract or by utilizing an authenticator app such as Google Authenticator built into a wallet software.</li>
    </ul>
  </li>
</ul>

<p>Besides the usage of professional security analysis tools, it is also recommended that each implementation performs a security audit of its implementation.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
