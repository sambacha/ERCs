<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Composable NFTs utilizing Equippable Parts | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Composable NFTs utilizing Equippable Parts | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-6220" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-6220" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Composable NFTs utilizing Equippable Parts</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>The Composable NFTs utilizing equippable parts standard extends <a href="./eip-721.md">ERC-721</a> by allowing the NFTs to selectively add parts to themselves via equipping.</p>

<p>Tokens can be composed by cherry picking the list of parts from a Catalog for each NFT instance, and are able to equip other NFTs into slots, which are also defined within the Catalog. Catalogs contain parts from which NFTs can be composed.</p>

<p>This proposal introduces two types of parts; slot type of parts and fixed type of parts. The slot type of parts allow for other NFT collections to be equipped into them, while fixed parts are full components with their own metadata.</p>

<p>Equipping a part into an NFT doesn’t generate a new token, but rather adds another component to be rendered when retrieving the token.</p>

<h2 id="motivation">Motivation</h2>

<p>With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to equip other tokens and be composed from a set of available parts allows for greater utility, usability and forward compatibility.</p>

<p>In the four years since <a href="./eip-721.md">ERC-721</a> was published, the need for additional functionality has resulted in countless extensions. This EIP improves upon ERC-721 in the following areas:</p>

<ul>
  <li><a href="#composing">Composing</a></li>
  <li><a href="#token-progression">Token progression</a></li>
  <li><a href="#merit-tracking">Merit tracking</a></li>
  <li><a href="#provable-digital-scarcity">Provable Digital Scarcity</a></li>
</ul>

<h3 id="composing">Composing</h3>

<p>NFTs can work together to create a greater construct. Prior to this proposal, multiple NFTs could be composed into a single construct either by checking all of the compatible NFTs associated with a given account and used indiscriminately (which could result in unexpected result if there was more than one NFT intended to be used in the same slot), or by keeping a custom ledger of parts to compose together (either in a smart contract or an off-chain database). This proposal establishes a standardized framework for composable NFTs, where a single NFT can select which parts should be a part of the whole, with the information being on chain. Composing NFTs in such a way allows for virtually unbounded customization of the base NFT. An example of this could be a movie NFT. Some parts, like credits, should be fixed. Other parts, like scenes, should be interchangeable, so that various releases (base version, extended cuts, anniversary editions,…) can be replaced.</p>

<h3 id="token-progression">Token progression</h3>

<p>As the token progresses through various stages of its existence, it can attain or be awarded various parts. This can be explained in terms of gaming. A character could be represented by an NFT utilizing this proposal and would be able to equip gear acquired through the gameplay activities and as it progresses further in the game, better items would be available. In stead of having numerous NFTs representing the items collected through its progression, equippable parts can be unlocked and the NFT owner would be able to decide which items to equip and which to keep in the inventory (not equipped) without need of a centralized party.</p>

<h3 id="merit-tracking">Merit tracking</h3>

<p>An equippable NFT can also be used to track merit. An example of this is academic merit. The equippable NFT in this case would represent a sort of digital portfolio of academic achievements, where the owner would be able to equip their diplomas, published articles and awards for all to see.</p>

<h3 id="provable-digital-scarcity">Provable Digital Scarcity</h3>

<p>The majority of current NFT projects are only mock-scarce. Even with a limited supply of tokens, the utility of these (if any) is uncapped. As an example, you can log into 500 different instances of the same game using the same wallet and the same NFT. You can then equip the same hat onto 500 different in-game avatars at the same time, because its visual representation is just a client-side mechanic.</p>

<p>This proposal adds the ability to enforce that, if a hat is equipped on one avatar (by being sent into it and then equipped), it cannot be equipped on another. This provides real digital scarcity.</p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<h3 id="equippable-tokens">Equippable tokens</h3>

<p>The interface of the core smart contract of the equippable tokens.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @title EIP-6220 Composable NFTs utilizing Equippable Parts
/// @dev See https://eips.ethereum.org/EIPS/eip-6220
/// @dev Note: the ERC-165 identifier for this interface is 0x28bc9ae4.
</span>
<span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="k">import</span> <span class="s">"./IERC5773.sol"</span><span class="p">;</span>

<span class="k">interface</span> <span class="n">IERC6220</span> <span class="k">is</span> <span class="n">IERC5773</span> <span class="cm">/*, ERC165 */</span> <span class="p">{</span>
    <span class="cm">/**
     * @notice Used to store the core structure of the `Equippable` component.
     * @return assetId The ID of the asset equipping a child
     * @return childAssetId The ID of the asset used as equipment
     * @return childId The ID of token that is equipped
     * @return childEquippableAddress Address of the collection to which the child asset belongs to
     */</span>
    <span class="k">struct</span> <span class="n">Equipment</span> <span class="p">{</span>
        <span class="kt">uint64</span> <span class="n">assetId</span><span class="p">;</span>
        <span class="kt">uint64</span> <span class="n">childAssetId</span><span class="p">;</span>
        <span class="kt">uint256</span> <span class="n">childId</span><span class="p">;</span>
        <span class="kt">address</span> <span class="n">childEquippableAddress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice Used to provide a struct for inputing equip data.
     * @dev Only used for input and not storage of data.
     * @return tokenId ID of the token we are managing
     * @return childIndex Index of a child in the list of token's active children
     * @return assetId ID of the asset that we are equipping into
     * @return slotPartId ID of the slot part that we are using to equip
     * @return childAssetId ID of the asset that we are equipping
     */</span>
    <span class="k">struct</span> <span class="n">IntakeEquip</span> <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">;</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">;</span>
        <span class="kt">uint64</span> <span class="n">assetId</span><span class="p">;</span>
        <span class="kt">uint64</span> <span class="n">slotPartId</span><span class="p">;</span>
        <span class="kt">uint64</span> <span class="n">childAssetId</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice Used to notify listeners that a child's asset has been equipped into one of its parent assets.
     * @param tokenId ID of the token that had an asset equipped
     * @param assetId ID of the asset associated with the token we are equipping into
     * @param slotPartId ID of the slot we are using to equip
     * @param childId ID of the child token we are equipping into the slot
     * @param childAddress Address of the child token's collection
     * @param childAssetId ID of the asset associated with the token we are equipping
     */</span>
    <span class="k">event</span> <span class="n">ChildAssetEquipped</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">assetId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">slotPartId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">childAssetId</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners that a child's asset has been unequipped from one of its parent assets.
     * @param tokenId ID of the token that had an asset unequipped
     * @param assetId ID of the asset associated with the token we are unequipping out of
     * @param slotPartId ID of the slot we are unequipping from
     * @param childId ID of the token being unequipped
     * @param childAddress Address of the collection that a token that is being unequipped belongs to
     * @param childAssetId ID of the asset associated with the token we are unequipping
     */</span>
    <span class="k">event</span> <span class="n">ChildAssetUnequipped</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">assetId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">slotPartId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">childAssetId</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as
     *  equippable into a given slot and parent
     * @param equippableGroupId ID of the equippable group being marked as equippable into the slot associated with
     *  `slotPartId` of the `parentAddress` collection
     * @param slotPartId ID of the slot part of the catalog into which the parts belonging to the equippable group
     *  associated with `equippableGroupId` can be equipped
     * @param parentAddress Address of the collection into which the parts belonging to `equippableGroupId` can be
     *  equipped
     */</span>
    <span class="k">event</span> <span class="n">ValidParentEquippableGroupIdSet</span><span class="p">(</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">equippableGroupId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">slotPartId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">parentAddress</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to equip a child into a token.
     * @dev The `IntakeEquip` stuct contains the following data:
     *  [
     *      tokenId,
     *      childIndex,
     *      assetId,
     *      slotPartId,
     *      childAssetId
     *  ]
     * @param data An `IntakeEquip` struct specifying the equip data
     */</span>
    <span class="k">function</span> <span class="n">equip</span><span class="p">(</span>
        <span class="n">IntakeEquip</span> <span class="k">memory</span> <span class="n">data</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to unequip child from parent token.
     * @dev This can only be called by the owner of the token or by an account that has been granted permission to
     *  manage the given token by the current owner.
     * @param tokenId ID of the parent from which the child is being unequipped
     * @param assetId ID of the parent's asset that contains the `Slot` into which the child is equipped
     * @param slotPartId ID of the `Slot` from which to unequip the child
     */</span>
    <span class="k">function</span> <span class="n">unequip</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">assetId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">slotPartId</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to check whether the token has a given child equipped.
     * @dev This is used to prevent from transferring a child that is equipped.
     * @param tokenId ID of the parent token for which we are querying for
     * @param childAddress Address of the child token's smart contract
     * @param childId ID of the child token
     * @return bool The boolean value indicating whether the child token is equipped into the given token or not
     */</span>
    <span class="k">function</span> <span class="n">isChildEquipped</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span>
    <span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to verify whether a token can be equipped into a given parent's slot.
     * @param parent Address of the parent token's smart contract
     * @param tokenId ID of the token we want to equip
     * @param assetId ID of the asset associated with the token we want to equip
     * @param slotId ID of the slot that we want to equip the token into
     * @return bool The boolean indicating whether the token with the given asset can be equipped into the desired
     *  slot
     */</span>
    <span class="k">function</span> <span class="n">canTokenBeEquippedWithAssetIntoSlot</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">parent</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">assetId</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">slotId</span>
    <span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to get the Equipment object equipped into the specified slot of the desired token.
     * @dev The `Equipment` struct consists of the following data:
     *  [
     *      assetId,
     *      childAssetId,
     *      childId,
     *      childEquippableAddress
     *  ]
     * @param tokenId ID of the token for which we are retrieving the equipped object
     * @param targetCatalogAddress Address of the `Catalog` associated with the `Slot` part of the token
     * @param slotPartId ID of the `Slot` part that we are checking for equipped objects
     * @return struct The `Equipment` struct containing data about the equipped object
     */</span>
    <span class="k">function</span> <span class="n">getEquipment</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">targetCatalogAddress</span><span class="p">,</span>
        <span class="kt">uint64</span> <span class="n">slotPartId</span>
    <span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Equipment</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to get the asset and equippable data associated with given `assetId`.
     * @param tokenId ID of the token for which to retrieve the asset
     * @param assetId ID of the asset of which we are retrieving
     * @return metadataURI The metadata URI of the asset
     * @return equippableGroupId ID of the equippable group this asset belongs to
     * @return catalogAddress The address of the catalog the part belongs to
     * @return partIds An array of IDs of parts included in the asset
     */</span>
    <span class="k">function</span> <span class="n">getAssetAndEquippableData</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint64</span> <span class="n">assetId</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span>
            <span class="kt">string</span> <span class="k">memory</span> <span class="n">metadataURI</span><span class="p">,</span>
            <span class="kt">uint64</span> <span class="n">equippableGroupId</span><span class="p">,</span>
            <span class="kt">address</span> <span class="n">catalogAddress</span><span class="p">,</span>
            <span class="kt">uint64</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">partIds</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="catalog">Catalog</h3>

<p>The interface of the Catalog containing the equippable parts. Catalogs are collections of equippable fixed and slot parts and are not restricted to a single collection, but can support any number of NFT collections.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @title ICatalog
 * @notice An interface Catalog for equippable module.
 * @dev Note: the ERC-165 identifier for this interface is 0xd912401f.
 */</span>

<span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="k">interface</span> <span class="n">ICatalog</span> <span class="cm">/* is IERC165 */</span> <span class="p">{</span>
    <span class="cm">/**
     * @notice Event to announce addition of a new part.
     * @dev It is emitted when a new part is added.
     * @param partId ID of the part that was added
     * @param itemType Enum value specifying whether the part is `None`, `Slot` and `Fixed`
     * @param zIndex An uint specifying the z value of the part. It is used to specify the depth which the part should
     *  be rendered at
     * @param equippableAddresses An array of addresses that can equip this part
     * @param metadataURI The metadata URI of the part
     */</span>
    <span class="k">event</span> <span class="n">AddedPart</span><span class="p">(</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">partId</span><span class="p">,</span>
        <span class="n">ItemType</span> <span class="k">indexed</span> <span class="n">itemType</span><span class="p">,</span>
        <span class="kt">uint8</span> <span class="n">zIndex</span><span class="p">,</span>
        <span class="kt">address</span><span class="p">[]</span> <span class="n">equippableAddresses</span><span class="p">,</span>
        <span class="kt">string</span> <span class="n">metadataURI</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Event to announce new equippables to the part.
     * @dev It is emitted when new addresses are marked as equippable for `partId`.
     * @param partId ID of the part that had new equippable addresses added
     * @param equippableAddresses An array of the new addresses that can equip this part
     */</span>
    <span class="k">event</span> <span class="n">AddedEquippables</span><span class="p">(</span>
        <span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">partId</span><span class="p">,</span>
        <span class="kt">address</span><span class="p">[]</span> <span class="n">equippableAddresses</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Event to announce the overriding of equippable addresses of the part.
     * @dev It is emitted when the existing list of addresses marked as equippable for `partId` is overwritten by a new
     *  one.
     * @param partId ID of the part whose list of equippable addresses was overwritten
     * @param equippableAddresses The new, full, list of addresses that can equip this part
     */</span>
    <span class="k">event</span> <span class="n">SetEquippables</span><span class="p">(</span><span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">partId</span><span class="p">,</span> <span class="kt">address</span><span class="p">[]</span> <span class="n">equippableAddresses</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Event to announce that a given part can be equipped by any address.
     * @dev It is emitted when a given part is marked as equippable by any.
     * @param partId ID of the part marked as equippable by any address
     */</span>
    <span class="k">event</span> <span class="n">SetEquippableToAll</span><span class="p">(</span><span class="kt">uint64</span> <span class="k">indexed</span> <span class="n">partId</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to define a type of the item. Possible values are `None`, `Slot` or `Fixed`.
     * @dev Used for fixed and slot parts.
     */</span>
    <span class="k">enum</span> <span class="n">ItemType</span> <span class="p">{</span>
        <span class="n">None</span><span class="p">,</span>
        <span class="n">Slot</span><span class="p">,</span>
        <span class="n">Fixed</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice The integral structure of a standard RMRK catalog item defining it.
     * @dev Requires a minimum of 3 storage slots per catalog item, equivalent to roughly 60,000 gas as of Berlin hard fork
     *  (April 14, 2021), though 5-7 storage slots is more realistic, given the standard length of an IPFS URI. This
     *  will result in between 25,000,000 and 35,000,000 gas per 250 assets--the maximum block size of Ethereum
     *  mainnet is 30M at peak usage.
     * @return itemType The item type of the part
     * @return z The z value of the part defining how it should be rendered when presenting the full NFT
     * @return equippable The array of addresses allowed to be equipped in this part
     * @return metadataURI The metadata URI of the part
     */</span>
    <span class="k">struct</span> <span class="n">Part</span> <span class="p">{</span>
        <span class="n">ItemType</span> <span class="n">itemType</span><span class="p">;</span> <span class="c1">//1 byte
</span>        <span class="kt">uint8</span> <span class="n">z</span><span class="p">;</span> <span class="c1">//1 byte
</span>        <span class="kt">address</span><span class="p">[]</span> <span class="n">equippable</span><span class="p">;</span> <span class="c1">//n Collections that can be equipped into this slot
</span>        <span class="kt">string</span> <span class="n">metadataURI</span><span class="p">;</span> <span class="c1">//n bytes 32+
</span>    <span class="p">}</span>

    <span class="cm">/**
     * @notice The structure used to add a new `Part`.
     * @dev The part is added with specified ID, so you have to make sure that you are using an unused `partId`,
     *  otherwise the addition of the part vill be reverted.
     * @dev The full `IntakeStruct` looks like this:
     *  [
     *          partID,
     *      [
     *          itemType,
     *          z,
     *          [
     *               permittedCollectionAddress0,
     *               permittedCollectionAddress1,
     *               permittedCollectionAddress2
     *           ],
     *           metadataURI
     *       ]
     *   ]
     * @return partId ID to be assigned to the `Part`
     * @return part A `Part` to be added
     */</span>
    <span class="k">struct</span> <span class="n">IntakeStruct</span> <span class="p">{</span>
        <span class="kt">uint64</span> <span class="n">partId</span><span class="p">;</span>
        <span class="n">Part</span> <span class="n">part</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice Used to return the metadata URI of the associated catalog.
     * @return string Base metadata URI
     */</span>
    <span class="k">function</span> <span class="n">getMetadataURI</span><span class="p">()</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">string</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to return the `itemType` of the associated catalog
     * @return string `itemType` of the associated catalog
     */</span>
    <span class="k">function</span> <span class="n">getType</span><span class="p">()</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">string</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to check whether the given address is allowed to equip the desired `Part`.
     * @dev Returns true if a collection may equip asset with `partId`.
     * @param partId The ID of the part that we are checking
     * @param targetAddress The address that we are checking for whether the part can be equipped into it or not
     * @return bool The status indicating whether the `targetAddress` can be equipped into `Part` with `partId` or not
     */</span>
    <span class="k">function</span> <span class="n">checkIsEquippable</span><span class="p">(</span><span class="kt">uint64</span> <span class="n">partId</span><span class="p">,</span> <span class="kt">address</span> <span class="n">targetAddress</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to check if the part is equippable by all addresses.
     * @dev Returns true if part is equippable to all.
     * @param partId ID of the part that we are checking
     * @return bool The status indicating whether the part with `partId` can be equipped by any address or not
     */</span>
    <span class="k">function</span> <span class="n">checkIsEquippableToAll</span><span class="p">(</span><span class="kt">uint64</span> <span class="n">partId</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve a `Part` with id `partId`
     * @param partId ID of the part that we are retrieving
     * @return struct The `Part` struct associated with given `partId`
     */</span>
    <span class="k">function</span> <span class="n">getPart</span><span class="p">(</span><span class="kt">uint64</span> <span class="n">partId</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Part</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve multiple parts at the same time.
     * @param partIds An array of part IDs that we want to retrieve
     * @return struct An array of `Part` structs associated with given `partIds`
     */</span>
    <span class="k">function</span> <span class="n">getParts</span><span class="p">(</span><span class="kt">uint64</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">partIds</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="n">Part</span><span class="p">[]</span> <span class="k">memory</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="rationale">Rationale</h2>

<p>Designing the proposal, we considered the following questions:</p>

<ol>
  <li><strong>Why are we using a Catalog in stead of supporting direct NFT equipping?</strong><br />
If NFTs could be directly equipped into other NFTs without any oversight, the resulting composite would be unpredictable. Catalog allows for parts to be pre-verified in order to result in a composite that composes as expected. Another benefit of Catalog is the ability of defining reusable fixed parts.</li>
  <li><strong>Why do we propose two types of parts?</strong><br />
Some parts, that are the same for all of the tokens, don’t make sense to be represented by individual NFTs, so they can be represented by fixed parts. This reduces the clutter of the owner’s wallet as well as introduces an efficient way of disseminating repetitive assets tied to NFTs.<br />
The slot parts allow for equipping NFTs into them. This provides the ability to equip unrelated NFT collections into the base NFT after the unrelated collection has been verified to compose properly.<br />
Having two parts allows for support of numerous use cases and, since the proposal doesn’t enforce the use of both it can be applied in any configuration needed.</li>
  <li><strong>Why is a method to get all of the equipped parts not included?</strong><br />
Getting all parts might not be an operation necessary for all implementers. Additionally, it can be added either as an extension, doable with hooks, or can be emulated using an indexer.</li>
  <li><strong>Should Catalog be limited to support one NFT collection at a time or be able to support any nunmber of collections?</strong><br />
As the Catalog is designed in a way that is agnostic to the use case using it. It makes sense to support as wide reusability as possible. Having one Catalog supporting multiple collections allows for optimized operation and reduced gas prices when deploying it and setting fixed as well as slot parts.</li>
</ol>

<h3 id="fixed-parts">Fixed parts</h3>

<p>Fixed parts are defined and contained in the Catalog. They have their own metadata and are not meant to change through the lifecycle of the NFT.</p>

<p>A fixed part cannot be replaced.</p>

<p>The benefit of fixed parts is that they represent equippable parts that can be equipped by any number of tokens in any number of collections and only need to be defined once.</p>

<h3 id="slot-parts">Slot parts</h3>

<p>Slot parts are defined and contained in the Catalog. They don’t have their own metadata, but rather support equipping of selected NFT collections into them. The tokens equipped into the slots however, contain their own metadata. This allows for an equippable modifialbe content of the base NFT controlled by its owner. As they can be equipped into any number of tokens of any number of collections, they allow for reliable composing of the final tokens by vetting which NFTs can be equipped by a given slot once and then reused any number of times.</p>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>The Equippable token standard has been made compatible with <a href="./eip-721.md">ERC-721</a> in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.</p>

<h2 id="test-cases">Test Cases</h2>

<p>Tests are included in <a href="../assets/eip-6220/test/equippableFixedParts.ts"><code class="language-plaintext highlighter-rouge">equippableFixedParts.ts</code></a> and <a href="../assets/eip-6220/test/equippableSlotParts.ts"><code class="language-plaintext highlighter-rouge">equippableSlotParts.ts</code></a>.</p>

<p>To run them in terminal, you can use the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../assets/eip-6220
npm install
npx hardhat test
</code></pre></div></div>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>See <a href="../assets/eip-6220/contracts/EquippableToken.sol"><code class="language-plaintext highlighter-rouge">EquippableToken.sol</code></a>.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>The same security considerations as with <a href="./eip-721.md">ERC-721</a> apply: hidden logic may be present in any of the functions, including burn, add resource, accept resource, and more.</p>

<p>Caution is advised when dealing with non-audited contracts.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
