<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Minimal Transferable NFT detection interface | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Minimal Transferable NFT detection interface | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-6454" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-6454" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Minimal Transferable NFT detection interface</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>The Minimalistic Transferable interface for Non-Fungible Tokens standard extends <a href="./eip-721.md">ERC-721</a> by introducing the ability to identify whether an NFT can be transferred or not.</p>

<p>This proposal introduces the ability to prevent a token from being transferred from their owner, making them bound to the externally owned account, abstracted account, smart contract or token that owns it.</p>

<h2 id="motivation">Motivation</h2>

<p>With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability to prevent the tokens from being transferred introduces new possibilities of NFT utility and evolution.</p>

<p>This proposal is designed in a way to be as minimal as possible in order to be compatible with any usecases that wish to utilize this proposal.</p>

<p>This EIP introduces new utilities for <a href="./eip-721.md">ERC-721</a> based tokens in the following areas:</p>

<ul>
  <li><a href="#verifiable-attribution">Verifiable attribution</a></li>
  <li><a href="#immutable-properties">Immutable properties</a></li>
</ul>

<h3 id="verifiable-attribution">Verifiable attribution</h3>

<p>Personal achievements can be represented by non-fungible tokens. These tokens can be used to represent a wide range of accomplishments, including scientific advancements, philanthropic endeavors, athletic achievements, and more. However, if these achievement-indicating NFTs can be easily transferred, their authenticity and trustworthiness can be called into question. By binding the NFT to a specific account, it can be ensured that the account owning the NFT is the one that actually achieved the corresponding accomplishment. This creates a secure and verifiable record of personal achievements that can be easily accessed and recognized by others in the network. The ability to verify attribution helps to establish the credibility and value of the achievement-indicating NFT, making it a valuable asset that can be used as a recognition of the holder’s accomplishments.</p>

<h3 id="immutable-properties">Immutable properties</h3>

<p>NFT properties are a critical aspect of non-fungible tokens, serving to differentiate them from one another and establish their scarcity. Centralized control of NFT properties by the issuer, however, can undermine the uniqueness of these properties.</p>

<p>By tying NFTs to specific properties, the original owner is ensured that the NFT will always retain these properties and its uniqueness.</p>

<p>In a blockchain game that employs non-transferable NFTs to represent skills or abilities, each skill would be a unique and permanent asset tied to a specific player or token. This would ensure that players retain ownership of the skills they have earned and prevent them from being traded or sold to other players. This can increase the perceived value of these skills, enhancing the player experience by allowing for greater customization and personalization of characters.</p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @title EIP-6454 Minimalistic Non-Transferable interface for NFTs
/// @dev See https://eips.ethereum.org/EIPS/eip-6454
/// @dev Note: the ERC-165 identifier for this interface is 0x91a6262f.
</span>
<span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="k">interface</span> <span class="n">IERC6454</span> <span class="cm">/* is IERC165 */</span> <span class="p">{</span>
    <span class="cm">/**
     * @notice Used to check whether the given token is transferable or not.
     * @dev If this function returns `false`, the transfer of the token MUST revert execution.
     * @dev If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for
     *  minting.
     * @dev The `from` parameter MAY be used to also validate the approval of the token for transfer, but anyone
     *  interacting with this function SHOULD NOT rely on it as it is not mandated by the proposal.
     * @param tokenId ID of the token being checked
     * @param from Address from which the token is being transferred
     * @param to Address to which the token is being transferred
     * @return Boolean value indicating whether the given token is transferable
     */</span>
    <span class="k">function</span> <span class="n">isTransferable</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In order to determine whether a token is transferable or not in general, the function SHOULD return the appropriate boolean value when passing the <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code> address as the <code class="language-plaintext highlighter-rouge">to</code> and <code class="language-plaintext highlighter-rouge">from</code> parameter.</p>

<p>The general transferability of a token should not be affected by the ability to mint the token (value of <code class="language-plaintext highlighter-rouge">from</code> parameter is <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code>) and the ability to burn the token (value of <code class="language-plaintext highlighter-rouge">to</code> parameter is <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code>).</p>

<p>If the general transferability of token is <code class="language-plaintext highlighter-rouge">false</code>, any kind of transfer of the token, save minting and burning, MUST revert execution.</p>

<p>In order to determine whether a token is mintable, the exception SHOULD be made to allow the <code class="language-plaintext highlighter-rouge">tokenId</code> parameter for a token that does not exist. Additionally the <code class="language-plaintext highlighter-rouge">from</code> parameter SHOULD be <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code> and the <code class="language-plaintext highlighter-rouge">to</code> parameter SHOULD NOT be <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code>.</p>

<p>In order to determine whether a token is burnable, the <code class="language-plaintext highlighter-rouge">from</code> parameter SHOULD NOT be <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code> and the <code class="language-plaintext highlighter-rouge">to</code> parameter SHOULD be <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code>.</p>

<p>Implementers MAY choose to validate the approval of the token for transfer by the <code class="language-plaintext highlighter-rouge">from</code> parameter, but anyone interacting with this function SHOULD NOT rely on it as it is not mandated by the proposal. This means that the <code class="language-plaintext highlighter-rouge">from</code> parameter in such implementations validates the initiator of the transaction rather than the owner from which the token is being transferred (which can either be the owner of the token or the operator allowed to transfer the token).</p>

<h2 id="rationale">Rationale</h2>

<p>Designing the proposal, we considered the following questions:</p>

<ol>
  <li><strong>Should we propose another (Non-)Transferable NFT proposal given the existence of existing ones, some even final, and how does this proposal compare to them?</strong><br />
This proposal aims to provide the minimum necessary specification for the implementation of non-transferable NFTs, we feel none of the existing proposals have presented the minimal required interface. Unlike other proposals that address the same issue, this proposal requires fewer methods in its specification, providing a more streamlined solution.</li>
  <li><strong>Why is there no event marking the token as Non-Transferable in this interface?</strong><br />
The token can become non-transferable either at its creation, after being marked as non-transferable, or after a certain condition is met. This means that some cases of tokens becoming non-transferable cannot emit an event, such as if the token becoming non-transferable is determined by a block number. Requiring an event to be emitted upon the token becoming non-transferable is not feasible in such cases.</li>
  <li><strong>Should the transferability state management function be included in this proposal?</strong><br />
A function that marks a token as non-transferable or releases the binding is referred to as the transferability management function. To maintain the objective of designing an agnostic minimal transferable proposal, we have decided not to specify the transferability management function. This allows for a variety of custom implementations that require the tokens to be non-transferable.</li>
  <li><strong>Why should this be an EIP if it only contains one method?</strong><br />
One could argue that since the core of this proposal is to only prevent ERC-721 tokens to be transferred, this could be done by overriding the transfer function. While this is true, the only way to assure that the token is non-transferable before the smart contract execution, is for it to have the transferable interface.<br />
This also allows for smart contract to validate whether the token is not transferable and not attempt transferring it as this would result in failed transactions and wasted gas.</li>
  <li><strong>Should we include the most straightforward method possible that only accepts a <code class="language-plaintext highlighter-rouge">tokenId</code> parameter?</strong><br />
The initial version of the proposal contained a method that only accepted a <code class="language-plaintext highlighter-rouge">tokenId</code> parameter. This method would return a boolean value indicating whether the token is transferable. However, the fact that the token can be non-transferable for different reasons was brought up throughout the discussion. This is why the method was changed to accept additional parameters, allowing for a more flexible implementation. Additionally, we kept the original method’s functionality by specifying the methodology on how to achieve the same result (by passing the <code class="language-plaintext highlighter-rouge">0x0000000000000000000000000000000000000000</code> address as the <code class="language-plaintext highlighter-rouge">to</code> and <code class="language-plaintext highlighter-rouge">from</code> parameters).</li>
  <li><strong>What is the best user experience for frontend?</strong><br />
The best user experience for the front end is having a single method that checks whether the token is transferable. This method should handle both cases of transferability, general and conditional.<br />
The front end should also be able to handle the case where the token is not transferable and the transfer is attempted. This can be done by checking the return value of the transfer function, which will be false if the token is not transferable. If the token would just be set as non-transferable, without a standardized interface to check whether the token is transferable, the only way to validate transferability would be to attempt a gas calculation and check whether the transaction would revert. This is a bad user experience and should be avoided.</li>
  <li><strong>Should we mandate that the <code class="language-plaintext highlighter-rouge">isTransferable</code> validates approvals as well?</strong><br />
We considered specifying that the <code class="language-plaintext highlighter-rouge">from</code> parameter represents the initiator of the token transfer. This would mean that the <code class="language-plaintext highlighter-rouge">from</code> would validate whether the address is the owner of the token or approved to transfer it. While this might be beneficial, we ultimately decided to make it optional.<br />
As this proposal aims to be the minimal possible implementation and the approvals are already standardized, we feel that <code class="language-plaintext highlighter-rouge">isTransferable</code> can be used in conjunction with the approvals to validate whether the given address can initiate the transfer or not.<br />
Additionally, mandating the validation of approvals would incur higher gas consumption as additional checks would be required to validate the transferability.</li>
</ol>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>The Minimalistic Non-Transferable token standard is fully compatible with <a href="./eip-721.md">ERC-721</a> and with the robust tooling available for implementations of ERC-721 as well as with the existing ERC-721 infrastructure.</p>

<h2 id="test-cases">Test Cases</h2>

<p>Tests are included in <a href="../assets/eip-6454/test/transferable.ts"><code class="language-plaintext highlighter-rouge">transferable.ts</code></a>.</p>

<p>To run them in terminal, you can use the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../assets/eip-6454
npm install
npx hardhat test
</code></pre></div></div>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>See <a href="../assets/eip-6454/contracts/mocks/ERC721TransferableMock.sol"><code class="language-plaintext highlighter-rouge">ERC721TransferableMock.sol</code></a>.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>The same security considerations as with <a href="./eip-721.md">ERC-721</a> apply: hidden logic may be present in any of the functions, including burn, add asset, accept asset, and more.</p>

<p>A smart contract can implement the proposal interface but returns fraudulent values, i.e., returning <code class="language-plaintext highlighter-rouge">false</code> for <code class="language-plaintext highlighter-rouge">isTransferable</code> when the token is transferable. Such a contract would trick other contracts into thinking that the token is non-transferable when it is transferable. If such a contract exists, we suggest not interacting with it. Much like fraudulent <a href="./eip-20.md">ERC-20</a> or <a href="./eip-721.md">ERC-721</a> smart contracts, it is not possible to prevent such contracts from existing. We suggest that you verify all of the external smart contracts you interact with and not interact with contracts you do not trust.</p>

<p>Since the transferability state can change over time, verifying that the state of the token is transferable before interacting with it is essential. Therefore, a dApp, marketplace, or wallet implementing this interface should verify the state of the token every time the token is displayed.</p>

<p>Caution is advised when dealing with non-audited contracts.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
