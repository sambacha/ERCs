<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Purpose bound money | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Purpose bound money | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-7291" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-7291" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Purpose bound money</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>This proposal outlines a smart contract interface that builds upon the <a href="./eip-1155.md">ERC-1155</a> standard to implement the purpose bound money (PBM) concept:</p>

<ul>
  <li>PBMs is comprised of a PBM wrapper and a digital money token that it wraps. A digital money token (e.g. stablecoins, central bank digital currency, tokenised bank deposits etc) serves as as a store of value (abbreviated as “sov”). Thus, a digital money token (also referred to as “sovToken”) <strong>SHOULD</strong> be:
    <ul>
      <li>a good store of value;</li>
      <li>a suitable unit of account; and</li>
      <li>a medium of exchange.</li>
    </ul>
  </li>
  <li>PBMs are bearer instruments, with self-contained programming logic, and can be transferred between two parties without involving intermediaries. It combines the concept of:
    <ul>
      <li>programmable payment - automatic execution of payments once a pre-defined set of conditions are met; and</li>
      <li>programmable money - the possibility of embedding rules within the medium of exchange itself that defines or constraints its usage.</li>
    </ul>
  </li>
  <li>Once the conditions are met, sovToken is released, and it becomes unbounded once again. A PBM can be taught of as a digital cash voucher, because it places constraint on how a payer can use the PBM but does not imposes any constraints on the merchant/redeemer because the PBM unwraps and releases the underlying digital money upon payment to the merchant/redeemer. This is akin to a physical cash voucher, where the payer is restricted to purchases from the merchants specified by the issuer but the merchants accepting the vouchers can exchange the physical vouchers with the issuer for fiat money.</li>
</ul>

<p>In this EIP, we propose a modular structure consisting of an <a href="./eip-20.md">ERC-20</a> compatible sovToken as the digital money, an ERC-1155 compatible smart contract as the PBM wrapper, an address list smart contract as the PBM logic and a PBM token manager smart contract to manage token registration and retrieval.</p>

<h2 id="motivation">Motivation</h2>

<p>This proposal intends to forestall technology fragmentation and consequently a lack of interoperability. By making the PBM specification open, it gives new participants easy and free access to the pre-existing market standards, enabling interoperability across different platforms, wallets, payment systems and rails. This would lower cost of entry for new participants, foster a vibrant payment landscape and prevent the development of walled gardens and monopolies, ultimately leading to more efficient, affordable services and better user experiences.</p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174.</p>

<h3 id="definitions">Definitions</h3>

<ul>
  <li>
    <p><strong>sovToken</strong> - an ERC-20 or ERC-20 compatible digital currency (e.g. <a href="./eip-777.md">ERC-777</a>, <a href="./eip-1363.md">ERC-1363</a>) serving as the store of value token (i.e. collateral backing the PBM Token).</p>
  </li>
  <li>
    <p><strong>PBM Wrapper</strong> - an ERC-1155 compliant smart contract, which wraps the sovToken by specifying one or more conditions that have to be met (referred to as PBM business logic in subsequent section of this proposal). The PBM wrapper can be designed to be modular in nature, with core, plug-ins and hooks components (see section on PBM Architecture for elaboration). The PBM wrapper smart contract, together with adopted hooks smart contracts verifies that condition(s) has/have been met before unwrapping the underlying sovToken.</p>
  </li>
  <li>
    <p><strong>PBM Token</strong> - the sovToken and its PBM wrapper are collectively referred to as a PBM Token. PBM Tokens are represented as a ERC-1155 token.</p>
  </li>
  <li>
    <p><strong>PBM Creator</strong> defines the conditions of the PBM Wrapper to create PBM Tokens.</p>
  </li>
  <li>
    <p><strong>PBM Wallet</strong> - cryptographic wallets which can either be an EOA (Externally Owned Account) that is controlled by a private key, or a smart contract wallet.</p>
  </li>
  <li>
    <p><strong>Merchant / Redeemer</strong> - In the context of this proposal, a Merchant or a Redeemer is broadly defined as the ultimate recipient, or endpoint, for PBM tokens, to which these tokens are intrinsically directed or purpose-bound to. The identity of merchant/redeemer will be specify in the PBM Address List (which can be part of the PBM Wrapper smart contract or a standalone PBM Address List smart contract that is registered as a PBM hook).</p>
  </li>
</ul>

<h3 id="overview">Overview</h3>

<ul>
  <li>
    <p>PBM <strong>SHALL</strong> adhere to the definition of “wrap” or “wrapping” to mean bounding a token in accordance with PBM business logic during its lifecycle stage.</p>
  </li>
  <li>
    <p>PBM <strong>SHALL</strong> adhere to the definition of “unwrap” or “unwrapping” to mean the release of a token in accordance with the PBM business logic during its lifecycle stage.</p>
  </li>
  <li>
    <p>A valid PBM Token <strong>MUST</strong> consists of an underlying sovToken and the PBM Wrapper.</p>

    <ul>
      <li>
        <p>The sovToken can be wrapped either upon the creation of the PBM Token or at a later date.</p>
      </li>
      <li>
        <p>A sovToken can be implemented as any widely accepted ERC-20 compatible token, such as ERC-20, ERC-777, or ERC-1363.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>PBM Wrapper <strong>MUST</strong> provide a mechanism for all transacting parties to verify that all necessary condition(s) have been met before allowing the PBM Token to be unwrapped. Refer to Auditability section for elaborations. The necessary conditions can be implemented within the PBM wrapper, or in a separate PBM hook(s) smart contract(s).</p>
  </li>
  <li>
    <p>PBM Wrapper <strong>MUST</strong> ensure the destination address for unwrapped sovToken is in a whitelist of Merchant/Redeemer addresses and not in a blacklist of banned addresses prior to unwrapping the underlying sovToken.</p>
  </li>
  <li>
    <p>The PBM Token <strong>MUST</strong> be burnt upon being fully unwrapped and used.</p>
  </li>
  <li>
    <p>A PBM Token <strong>SHOULD</strong> have an expiry time that is decided by the PBM Creator.</p>

    <ul>
      <li>For cases where an expiry time is not needed, the expiry time <strong>SHOULD</strong> be set to infinity.</li>
    </ul>
  </li>
  <li>
    <p>This proposal defines a base specification of what a PBM should entail. Extensions to this base specification can be implemented as separate specifications.</p>
  </li>
</ul>

<h3 id="pbm-architecture">PBM Architecture</h3>

<p>In this EIP, we propose a modular PBM architecture that has three distinct components (the core, the plugins and the hooks):</p>

<ul>
  <li>The <strong>core components</strong> contains basic functionalities and validation checks that all PBMs should have. Core components includes sovToken and PBM wrapper containing the core logic (e.g. logic to whitelist the merchant/redeemer address, logic to unwrap upon transfer to a whitelisted address, logic for minting and burning the PBM) and a token manager which allows for token registration, retrieval. In addition, the PBM wrapper <strong>MAY</strong> include logic to interface with plugins and hooks.</li>
  <li>The <strong>plugin components</strong> implement additional functionality that only specific PBMs may require (e.g. logic to call external application programming interfaces to verify specific PBM condition was met, logic to track PBM usage patterns).</li>
  <li>The <strong>hook components</strong> implement additional validation checks that some PBMs may need (e.g. checks for expiration, daily spending limit, goods &amp; services limit etc).</li>
</ul>

<p>For example, a PBM creator may want to ensure only 50% of PBM Series A can be spent in supermarkets, while there are no restriction on proportion of PBM Series B that can be spent in supermarkets. He can implement a plugin smart contract to keep track of supermarket spendings by PBM users. He will also implement a hook to validate that less than 50% of the PBM Series A issued a user is spent in a supermarket. This allows him to use the same generic PBM wrapper and sovToken for both PBM Series A and B. In addition, PBM series A will register the plugin module and hook module for additional data tracking and validations.</p>

<h3 id="auditability">Auditability</h3>

<p>PBM Wrapper <strong>SHOULD</strong> provide the public easily accessible mechanism(s) to verify the smart contract logic for unwrapping a PBM. Such mechanisms could be leveraged by automated validation or asynchronous user verifications from transacting parties and/or whitelisted third parties attestations.</p>

<p>As the fulfilment of PBM conditions is likely to be subjected to audits to ensure trust amongst all transacting parties, the following evidence shall be documented to support audits:</p>

<ul>
  <li>The interface/events emitted <strong>SHOULD</strong> allow a fine-grained recreation of the transaction history, token types and token balances</li>
  <li>The source code <strong>SHOULD</strong> be verified and formally published on a blockchain explorer.</li>
</ul>

<h3 id="fungibility">Fungibility</h3>

<p>A PBM Wrapper <strong>SHOULD</strong> be able to wrap multiple types of compatible sovTokens (e.g. the same PBM Wrapper should be able to wrap USDC and XSGD). sovTokens wrapped by the same PBM wrapper may or may not be fungible to one another. The standard does NOT mandate how an implementation must do this.</p>

<h3 id="pbm-token-details">PBM token details</h3>

<p>The ERC-1155 Multi Token Standard enables each token ID to correspond to a unique, configurable token type. All essential details facilitating the business or display logic for a PBM <strong>MUST</strong> be defined for each token type. The mandatory fields for this purpose are outlined in the <code class="language-plaintext highlighter-rouge">struct PBMToken</code> (below). Future proposals may define additional, optional state variables as needed. Once a token detail has been defined, it <strong>MUST</strong> be immutable.</p>

<p>Example of token details:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="k">abstract</span> <span class="k">contract</span> <span class="n">IPBMRC1_TokenManager</span> <span class="p">{</span>
    <span class="c1">/// @dev Mapping of each ERC-1155 tokenId to its corresponding PBM Token details.
</span>    <span class="k">mapping</span> <span class="p">(</span><span class="kt">uint256</span> <span class="o">=&gt;</span> <span class="n">PBMToken</span><span class="p">)</span> <span class="k">internal</span> <span class="n">tokenTypes</span> <span class="p">;</span>

    <span class="c1">/// @notice A PBM token MUST include compulsory state variables (name, faceValue, expiry, and uri) to adhere to this standard.
</span>    <span class="c1">/// @dev Represents all the details corresponding to a PBM tokenId.
</span>    <span class="k">struct</span> <span class="n">PBMToken</span> <span class="p">{</span>
        <span class="c1">// Name of the token.
</span>        <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>

        <span class="c1">// Value of the underlying wrapped ERC20-compatible sovToken. Additional information on the `faceValue` can be specified by
</span>        <span class="c1">// adding the optional variables: `currencySymbol` or `tokenSymbol` as indicated below
</span>        <span class="kt">uint256</span> <span class="n">faceValue</span><span class="p">;</span>

        <span class="c1">// Time after which the token will be rendered useless (expressed in Unix Epoch time).
</span>        <span class="kt">uint256</span> <span class="n">expiry</span><span class="p">;</span>

        <span class="c1">// Metadata URI for ERC-1155 display purposes.
</span>        <span class="kt">string</span> <span class="n">uri</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: Indicates if the PBM token can be transferred to a non merchant/redeemer wallet.
</span>        <span class="kt">bool</span> <span class="n">isTransferable</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: Determines whether the PBM will be burned or revoked upon expiry, under certain predefined conditions, or at the owner's discretion.
</span>        <span class="kt">bool</span> <span class="n">burnable</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: Number of decimal places for the token.
</span>        <span class="kt">uint8</span> <span class="n">decimals</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: The address of the creator of this PBM type on this smart contract. This field is optional because the creator is msg.sender by default.
</span>        <span class="kt">address</span> <span class="n">creator</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: The smart contract address of the sovToken.
</span>        <span class="kt">address</span> <span class="n">tokenAddress</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: The running balance of the PBM Token type that has been minted.
</span>        <span class="kt">uint256</span> <span class="n">totalSupply</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: An ISO4217 three-character alphabetic code may be needed for the faceValue in multicurrency PBM use cases.
</span>        <span class="kt">string</span> <span class="n">currencySymbol</span><span class="p">;</span>

        <span class="c1">// OPTIONAL: An abbreviation for the PBM token name may be assigned.
</span>        <span class="kt">string</span> <span class="n">tokenSymbol</span><span class="p">;</span>

        <span class="c1">// Add other optional state variables below...
</span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An implementer has the option to define all token types upon PBM contract deployment. If needed, they can also expose an external function to create new PBM tokens at a later time.
All token types created <strong>SHOULD</strong> emit a <code class="language-plaintext highlighter-rouge">NewPBMTypeCreated</code> event.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// @notice Creates a new PBM Token type with the provided data.
</span>    <span class="c1">/// @dev The caller of createPBMTokenType shall be responsible for setting the creator address.
</span>    <span class="c1">/// Example of uri can be found in [`sample-uri`](../assets/eip-7291/sample-uri/stx-10-static)
</span>    <span class="c1">/// Must emit {NewPBMTypeCreated}
</span>    <span class="c1">/// @param _name Name of the token.
</span>    <span class="c1">/// @param _faceValue Value of the underlying wrapped ERC20-compatible sovToken.
</span>    <span class="c1">/// @param _tokenExpiry Time after which the token will be rendered useless (expressed in Unix Epoch time).
</span>    <span class="c1">/// @param _tokenURI Metadata URI for ERC-1155 display purposes
</span>    <span class="k">function</span> <span class="n">createPBMTokenType</span><span class="p">(</span>
        <span class="kt">string</span> <span class="k">memory</span> <span class="n">_name</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">_faceValue</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">_tokenExpiry</span><span class="p">,</span>
        <span class="kt">string</span> <span class="k">memory</span> <span class="n">_tokenURI</span>
    <span class="p">)</span> <span class="k">external</span> <span class="k">virtual</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId_</span><span class="p">);</span>

    <span class="c1">/// @notice Emitted when a new Purpose-Bound Token (PBM) type is created within the contract.
</span>    <span class="c1">/// @param tokenId The unique identifier for the newly created PBM token type.
</span>    <span class="c1">/// @param tokenName A human-readable string representing the name of the newly created PBM token type.
</span>    <span class="c1">/// @param amount The initial supply of the newly created PBM token type.
</span>    <span class="c1">/// @param expiry The timestamp at which the newly created PBM token type will expire.
</span>    <span class="c1">/// @param creator The address of the account that created the new PBM token type.
</span>    <span class="k">event</span> <span class="n">NewPBMTypeCreated</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">tokenName</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">expiry</span><span class="p">,</span> <span class="kt">address</span> <span class="n">creator</span><span class="p">);</span>

</code></pre></div></div>

<p>Implementors of the standard <strong>MUST</strong> define a method to retrieve a PBM token detail</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// @notice Retrieves the details of a PBM Token type given its tokenId.
</span>    <span class="c1">/// @dev This function fetches the PBMToken struct associated with the tokenId and returns it.
</span>    <span class="c1">/// @param tokenId The identifier of the PBM token type.
</span>    <span class="c1">/// @return pbmToken_ A PBMToken struct containing all the details of the specified PBM token type.
</span>    <span class="k">function</span> <span class="n">getTokenDetails</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">)</span> <span class="k">external</span> <span class="k">virtual</span> <span class="k">view</span> <span class="k">returns</span><span class="p">(</span><span class="n">PBMToken</span> <span class="k">memory</span> <span class="n">pbmToken_</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="pbm-address-list">PBM Address List</h3>

<p>A targeted address list for PBM unwrapping must be specified. This list can be supplied either
through the initialization function as part of a composite contract that contains various business logic elements,
or it can be coded directly as a state variable within a PBM smart contract.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">/// @title PBM Address list Interface.
/// @notice The PBM address list stores and manages whitelisted merchants/redeemers and blacklisted address for the PBMs
</span><span class="k">interface</span> <span class="n">IPBMAddressList</span> <span class="p">{</span>

    <span class="c1">/// @notice Checks if the address is one of the blacklisted addresses
</span>    <span class="c1">/// @param _address The address to query
</span>    <span class="c1">/// @return bool_ True if address is blacklisted, else false
</span>    <span class="k">function</span> <span class="n">isBlacklisted</span><span class="p">(</span><span class="kt">address</span> <span class="n">_address</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">bool_</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">/// @notice Checks if the address is one of the whitelisted merchant/redeemer addresses
</span>    <span class="c1">/// @param _address The address to query
</span>    <span class="c1">/// @return bool_ True if the address is in merchant/redeemer whitelist and is NOT a blacklisted address, otherwise false.
</span>    <span class="k">function</span> <span class="n">isMerchant</span><span class="p">(</span><span class="kt">address</span> <span class="n">_address</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">bool_</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">/// @notice Event emitted when the Merchant/Redeemer List is edited
</span>    <span class="c1">/// @param action Tags "add" or "remove" for action type
</span>    <span class="c1">/// @param addresses An array of merchant wallet addresses that was just added or removed from Merchant/Redeemer whitelist
</span>    <span class="c1">/// @param metadata Optional comments or notes about the added or removed addresses.
</span>    <span class="k">event</span> <span class="n">MerchantList</span><span class="p">(</span><span class="kt">string</span> <span class="n">action</span><span class="p">,</span> <span class="kt">address</span><span class="p">[]</span> <span class="n">addresses</span><span class="p">,</span> <span class="kt">string</span> <span class="n">metadata</span><span class="p">);</span>

    <span class="c1">/// @notice Event emitted when the Blacklist is edited
</span>    <span class="c1">/// @param action Tags "add" or "remove" for action type
</span>    <span class="c1">/// @param addresses An array of wallet addresses that was just added or removed from address blacklist
</span>    <span class="c1">/// @param metadata Optional comments or notes about the added or removed addresses.
</span>    <span class="k">event</span> <span class="n">Blacklist</span><span class="p">(</span><span class="kt">string</span> <span class="n">action</span><span class="p">,</span> <span class="kt">address</span><span class="p">[]</span> <span class="n">addresses</span><span class="p">,</span> <span class="kt">string</span> <span class="n">metadata</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="pbmrc1---base-interface">PBMRC1 - Base Interface</h3>

<p>This interface contains the essential functions required to implement a pre-loaded PBM.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">/// LIST OF EVENTS TO BE EMITTED
/// A database or explorer may listen to events and be able to provide indexed and categorized searches
/// @title PBM Specification interface
/// @notice The PBM (purpose bound money) allows us to add logical requirements on the use of sovTokens.
/// The PBM acts as wrapper around the sovTokens and implements the necessary business logic.
/// @dev PBM deployer must assign an overall owner to the smart contract. If fine grain access controls are required, EIP-5982 can be used on top of ERC173
</span><span class="k">interface</span> <span class="n">IPBMRC1</span> <span class="k">is</span> <span class="n">IERC173</span><span class="p">,</span> <span class="n">IERC5679Ext1155</span> <span class="p">{</span>

    <span class="c1">/// @notice Initialise the contract by specifying an underlying ERC20-compatible token address,
</span>    <span class="c1">/// contract expiry, and the PBM address list.
</span>    <span class="c1">/// @param _sovToken The address of the underlying sovToken.
</span>    <span class="c1">/// @param _expiry The contract-wide expiry timestamp (in Unix epoch time).
</span>    <span class="c1">/// @param _pbmWrapperLogic This address should point to a smart contract that contains conditions governing a PBM;
</span>    <span class="c1">/// such as purpose-bound conditions (ie: an address list determining whether a PBM is permitted to be transferred to or to be unwrapped)
</span>    <span class="c1">/// and other relevant business logic, effectively implementing an inversion of control.
</span>    <span class="k">function</span> <span class="n">initialise</span><span class="p">(</span><span class="kt">address</span> <span class="n">_sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_expiry</span><span class="p">,</span> <span class="kt">address</span> <span class="n">_pbmWrapperLogic</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="c1">/// @notice Returns the Uniform Resource Identifier (URI) metadata information for the PBM with the corresponding tokenId
</span>    <span class="c1">/// @dev URIs are defined in RFC 3986.
</span>    <span class="c1">/// The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".
</span>    <span class="c1">/// Developer may choose to adhere to the ERC1155Metadata_URI extension interface if necessary.
</span>    <span class="c1">/// The URI is not expected to be immutable.
</span>    <span class="c1">/// @param tokenId The id for the PBM in query
</span>    <span class="c1">/// @return Returns the metadata URI string for the PBM
</span>    <span class="k">function</span> <span class="n">uri</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">)</span> <span class="k">external</span>  <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">string</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
        @notice Creates a PBM copy ( ERC1155 NFT ) of an existing PBM token type.
        @dev See {IERC5679Ext1155} on further implementation notes
        @param receiver The wallet address to which the created PBMs need to be transferred to
        @param tokenId The identifier of the PBM token type to be copied.
        @param amount The number of the PBMs that are to be created
        @param data Additional data with no specified format, based on eip-5750

        This function will transfer the underlying token from the caller into the PBM smart contract.
        IMPT: Before minting, the caller should approve the contract address to spend sovTokens on behalf of the caller.
            This can be done by calling the `approve` or `increaseMinterAllowance` functions of the ERC-20 contract and specifying `_spender` to be the PBM contract address.
            Ref : https://eips.ethereum.org/EIPS/eip-20

        WARNING: Any contracts that externally call these safeMint() and safeMintBatch() functions should implement some sort of reentrancy guard procedure
        (such as OpenZeppelin's ReentrancyGuard) or a Checks-effects-interactions pattern.

        As per ERC-5679 standard: When the token is being minted, the transfer events MUST be emitted as if the token in the `amount` for EIP-1155
        and `tokenId` being _id for EIP-1155 were transferred from address 0x0 to the recipient address identified by receiver.
        The total supply MUST increase accordingly.

        MUST Emits {TokenWrap} event as the underlying sovToken is wrapped by PBM wrapper smart contract during minting.

        Requirements:
        - contract must not be paused
        - tokens must not be expired
        - `tokenId` should be a valid id that has already been created
        - caller should have the necessary amount of the sovTokens required to mint
        - caller should have approved the PBM contract to spend the sovTokens
        - receiver should not be blacklisted
     */</span>
    <span class="k">function</span> <span class="n">safeMint</span><span class="p">(</span><span class="kt">address</span> <span class="n">receiver</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
        @notice Creates multiple PBM copies (ERC1155 NFT) of an existing PBM token type.
        @dev See {IERC5679Ext1155}.
        @param receiver The wallet address to which the created PBMs need to be transferred to
        @param tokenIds The identifier of the PBM token type
        @param amounts The number of the PBMs that are to be created
        @param data Additional data with no specified format, based on eip-5750

        This function will transfer the underlying token from the caller into the PBM smart contract.
        IMPT: Before minting, the caller should approve the contract address to spend sovTokens on behalf of the caller.
            This can be done by calling the `approve` or `increaseMinterAllowance` functions of the ERC-20 contract and specifying `_spender` to be the PBM contract address.
            Ref : https://eips.ethereum.org/EIPS/eip-20

        WARNING: Any contracts that externally call these safeMint() and safeMintBatch() functions should implement some sort of reentrancy guard procedure
        (such as OpenZeppelin's ReentrancyGuard) or a Checks-effects-interactions pattern.

        As per ERC-5679 standard: When the token is being minted, the transfer events MUST be emitted as if the token in the `amount` for EIP-1155
        and `tokenId` being _id for EIP-1155 were transferred from address 0x0 to the recipient address identified by receiver.
        The total supply MUST increase accordingly.

        MUST Emits {TokenWrap} event as the underlying sovToken is wrapped by PBM wrapper smart contract during minting.

        Requirements:
        - contract must not be paused
        - tokens must not be expired
        - `tokenIds` should all be valid ids that have already been created
        - `tokenIds` and `amounts` list need to have the same number of values
        - caller should have the necessary amount of the sovTokens required to mint
        - caller should have approved the PBM contract to spend the sovTokens
        - receiver should not be blacklisted
     */</span>
    <span class="k">function</span> <span class="n">safeMintBatch</span><span class="p">(</span><span class="kt">address</span> <span class="n">receiver</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">tokenIds</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
        @notice Burns a PBM token. Upon burning of the tokens, the underlying wrapped token (if any) should be handled.
        @dev Destroys `amount` tokens of token type `tokenId` from `from`
        @dev See {IERC5679Ext1155}

        @param from The originating wallet address of the PBMs to be burned
        @param tokenId The identifier of the PBM token type
        @param amount The amount of the PBMs that are to be burned
        @param data Additional data with no specified format, based on eip-5750

        MUST Emits {TransferSingle} event.
        MUST Emits {TokenUnwrapForPBMBurn} event if the underlying wrapped token is moved out of the PBM smart contract.

        Requirements:
        - `from` cannot be the zero address.
        - `from` must have at least `amount` tokens of token type `tokenId`.

     */</span>
    <span class="k">function</span> <span class="n">burn</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
        @notice Burns multiple PBM token. Upon burning of the tokens, the underlying wrapped token (if any) should be handled.
        @dev Destroys `amount` tokens of token type `tokenId` from `from`
        @dev See {IERC5679Ext1155}

        @param from The originating wallet address of the PBMs to be burned
        @param tokenIds The identifier of the PBM token types
        @param amounts The amount of the PBMs that are to be burned for each tokenId in _tokenIds
        @param data Additional data with no specified format, based on eip-5750

        Must Emits {TransferSingle} event.
        Must Emits {TokenUnwrapForPBMBurn} event if the underlying wrapped token is moved out of the PBM smart contract.

        Requirements:
        - `from` cannot be the zero address.
        - `from` must have at least amount specified in `_amounts` of the corresponding token type tokenId in `_tokenIds` array.
     */</span>
    <span class="k">function</span> <span class="n">burnBatch</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">tokenIds</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="c1">/// @notice Transfers the PBM(NFT) from one wallet to another.
</span>    <span class="c1">/// @dev This function extends the ERC-1155 standard in order to allow the PBM token to be freely transferred between wallet addresses due to
</span>    <span class="c1">/// widespread support accross wallet providers. Specific conditions and restrictions on whether a pbm can be moved across addresses can be incorporated in this function.
</span>    <span class="c1">/// Unwrap logic MAY also be placed within this function to be called.
</span>    <span class="c1">/// @param from The account from which the PBM (NFT) is moving from
</span>    <span class="c1">/// @param to The account which is receiving the PBM (NFT)
</span>    <span class="c1">/// @param id The identifier of the PBM token type
</span>    <span class="c1">/// @param amount The number of (quantity) the PBM type that are to be transferred of the PBM type
</span>    <span class="c1">/// @param data To record any data associated with the transaction, can be left blank if none
</span>    <span class="k">function</span> <span class="n">safeTransferFrom</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">id</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="c1">/// @notice Transfers the PBM(NFT)(s) from one wallet to another.
</span>    <span class="c1">/// @dev This function extends the ERC-1155 standard in order to allow the PBM token to be freely transferred between wallet addresses due to
</span>    <span class="c1">/// widespread support accross wallet providers.  Specific conditions and restrictions on whether a pbm can be moved across addresses can be incorporated in this function.
</span>    <span class="c1">/// Unwrap logic MAY also be placed within this function to be called.
</span>    <span class="c1">/// If the receiving wallet is a whitelisted /redeemer wallet address, the PBM(NFT)(s) will be burnt and the underlying sovTokens will be transferred to the merchant/redeemer wallet instead.
</span>    <span class="c1">/// @param from The account from which the PBM (NFT)(s) is moving from
</span>    <span class="c1">/// @param to The account which is receiving the PBM (NFT)(s)
</span>    <span class="c1">/// @param ids The identifiers of the different PBM token type
</span>    <span class="c1">/// @param amounts The number of (quantity) the different PBM types that are to be created
</span>    <span class="c1">/// @param data To record any data associated with the transaction, can be left blank if none.
</span>    <span class="k">function</span> <span class="n">safeBatchTransferFrom</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">ids</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="c1">/// @notice Unwraps the underlying ERC-20 compatible tokens to an intended end point (ie: merchant/redeemer) upon fulfilling the required PBM conditions.
</span>    <span class="c1">/// @dev Add implementation specific logic for the conditions under which a PBM processes and transfers the underlying tokens here.
</span>    <span class="c1">/// e.g. If the receving wallet is a whitelisted merchant/redeemer wallet address, the PBM (NFT) MUST be burnt and the underlying sovTokens
</span>    <span class="c1">/// will unwrapped to be transferred to the merchant/redeemer wallet.
</span>    <span class="c1">/// MUST emit the event {TokenUnwrapForTarget} on success
</span>    <span class="c1">/// @param from The account currently holding the PBM
</span>    <span class="c1">/// @param to The account receiving the PBM (NFT)
</span>    <span class="c1">/// @param tokenId The identifier of the PBM token type
</span>    <span class="c1">/// @param amount The quantity of the PBM type involved in this transaction
</span>    <span class="c1">/// @param data Additional data without a specified format, based on EIP-5750
</span>    <span class="k">function</span> <span class="n">unwrap</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">)</span> <span class="k">internal</span><span class="p">;</span>

    <span class="c1">/// @notice Allows the creator of a PBM token type to retrieve all locked-up underlying sovTokens within that PBM.
</span>    <span class="c1">/// @dev Ensure that only the creator of the PBM token type or the contract owner can call this function.
</span>    <span class="c1">/// Validate the token state and existence, handle PBM token burning if necessary, safely transfer the remaining sovTokens to the originator,
</span>    <span class="c1">/// MUST emit {PBMrevokeWithdraw} upon a successful revoke.
</span>    <span class="c1">/// @param tokenId The identifier of the PBM token type
</span>    <span class="c1">/// Requirements:
</span>    <span class="c1">/// - `tokenId` should be a valid identifier for an existing PBM token type.
</span>    <span class="c1">/// - The caller must be either the creator of the token type or the smart contract owner.
</span>    <span class="k">function</span> <span class="n">revokePBM</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="c1">/// @notice Emitted when a PBM type creator withdraws the underlying sovTokens from all the remaining expired PBMs
</span>    <span class="c1">/// @param beneficiary the address ( PBM type creator ) which receives the sovToken
</span>    <span class="c1">/// @param PBMTokenId The identifiers of the different PBM token type
</span>    <span class="c1">/// @param sovToken The address of the underlying sovToken
</span>    <span class="c1">/// @param sovTokenValue The number of underlying sovTokens transferred
</span>    <span class="k">event</span> <span class="n">PBMrevokeWithdraw</span><span class="p">(</span><span class="kt">address</span> <span class="n">beneficiary</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">PBMTokenId</span><span class="p">,</span> <span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>

    <span class="c1">/// @notice Emitted when the underlying tokens are unwrapped and transferred to a specific purpose-bound address.
</span>    <span class="c1">/// This event signifies the end of the PBM lifecycle, as all necessary conditions have been met to release the underlying tokens to the recipient (whitelisted merchant/redeemer with non-blacklisted wallet address).
</span>    <span class="c1">/// If there are multiple different underlying tokens involved in a single unwrap operation, this event should be emitted for each underlying token.
</span>    <span class="c1">/// @param from The address from which the PBM tokens are being unwrapped.
</span>    <span class="c1">/// @param to The purpose-bound address receiving the unwrapped underlying tokens.
</span>    <span class="c1">/// @param tokenIds An array containing the identifiers of the unwrapped PBM token types.
</span>    <span class="c1">/// @param amounts An array containing the quantities of the corresponding unwrapped PBM tokens.
</span>    <span class="c1">/// @param sovToken The address of the underlying sovToken.
</span>    <span class="c1">/// @param sovTokenValue The amount of unwrapped underlying sovTokens transferred.
</span>    <span class="k">event</span> <span class="n">TokenUnwrapForTarget</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">tokenIds</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>

    <span class="c1">/// @notice Emitted when PBM tokens are burned, resulting in the unwrapping of the underlying tokens for the designated recipient.
</span>    <span class="c1">/// This event is required if there is an unwrapping of the underlying tokens during the PBM (NFT) burning process.
</span>    <span class="c1">/// If there are multiple different underlying tokens involved in a single unwrap operation, this event should be emitted for each underlying token.
</span>    <span class="c1">/// @param from The address from which the PBM tokens are being burned.
</span>    <span class="c1">/// @param to The address receiving the unwrapped underlying tokens.
</span>    <span class="c1">/// @param tokenIds An array containing the identifiers of the burned PBM token types.
</span>    <span class="c1">/// @param amounts An array containing the quantities of the corresponding burned PBM tokens.
</span>    <span class="c1">/// @param sovToken The address of the underlying sovToken.
</span>    <span class="c1">/// @param sovTokenValue The amount of unwrapped underlying sovTokens transferred.
</span>    <span class="k">event</span> <span class="n">TokenUnwrapForPBMBurn</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">tokenIds</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>

    <span class="c1">/// Indicates the wrapping of an token into the PBM smart contract.
</span>    <span class="c1">/// @notice Emitted when underlying tokens are wrapped within the PBM smart contract.
</span>    <span class="c1">/// If there are multiple different underlying tokens involved in a single wrap operation, this event should be emitted for each underlying token.
</span>    <span class="c1">/// This event signifies the beginning of the PBM lifecycle, as tokens are now managed by the conditions within the PBM contract.
</span>    <span class="c1">/// @param from The address initiating the token wrapping process, and
</span>    <span class="c1">/// @param tokenIds An array containing the identifiers of the token types being wrapped.
</span>    <span class="c1">/// @param amounts An array containing the quantities of the corresponding wrapped tokens.
</span>    <span class="c1">/// @param sovToken The address of the underlying sovToken.
</span>    <span class="c1">/// @param sovTokenValue The amount of wrapped underlying sovTokens transferred.
</span>    <span class="k">event</span> <span class="n">TokenWrap</span><span class="p">(</span><span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">tokenIds</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="n">amounts</span><span class="p">,</span><span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="extensions">Extensions</h3>

<h4 id="pbmrc1---token-receiver">PBMRC1 - Token Receiver</h4>

<p>Smart contracts MUST implement all of the functions in the PBMRC1_TokenReceiver interface to subscribe to PBM unwrap callbacks.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">/// @notice Smart contracts MUST implement the ERC-165 `supportsInterface` function and signify support for the `PBMRC1_TokenReceiver` interface to accept callbacks.
/// It is optional for a receiving smart contract to implement the `PBMRC1_TokenReceiver` interface
/// @dev WARNING: Reentrancy guard procedure, Non delegate call, or the check-effects-interaction pattern must be adhere to when calling an external smart contract.
/// The interface functions MUST only be called at the end of the `unwrap` function.
</span><span class="k">interface</span> <span class="n">PBMRC1_TokenReceiver</span> <span class="p">{</span>
    <span class="cm">/**
        @notice Handles the callback from a PBM smart contract upon unwrapping
        @dev An PBM smart contract MUST call this function on the token recipient contract, at the end of a `unwrap` if the
        receiver smart contract supports type(PBMRC1_TokenReceiver).interfaceId
        @param _operator  The address which initiated the transfer (either the address which previously owned the token or the address authorised to make transfers on the owner's behalf) (i.e. msg.sender)
        @param _from      The address which previously owned the token
        @param _id        The ID of the token being unwrapped
        @param _value     The amount of tokens being transferred
        @param _data      Additional data with no specified format
        @return           `bytes4(keccak256("onPBMRC1Unwrap(address,address,uint256,uint256,bytes)"))`
    */</span>
    <span class="k">function</span> <span class="n">onPBMRC1Unwrap</span><span class="p">(</span><span class="kt">address</span> <span class="n">_operator</span><span class="p">,</span> <span class="kt">address</span> <span class="n">_from</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_id</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_value</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">_data</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">);</span>

    <span class="cm">/**
        @notice Handles the callback from a PBM smart contract upon unwrapping a batch of tokens
        @dev An PBM smart contract MUST call this function on the token recipient contract, at the end of a `unwrap` if the
        receiver smart contract supports type(PBMRC1_TokenReceiver).interfaceId

        @param _operator  The address which initiated the transfer (either the address which previously owned the token or the address authorised to make transfers on the owner's behalf) (i.e. msg.sender)
        @param _from      The address which previously owned the token
        @param _id        The ID of the token being unwrapped
        @param _value     The amount of tokens being transferred
        @param _data      Additional data with no specified format
        @return           `bytes4(keccak256("onPBMRC1BatchUnwrap(address,address,uint256,uint256,bytes)"))`
    */</span>
    <span class="k">function</span> <span class="n">onPBMRC1BatchUnwrap</span><span class="p">(</span><span class="kt">address</span> <span class="n">_operator</span><span class="p">,</span> <span class="kt">address</span> <span class="n">_from</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">_ids</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">_values</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">_data</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h4 id="pbmrc2---non-preloaded-pbm-interface">PBMRC2 - Non preloaded PBM Interface</h4>

<p>The <strong>Non Preloaded</strong> PBM extension is OPTIONAL for compliant smart contracts. This allows contracts to bind an underlying sovToken to the PBM at a later date instead of during a minting process.</p>

<p>Compliant contract <strong>MUST</strong> implement the following interface:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/**
 *  @dev This interface extends IPBMRC1, adding functions for working with non-preloaded PBMs.
 *  Non-preloaded PBMs are minted as empty containers without any underlying tokens of value,
 *  allowing the loading of the underlying token to happen at a later stage.
 */</span>
<span class="k">interface</span> <span class="n">PBMRC2_NonPreloadedPBM</span> <span class="k">is</span> <span class="n">IPBMRC1</span> <span class="p">{</span>

  <span class="c1">/// @notice This function extends IPBMRC1 to mint PBM tokens as empty containers without underlying tokens of value.
</span>  <span class="c1">/// @dev The loading of the underlying token of value can be done by calling the `load` function. The function parameters should be identical to IPBMRC1
</span>  <span class="k">function</span> <span class="n">safeMint</span><span class="p">(</span><span class="kt">address</span> <span class="n">receiver</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

  <span class="c1">/// @notice This function extends IPBMRC1 to mint PBM tokens as empty containers without underlying tokens of value.
</span>  <span class="c1">/// @dev The loading of the underlying token of value can be done by calling the `load` function. The function parameters should be identical to IPBMRC1
</span>  <span class="k">function</span> <span class="n">safeMintBatch</span><span class="p">(</span><span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">ids</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">[]</span> <span class="k">calldata</span> <span class="n">amounts</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

  <span class="c1">/// @notice Wrap an amount of sovTokens into the PBM
</span>  <span class="c1">/// @dev function will pull sovTokens from msg.sender
</span>  <span class="c1">/// Approval must be given to the PBM smart contract in order to for the pbm to pull money from msg.sender
</span>  <span class="c1">/// underlying data structure must record how much the msg.sender has been loaded into the PBM.
</span>  <span class="c1">/// Emits {TokenLoad} event.
</span>  <span class="c1">/// @param amount    The amount of sovTokens to be loaded
</span>  <span class="k">function</span> <span class="n">load</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">amount</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

  <span class="c1">/// @notice Retrieves the balance of the underlying sovToken associated with a specific PBM token type and user address.
</span>  <span class="c1">/// This function provides a way to check the amount of the underlying token that a user has loaded into a particular PBM token.
</span>  <span class="c1">/// @param user The address of the user whose underlying token balance is being queried.
</span>  <span class="c1">/// @return The balance of the underlying sovToken associated with the specified PBM token type and user address.
</span>  <span class="k">function</span> <span class="n">underlyingBalanceOf</span><span class="p">(</span><span class="kt">address</span> <span class="n">user</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>

  <span class="c1">/// @notice Unloads all of the underlying token belonging to the caller from the PBM smart contract.
</span>  <span class="c1">/// @dev The underlying token that belongs to the caller (msg.sender) will be removed and transferred
</span>  <span class="c1">/// back to the caller.
</span>  <span class="c1">/// Emits {TokenUnload} event.
</span>  <span class="c1">/// @param amount The quantity of the corresponding tokens to be unloaded.
</span>  <span class="c1">/// Amount should not exceed the amount that the caller has originally loaded into the PBM smart contract.
</span>  <span class="k">function</span> <span class="n">unload</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">amount</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

  <span class="c1">/// @notice Emitted when an underlying token is loaded into a PBM
</span>  <span class="c1">/// @param caller Address by which sovToken is taken from.
</span>  <span class="c1">/// @param to Address by which the token is loaded and assigned to
</span>  <span class="c1">/// @param amount The quantity of tokens to be loaded
</span>  <span class="c1">/// @param sovToken The address of the underlying sovToken.
</span>  <span class="c1">/// @param sovTokenValue The amount of underlying sovTokens loaded
</span>  <span class="k">event</span> <span class="n">TokenLoad</span><span class="p">(</span><span class="kt">address</span> <span class="n">caller</span><span class="p">,</span> <span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>

  <span class="c1">/// @notice Emitted when an underlying token is unloaded from a PBM.
</span>  <span class="c1">/// This event indicates the process of releasing the underlying token from the PBM smart contract.
</span>  <span class="c1">/// @param caller The address initiating the token unloading process.
</span>  <span class="c1">/// @param from The address from which the token is being unloaded and removed from.
</span>  <span class="c1">/// @param amount The quantity of the corresponding unloaded tokens.
</span>  <span class="c1">/// @param sovToken The address of the underlying sovToken.
</span>  <span class="c1">/// @param sovTokenValue The amount of unloaded underlying sovTokens transferred.
</span>  <span class="k">event</span> <span class="n">TokenUnload</span><span class="p">(</span><span class="kt">address</span> <span class="n">caller</span><span class="p">,</span> <span class="kt">address</span> <span class="n">from</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">address</span> <span class="n">sovToken</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">sovTokenValue</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="rationale">Rationale</h2>

<h3 id="why-sovtoken-must-be-erc-20-compatible">Why sovToken <strong>MUST</strong> be ERC-20 compatible?</h3>

<p>As PBM is envisioned to have functionality of money, it has to be a fungible token with stable value. Currently, the major stablecoins in the market are mainly based on the ERC-20 interface. ERC-20 or ERC-20 compatible tokens are the most widely supported by existing wallets, defi apps, and used also by protocol design such as <a href="./eip-4337.md">ERC-4337</a> and more importantly they are the de facto standard for fungible tokens.</p>

<p>With regards to <a href="./eip-721.md">ERC-721</a> and ERC-1155 compatible tokens:</p>

<ul>
  <li>ERC-721 is not suitable given that it is a standard for non-fungible tokens, which cannot fulfill the functions of money.</li>
  <li>While ERC-1155 tokens could be used for fungible tokens, we decided not to include it because there is a lack of ERC-1155 stablecoins in the market. Requiring the PBM interface to support both ERC-20 compatible and ERC-1155 compatible sovToken would complicate PBM interface without adding much practical utility. Furthermore, the base ERC-1155 does not support decimals, but this is not a dealbreaker as there can be workarounds. However, should there be changes in the stablecoin market in future, a revision can be considered.</li>
</ul>

<h3 id="why-pbm-wapper-must-be-erc-1155-compatible">Why PBM Wapper <strong>MUST</strong> be ERC-1155 compatible?</h3>

<p>This paper extends the ERC-1155 standards in order to enable easy adoption by existing wallet providers. Currently, most wallet providers are able to support and display ERC-20, ERC-1155 and ERC-721 standards. An implementation which doesn’t extend these standards will require the wallet provider to build a custom user interface and interfacing logic which increases the implementation cost and lengthen the time-to-market.</p>

<p>The core aim of our proposal is to standardize the implementation of PBM. Hence, we have surveyed existing interface standards and decided to build upon ERC-1155 standard for the PBM tokens for the following reasons:</p>

<ul>
  <li>ERC-1155 allows a single contract to support multiple tokens. This is very useful for the PBM use cases as a single contract can support issuance of tokens with different denominations, expiry dates, business logics.</li>
  <li>ERC-1155 also has batch transfer support, which is absent in ERC-20, which could lead to gas savings when tokens have to be airdropped to a large number of recipients.</li>
  <li>ERC-1155 is able to support semi-fungible tokens which could be very useful for PBM use cases as a PBM can be converted into a collectible after its expiry.</li>
  <li>ERC-1155 allows for a visualisation of a PBM token on the UI of a wallet issuer.</li>
</ul>

<h3 id="why-pbm-must-ensure-the-destination-address-for-unwrapped-sovtoken-is-in-a-whitelist-of-merchantredeemer-addresses-and-not-in-a-blacklist-of-banned-addresses-prior-to-unwrapping-the-underlying-sovtoken">Why PBM <strong>MUST</strong> ensure the destination address for unwrapped sovToken is in a whitelist of Merchant/Redeemer addresses and not in a blacklist of banned addresses prior to unwrapping the underlying sovToken?</h3>

<p>Why we need a whitelist?</p>

<ul>
  <li>The whitelist is a compulsory requirement because a PBM is purpose-bound, i.e. it should be unwrapped only if all conditions are fulfilled and it is transferred to someone in the predefined whitelist.</li>
  <li>In some implementations, developers can define that a whitelisted address is something that is dynamically determined at run time as well, such as presence of an NFT in a wallet address, or relying on an oracle etc.</li>
</ul>

<p>Why we need a blacklist?</p>

<ul>
  <li>The blacklist is a compulsory requirement to ensure that accounts which were banned for various reasons (e.g. address owner has re-registered a new account, address owner suspended/withdrawn/expelled due to complaints or law enforcement reason etc).</li>
</ul>

<p>Why we can’t have either a whitelist or a blacklist?</p>

<ul>
  <li>While the same effect can be obtained by only having a whitelist, repeatedly redeploying the whitelist to the blockchain to ban one person is not gas efficient.</li>
  <li>Using a blacklist to implement purpose-bound money is not practical as you would need to have a list of all addresses to be excluded and update it whenever a new account is created.</li>
</ul>

<p>Why is there a need for destination?</p>

<ul>
  <li>This actually forms the core of what we are trying to propose - a PBM can only be unwrapped when it is transferred to pre-approved destinations.</li>
  <li>PBM can be transferred freely, but the target allowed to unwrap the PBM and take delivery of the underlying sovToken must be limited to differentiate it from plain vanilla stablecoins that are wrapped by smart contracts</li>
</ul>

<h3 id="what-does-business-logic-encompasses">What does business logic encompasses?</h3>

<ul>
  <li>In general, business logic can be divided into core, plugin and hook logic:
    <ul>
      <li>Core logic contains essential functionalities and validation checks and should be included in the PBM Wrapper contract.</li>
      <li>Plugin and hook logic can be contained in standalone smart contract modules and are registered by the PBM Wrapper contract. Plugin logic extends the core logic by adding functionality, e.g. custom data collection, additional administrative functions etc.</li>
      <li>Hook logic implements additional validation checks which are only applicable for a subset of PBMs.</li>
    </ul>
  </li>
  <li>“PBM business logic” can contain access control logic, PBM unwrapping logic, API logic to integrate with non-blockchain IT systems.</li>
  <li>As PBM can be used for a wide variety of use cases, ranging from government disbursement tokens, shopping vouchers, prepaid tokens, rewards points tokens, purpose bound donation token, school allowance token etc, with each use cases having a separate business logic, it was intentionally left undefined so that implementation authors can have maximum flexibility.</li>
</ul>

<h3 id="why-was-a-push-transaction-model-chosen">Why was a push transaction model chosen?</h3>

<ul>
  <li>This standard sticks to the push transaction model where the transfer of PBM is initiated on the senders side. Modern wallets can support the required PBM logic by embedding the unwrapping logic within the ERC-1155 <code class="language-plaintext highlighter-rouge">safeTransfer</code> function.</li>
</ul>

<h3 id="customisability">Customisability</h3>

<p>Each ERC-1155 PBM Token would map to an underlying <code class="language-plaintext highlighter-rouge">PBMToken</code> data structure that implementers are free to customize in accordance to the business logic.</p>

<p>By mapping the underlying ERC-1155 token model with an additional data structure, it allows for the flexibility in the management of multiple token types within the same smart contract with multiple conditional unwrapping logic attached to each token type which reduces the gas costs as there is no need to deploy multiple smart contracts for each token types.</p>

<ol>
  <li>
    <p>To keep it simple, this standard <em>intentionally</em> omits functions or events that doesn’t add to definition and concept of a PBM.</p>
  </li>
  <li>
    <p>This EIP makes no assumptions about access control or the conditions under which a function can be executed. It is the responsibility of the PBM creator to determine the various roles involved in each specific PBM business flow.</p>
  </li>
  <li>
    <p>The proposed PBM Architecture <em>intentionally</em> modular to enable greater customisability and reusability of smart contracts.</p>
  </li>
  <li>
    <p>Metadata associated to the PBM standard is not included the standard. If necessary, related metadata can be created with a separate metadata extension interface, e.g. <code class="language-plaintext highlighter-rouge">ERC721Metadata</code> from ERC-721. Refer to Opensea’s metadata-standards for an implementation example.</p>
  </li>
  <li>
    <p>To allow for future extensibility, it is <strong>RECOMMENDED</strong> that developers read and adopt the specifications for building general extensibility for method behaviours (<a href="./eip-5750.md">ERC-5750</a>).</p>
  </li>
</ol>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>This interface is designed to be compatible with ERC-1155.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>Reference implementations can be found in <a href="../assets/eip-7291/README.md"><code class="language-plaintext highlighter-rouge">README.md</code></a>.</p>

<h2 id="security-considerations">Security Considerations</h2>

<ul>
  <li>
    <p>Everything used in a smart contract is publicly visible, even local variables and state variables marked <code class="language-plaintext highlighter-rouge">private</code>.</p>
  </li>
  <li>
    <p>Due to gas limit, loops that do not have a fixed number of iterations have to be used cautiously.</p>
  </li>
  <li>
    <p>Never use tx.origin to check for authorization. <code class="language-plaintext highlighter-rouge">msg.sender</code> should be used to check for authorization.</p>
  </li>
  <li>
    <p>If library code is used as part of a <code class="language-plaintext highlighter-rouge">delegatecall</code>, make sure library code is stateless to prevent malicious actors from changing state in your contract via <code class="language-plaintext highlighter-rouge">delegatecall</code>.</p>
  </li>
  <li>
    <p>Malicious actors may try to front run transactions. As transactions take some time before they are mined, an attacker can watch the transaction pool and send a transaction, have it included in a block before the original transaction. This mechanism can be abused to re-order transactions to the attacker’s advantage. A commitment scheme can be used to prevent front running.</p>
  </li>
  <li>
    <p>Don’t use block.timestamp for a source of entropy and random number.</p>
  </li>
  <li>
    <p>Signing messages off-chain and having a contract that requires that signature before executing a function is a useful technique. However, the same signature can be exploited by malicious actors to execute a function multiple times. This can be harmful if the signer’s intention was to approve a transaction once. To prevent signature replay, messages should be signed with nonce and address of the contract.</p>
  </li>
  <li>
    <p>Malicious users may attempt to:</p>

    <ul>
      <li>Double spend through reentrancy.</li>
      <li>clone existing PBM Tokens to perform double-spending;</li>
      <li>create invalid PBM Token with no underlying sovToken; or</li>
      <li>falsifying the face value of PBM token through wrapping of fraudulent/invalid/worthless sovTokens.</li>
    </ul>
  </li>
  <li>
    <p>For consistency, when the contract is suspended or a user’s token transfer is restricted due to suspected fraudulent activity or erroneous transfers, corresponding restrictions <strong>MUST</strong> be applied to the user’s unwrap requests for the PBM Token.</p>
  </li>
  <li>
    <p>Security audits and tests should be performed to verify that unwrap logic behaves as expected or if any complex business logic is being implemented that involves calling an external smart contract to prevent re-entrancy attacks and other forms of call chain attacks.</p>
  </li>
  <li>
    <p>This EIP relies on the secure and accurate bookkeeping behavior of the token implementation.</p>

    <ul>
      <li>
        <p>Contracts adhering to this standard should closely monitor balance changes for each user during token consumption or minting.</p>
      </li>
      <li>
        <p>The PBM Wrapper must be meticulously designed to ensure effective control over the permission to mint new tokens. Failure to secure the minting permission can lead to fraudulent issuance and unauthorized inflation of the total token supply.</p>
      </li>
      <li>
        <p>The mapping of each PBM Token to the corresponding amount of underlying sovToken held by the smart contract requires careful accounting and auditing.</p>
      </li>
      <li>
        <p>The access control over permission to burn tokens should be carefully designed. Typically, only the following two roles are entitled to burn a token:</p>

        <ul>
          <li>Role 1. Prior to a PBM expiry, only whitelisted merchants/redeemers with non-blacklisted wallet addresses are allowed to unwrap and burn tokens that they holds.</li>
          <li>Role 2. After a PBM has expired:
            <ul>
              <li>whitelisted merchants/redeemers with non-blacklisted wallet addresses are allowed to unwrap and burn tokens that they hold; and</li>
              <li>PBM owners are allowed to burn unused PBM Tokens remaining in the hands of non-whitelisted merchants/redeemers to retrieve underlying sovTokens.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>Nevertheless, we do recognize there are potentially other use cases where a third type of role may be entitled to burning. Implementors should be cautious when designing access control over burning of PBM Tokens.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>It is recommended to adopt a token standard that is compatible with ERC-20. Examples of such compatible tokens includes tokens implementing ERC-777 or ERC-1363. However, ERC-20 remains the most widely accepted because of its simplicity and there is a high degree of confidence in its security.</p>
  </li>
</ul>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
