<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Parent-Governed Non-Fungible Tokens Nesting | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Parent-Governed Non-Fungible Tokens Nesting | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-7401" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-7401" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Parent-Governed Non-Fungible Tokens Nesting</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>❗️ <strong><a href="./eip-7401.md">ERC-7401</a> supersedes <a href="./eip-6059.md">ERC-6059</a>.</strong> ❗️</p>

<p>The Parent-Governed NFT Nesting standard extends <a href="./eip-721.md">ERC-721</a> by allowing for a new inter-NFT relationship and interaction.</p>

<p>At its core, the idea behind the proposal is simple: the owner of an NFT does not have to be an Externally Owned Account (EOA) or a smart contract, it can also be an NFT.</p>

<p>The process of nesting an NFT into another is functionally identical to sending it to another user. The process of sending a token out of another one involves issuing a transaction from the account owning the parent token.</p>

<p>An NFT can be owned by a single other NFT, but can in turn have a number of NFTs that it owns. This proposal establishes the framework for the parent-child relationships of NFTs. A parent token is the one that owns another token. A child token is a token that is owned by another token. A token can be both a parent and child at the same time. Child tokens of a given token can be fully managed by the parent token’s owner, but can be proposed by anyone.</p>

<p><img src="../assets/eip-7401/img/eip-7401-nestable-tokens.png" alt="Nestable tokens" /></p>

<p>The graph illustrates how a child token can also be a parent token, but both are still administered by the root parent token’s owner.</p>

<h2 id="motivation">Motivation</h2>

<p>With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to own other tokens allows for greater utility, usability and forward compatibility.</p>

<p>In the four years since <a href="./eip-721.md">ERC-721</a> was published, the need for additional functionality has resulted in countless extensions. This ERC improves upon ERC-721 in the following areas:</p>

<ul>
  <li><a href="#bundling">Bundling</a></li>
  <li><a href="#collecting">Collecting</a></li>
  <li><a href="#membership">Membership</a></li>
  <li><a href="#delegation">Delegation</a></li>
</ul>

<p>This proposal fixes the inconsistency in the <a href="./eip-6059.md">ERC-6059</a> interface specification, where interface ID doesn’t match the interface specified as the interface evolved during the proposal’s lifecycle, but one of the parameters was not added to it. The missing parameter is, however, present in the interface ID. Apart from this fix, this proposal is functionally equivalent to <a href="./eip-6059.md">ERC-6059</a>.</p>

<h3 id="bundling">Bundling</h3>

<p>One of the most frequent uses of <a href="./eip-721.md">ERC-721</a> is to disseminate the multimedia content that is tied to the tokens. In the event that someone wants to offer a bundle of NFTs from various collections, there is currently no easy way of bundling all of these together and handle their sale as a single transaction. This proposal introduces a standardized way of doing so. Nesting all of the tokens into a simple bundle and selling that bundle would transfer the control of all of the tokens to the buyer in a single transaction.</p>

<h3 id="collecting">Collecting</h3>

<p>A lot of NFT consumers collect them based on countless criteria. Some aim for utility of the tokens, some for the uniqueness, some for the visual appeal, etc. There is no standardized way to group the NFTs tied to a specific account. By nesting NFTs based on their owner’s preference, this proposal introduces the ability to do it. The root parent token could represent a certain group of tokens and all of the children nested into it would belong to it.</p>

<p>The rise of soulbound, non-transferable, tokens, introduces another need for this proposal. Having a token with multiple soulbound traits (child tokens), allows for numerous use cases. One concrete example of this can be drawn from supply chains use case. A shipping container, represented by an NFT with its own traits, could have multiple child tokens denoting each leg of its journey.</p>

<h3 id="membership">Membership</h3>

<p>A common utility attached to NFTs is a membership to a Decentralised Autonomous Organization (DAO) or to some other closed-access group. Some of these organizations and groups occasionally mint NFTs to the current holders of the membership NFTs. With the ability to nest mint a token into a token, such minting could be simplified, by simply minting the bonus NFT directly into the membership one.</p>

<h3 id="delegation">Delegation</h3>

<p>One of the core features of DAOs is voting and there are various approaches to it. One such mechanic is using fungible voting tokens where members can delegate their votes by sending these tokens to another member. Using this proposal, delegated voting could be handled by nesting your voting NFT into the one you are delegating your votes to and transferring it when the member no longer wishes to delegate their votes.</p>

<h2 id="specification">Specification</h2>

<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// @title EIP-7401 Parent-Governed Nestable Non-Fungible Tokens
/// @dev See https://eips.ethereum.org/EIPS/eip-7401
/// @dev Note: the ERC-165 identifier for this interface is 0x42b0e56f.
</span>
<span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="k">interface</span> <span class="n">IERC7059</span> <span class="cm">/* is ERC165 */</span> <span class="p">{</span>
    <span class="cm">/**
     * @notice The core struct of ownership.
     * @dev The `DirectOwner` struct is used to store information of the next immediate owner, be it the parent token,
     * an `ERC721Receiver` contract or an externally owned account.
     * @dev If the token is not owned by an NFT, the `tokenId` MUST equal `0`.
     * @param tokenId ID of the parent token
     * @param ownerAddress Address of the owner of the token. If the owner is another token, then the address MUST be
     *  the one of the parent token's collection smart contract. If the owner is externally owned account, the address
     *  MUST be the address of this account
     */</span>
    <span class="k">struct</span> <span class="n">DirectOwner</span> <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">;</span>
        <span class="kt">address</span> <span class="n">ownerAddress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice The core child token struct, holding the information about the child tokens.
     * @return tokenId ID of the child token in the child token's collection smart contract
     * @return contractAddress Address of the child token's smart contract
     */</span>
    <span class="k">struct</span> <span class="n">Child</span> <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">;</span>
        <span class="kt">address</span> <span class="n">contractAddress</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/**
     * @notice Used to notify listeners that the token is being transferred.
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     * @param from Address of the previous immediate owner, which is a smart contract if the token was nested.
     * @param to Address of the new immediate owner, which is a smart contract if the token is being nested.
     * @param fromTokenId ID of the previous parent token. If the token was not nested before, the value MUST be `0`
     * @param toTokenId ID of the new parent token. If the token is not being nested, the value MUST be `0`
     * @param tokenId ID of the token being transferred
     */</span>
    <span class="k">event</span> <span class="n">NestTransfer</span><span class="p">(</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="n">from</span><span class="p">,</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="n">to</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">fromTokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">toTokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners that a new token has been added to a given token's pending children array.
     * @dev Emitted when a child NFT is added to a token's pending array.
     * @param tokenId ID of the token that received a new pending child token
     * @param childIndex Index of the proposed child token in the parent token's pending children array
     * @param childAddress Address of the proposed child token's collection smart contract
     * @param childId ID of the child token in the child token's collection smart contract
     */</span>
    <span class="k">event</span> <span class="n">ChildProposed</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">childId</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners that a new child token was accepted by the parent token.
     * @dev Emitted when a parent token accepts a token from its pending array, migrating it to the active array.
     * @param tokenId ID of the token that accepted a new child token
     * @param childIndex Index of the newly accepted child token in the parent token's active children array
     * @param childAddress Address of the child token's collection smart contract
     * @param childId ID of the child token in the child token's collection smart contract
     */</span>
    <span class="k">event</span> <span class="n">ChildAccepted</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">childId</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners that all pending child tokens of a given token have been rejected.
     * @dev Emitted when a token removes all child tokens from its pending array.
     * @param tokenId ID of the token that rejected all of the pending children
     */</span>
    <span class="k">event</span> <span class="n">AllChildrenRejected</span><span class="p">(</span><span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to notify listeners a child token has been transferred from parent token.
     * @dev Emitted when a token transfers a child from itself, transferring ownership.
     * @param tokenId ID of the token that transferred a child token
     * @param childIndex Index of a child in the array from which it is being transferred
     * @param childAddress Address of the child token's collection smart contract
     * @param childId ID of the child token in the child token's collection smart contract
     * @param fromPending A boolean value signifying whether the token was in the pending child tokens array (`true`) or
     *  in the active child tokens array (`false`)
     * @param toZero A boolean value signifying whether the token is being transferred to the `0x0` address (`true`) or
     *  not (`false`)
     */</span>
    <span class="k">event</span> <span class="n">ChildTransferred</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="k">indexed</span> <span class="n">childId</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">fromPending</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">toZero</span>
    <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve the *root* owner of a given token.
     * @dev The *root* owner of the token is the top-level owner in the hierarchy which is not an NFT.
     * @dev If the token is owned by another NFT, it MUST recursively look up the parent's root owner.
     * @param tokenId ID of the token for which the *root* owner has been retrieved
     * @return owner The *root* owner of the token
     */</span>
    <span class="k">function</span> <span class="n">ownerOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">)</span> <span class="k">external</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">owner</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve the immediate owner of the given token.
     * @dev If the immediate owner is another token, the address returned, MUST be the one of the parent token's
     *  collection smart contract.
     * @param tokenId ID of the token for which the direct owner is being retrieved
     * @return address Address of the given token's owner
     * @return uint256 The ID of the parent token. MUST be `0` if the owner is not an NFT
     * @return bool The boolean value signifying whether the owner is an NFT or not
     */</span>
    <span class="k">function</span> <span class="n">directOwnerOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span>
            <span class="kt">address</span><span class="p">,</span>
            <span class="kt">uint256</span><span class="p">,</span>
            <span class="kt">bool</span>
        <span class="p">);</span>

    <span class="cm">/**
     * @notice Used to burn a given token.
     * @dev When a token is burned, all of its child tokens are recursively burned as well.
     * @dev When specifying the maximum recursive burns, the execution MUST be reverted if there are more children to be
     *  burned.
     * @dev Setting the `maxRecursiveBurn` value to 0 SHOULD only attempt to burn the specified token and MUST revert if
     *  there are any child tokens present.
     * @param tokenId ID of the token to burn
     * @param maxRecursiveBurns Maximum number of tokens to recursively burn
     * @return uint256 Number of recursively burned children
     */</span>
    <span class="k">function</span> <span class="n">burn</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">maxRecursiveBurns</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to add a child token to a given parent token.
     * @dev This adds the child token into the given parent token's pending child tokens array.
     * @dev The destination token MUST NOT be a child token of the token being transferred or one of its downstream
     *  child tokens.
     * @dev This method MUST NOT be called directly. It MUST only be called from an instance of `IERC7059` as part of a 
        `nestTransfer` or `transferChild` to an NFT.
     * @dev Requirements:
     *
     *  - `directOwnerOf` on the child contract MUST resolve to the called contract.
     *  - the pending array of the parent contract MUST not be full.
     * @param parentId ID of the parent token to receive the new child token
     * @param childId ID of the new proposed child token
     */</span>
    <span class="k">function</span> <span class="n">addChild</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">childId</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to accept a pending child token for a given parent token.
     * @dev This moves the child token from parent token's pending child tokens array into the active child tokens
     *  array.
     * @param parentId ID of the parent token for which the child token is being accepted
     * @param childIndex Index of the child token to accept in the pending children array of a given token
     * @param childAddress Address of the collection smart contract of the child token expected to be at the specified
     *  index
     * @param childId ID of the child token expected to be located at the specified index
     */</span>
    <span class="k">function</span> <span class="n">acceptChild</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">parentId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to reject all pending children of a given parent token.
     * @dev Removes the children from the pending array mapping.
     * @dev The children's ownership structures are not updated.
     * @dev Requirements:
     *
     * - `parentId` MUST exist
     * @param parentId ID of the parent token for which to reject all of the pending tokens
     * @param maxRejections Maximum number of expected children to reject, used to prevent from
     *  rejecting children which arrive just before this operation.
     */</span>
    <span class="k">function</span> <span class="n">rejectAllChildren</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">maxRejections</span><span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to transfer a child token from a given parent token.
     * @dev MUST remove the child from the parent's active or pending children.
     * @dev When transferring a child token, the owner of the token MUST be set to `to`, or not updated in the event of `to`
     *  being the `0x0` address.
     * @param tokenId ID of the parent token from which the child token is being transferred
     * @param to Address to which to transfer the token to
     * @param destinationId ID of the token to receive this child token (MUST be 0 if the destination is not a token)
     * @param childIndex Index of a token we are transferring, in the array it belongs to (can be either active array or
     *  pending array)
     * @param childAddress Address of the child token's collection smart contract
     * @param childId ID of the child token in its own collection smart contract
     * @param isPending A boolean value indicating whether the child token being transferred is in the pending array of the
     *  parent token (`true`) or in the active array (`false`)
     * @param data Additional data with no specified format, sent in call to `to`
     */</span>
    <span class="k">function</span> <span class="n">transferChild</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">to</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">destinationId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">isPending</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="n">data</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>

    <span class="cm">/**
     * @notice Used to retrieve the active child tokens of a given parent token.
     * @dev Returns array of Child structs existing for parent token.
     * @dev The Child struct consists of the following values:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId ID of the parent token for which to retrieve the active child tokens
     * @return struct[] An array of Child structs containing the parent token's active child tokens
     */</span>
    <span class="k">function</span> <span class="n">childrenOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="n">Child</span><span class="p">[]</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve the pending child tokens of a given parent token.
     * @dev Returns array of pending Child structs existing for given parent.
     * @dev The Child struct consists of the following values:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId ID of the parent token for which to retrieve the pending child tokens
     * @return struct[] An array of Child structs containing the parent token's pending child tokens
     */</span>
    <span class="k">function</span> <span class="n">pendingChildrenOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="n">Child</span><span class="p">[]</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve a specific active child token for a given parent token.
     * @dev Returns a single Child struct locating at `index` of parent token's active child tokens array.
     * @dev The Child struct consists of the following values:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId ID of the parent token for which the child is being retrieved
     * @param index Index of the child token in the parent token's active child tokens array
     * @return struct A Child struct containing data about the specified child
     */</span>
    <span class="k">function</span> <span class="n">childOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="n">Child</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to retrieve a specific pending child token from a given parent token.
     * @dev Returns a single Child struct locating at `index` of parent token's active child tokens array.
     * @dev The Child struct consists of the following values:
     *  [
     *      tokenId,
     *      contractAddress
     *  ]
     * @param parentId ID of the parent token for which the pending child token is being retrieved
     * @param index Index of the child token in the parent token's pending child tokens array
     * @return struct A Child struct containing data about the specified child
     */</span>
    <span class="k">function</span> <span class="n">pendingChildOf</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">parentId</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">external</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="n">Child</span> <span class="k">memory</span><span class="p">);</span>

    <span class="cm">/**
     * @notice Used to transfer the token into another token.
     * @dev The destination token MUST NOT be a child token of the token being transferred or one of its downstream
     *  child tokens.
     * @param from Address of the direct owner of the token to be transferred
     * @param to Address of the receiving token's collection smart contract
     * @param tokenId ID of the token being transferred
     * @param destinationId ID of the token to receive the token being transferred
     * @param data Additional data with no specified format
     */</span>
    <span class="k">function</span> <span class="n">nestTransferFrom</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">from</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">to</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">destinationId</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ID MUST never be a <code class="language-plaintext highlighter-rouge">0</code> value, as this proposal uses <code class="language-plaintext highlighter-rouge">0</code> values do signify that the token/destination is not an NFT.</p>

<h2 id="rationale">Rationale</h2>

<p>Designing the proposal, we considered the following questions:</p>

<ol>
  <li><strong>How to name the proposal?</strong><br />
In an effort to provide as much information about the proposal we identified the most important aspect of the proposal; the parent centered control over nesting. The child token’s role is only to be able to be <code class="language-plaintext highlighter-rouge">Nestable</code> and support a token owning it. This is how we landed on the <code class="language-plaintext highlighter-rouge">Parent-Centered</code> part of the title.</li>
  <li><strong>Why is automatically accepting a child using <a href="./eip-712.md">EIP-712</a> permit-style signatures not a part of this proposal?</strong><br />
For consistency. This proposal extends ERC-721 which already uses 1 transaction for approving operations with tokens. It would be inconsistent to have this and also support signing messages for operations with assets.</li>
  <li><strong>Why use indexes?</strong><br />
To reduce the gas consumption. If the token ID was used to find which token to accept or reject, iteration over arrays would be required and the cost of the operation would depend on the size of the active or pending children arrays. With the index, the cost is fixed. Lists of active and pending children per token need to be maintained, since methods to get them are part of the proposed interface.<br />
To avoid race conditions in which the index of a token changes, the expected token ID as well as the expected token’s collection smart contract is included in operations requiring token index, to verify that the token being accessed using the index is the expected one.<br />
Implementation that would internally keep track of indices using mapping was attempted. The minimum cost of accepting a child token was increased by over 20% and the cost of minting has increased by over 15%. We concluded that it is not necessary for this proposal and can be implemented as an extension for use cases willing to accept the increased transaction cost this incurs. In the sample implementation provided, there are several hooks which make this possible.</li>
  <li><strong>Why is the pending children array limited instead of supporting pagination?</strong><br />
The pending child tokens array is not meant to be a buffer to collect the tokens that the root owner of the parent token wants to keep, but not enough to promote them to active children. It is meant to be an easily traversable list of child token candidates and should be regularly maintained; by either accepting or rejecting proposed child tokens. There is also no need for the pending child tokens array to be unbounded, because active child tokens array is.<br />
Another benefit of having bounded child tokens array is to guard against spam and griefing. As minting malicious or spam tokens could be relatively easy and low-cost, the bounded pending array assures that all of the tokens in it are easy to identify and that legitimate tokens are not lost in a flood of spam tokens, if one occurs.<br />
A consideration tied to this issue was also how to make sure, that a legitimate token is not accidentally rejected when clearing the pending child tokens array. We added the maximum pending children to reject argument to the clear pending child tokens array call. This assures that only the intended number of pending child tokens is rejected and if a new token is added to the pending child tokens array during the course of preparing such call and executing it, the clearing of this array SHOULD result in a reverted transaction.</li>
  <li><strong>Should we allow tokens to be nested into one of its children?</strong><br />
The proposal enforces that a parent token can’t be nested into one of its child token, or downstream child tokens for that matter. A parent token and its children are all managed by the parent token’s root owner. This means that if a token would be nested into one of its children, this would create the ownership loop and none of the tokens within the loop could be managed anymore.</li>
  <li><strong>Why is there not a “safe” nest transfer method?</strong><br />
<code class="language-plaintext highlighter-rouge">nestTransfer</code> is always “safe” since it MUST check for <code class="language-plaintext highlighter-rouge">IERC7059</code> compatibility on the destination.</li>
  <li><strong>How does this proposal differ from the other proposals trying to address a similar problem?</strong><br />
This interface allows for tokens to both be sent to and receive other tokens. The propose-accept and parent governed patterns allow for a more secure use. The backward compatibility is only added for ERC-721, allowing for a simpler interface. The proposal also allows for different collections to inter-operate, meaning that nesting is not locked to a single smart contract, but can be executed between completely separate NFT collections.<br />
Additionally this proposal addresses the inconsistencies between <code class="language-plaintext highlighter-rouge">interfaceId</code>, interface specification and example implementation of <a href="./eip-6059.md">ERC-6059</a>.</li>
</ol>

<h3 id="propose-commit-pattern-for-child-token-management">Propose-Commit pattern for child token management</h3>

<p>Adding child tokens to a parent token MUST be done in the form of propose-commit pattern to allow for limited mutability by a 3rd party. When adding a child token to a parent token, it is first placed in a <em>“Pending”</em> array, and MUST be migrated to the <em>“Active”</em> array by the parent token’s root owner. The <em>“Pending”</em> child tokens array SHOULD be limited to 128 slots to prevent spam and griefing.</p>

<p>The limitation that only the root owner can accept the child tokens also introduces a trust inherent to the proposal. This ensures that the root owner of the token has full control over the token. No one can force the user to accept a child if they don’t want to.</p>

<h3 id="parent-governed-pattern">Parent Governed pattern</h3>

<p>The parent NFT of a nested token and the parent’s root owner are in all aspects the true owners of it. Once you send a token to another one you give up ownership.</p>

<p>We continue to use ERC-721’s <code class="language-plaintext highlighter-rouge">ownerOf</code> functionality which will now recursively look up through parents until it finds an address which is not an NFT, this is referred to as the <em>root owner</em>. Additionally we provide the <code class="language-plaintext highlighter-rouge">directOwnerOf</code> which returns the most immediate owner of a token using 3 values: the owner address, the tokenId which MUST be 0 if the direct owner is not an NFT, and a flag indicating whether or not the parent is an NFT.</p>

<p>The root owner or an approved party MUST be able to do the following operations on children: <code class="language-plaintext highlighter-rouge">acceptChild</code>, <code class="language-plaintext highlighter-rouge">rejectAllChildren</code> and <code class="language-plaintext highlighter-rouge">transferChild</code>.</p>

<p>The root owner or an approved party MUST also be allowed to do these operations only when token is not owned by an NFT: <code class="language-plaintext highlighter-rouge">transferFrom</code>, <code class="language-plaintext highlighter-rouge">safeTransferFrom</code>, <code class="language-plaintext highlighter-rouge">nestTransferFrom</code>, <code class="language-plaintext highlighter-rouge">burn</code>.</p>

<p>If the token is owned by an NFT, only the parent NFT itself MUST be allowed to execute the operations listed above. Transfers MUST be done from the parent token, using <code class="language-plaintext highlighter-rouge">transferChild</code>, this method in turn SHOULD call <code class="language-plaintext highlighter-rouge">nestTransferFrom</code> or <code class="language-plaintext highlighter-rouge">safeTransferFrom</code> in the child token’s smart contract, according to whether the destination is an NFT or not. For burning, tokens must first be transferred to an EOA and then burned.</p>

<p>We add this restriction to prevent inconsistencies on parent contracts, since only the <code class="language-plaintext highlighter-rouge">transferChild</code> method takes care of removing the child from the parent when it is being transferred out of it.</p>

<h3 id="child-token-management">Child token management</h3>

<p>This proposal introduces a number of child token management functions. In addition to the permissioned migration from <em>“Pending”</em> to <em>“Active”</em> child tokens array, the main token management function from this proposal is the <code class="language-plaintext highlighter-rouge">transferChild</code> function. The following state transitions of a child token are available with it:</p>

<ol>
  <li>Reject child token</li>
  <li>Abandon child token</li>
  <li>Unnest child token</li>
  <li>Transfer the child token to an EOA or an <code class="language-plaintext highlighter-rouge">ERC721Receiver</code></li>
  <li>Transfer the child token into a new parent token</li>
</ol>

<p>To better understand how these state transitions are achieved, we have to look at the available parameters passed to <code class="language-plaintext highlighter-rouge">transferChild</code>:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">function</span> <span class="n">transferChild</span><span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">tokenId</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">to</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">destinationId</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childIndex</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">childAddress</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">childId</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">isPending</span><span class="p">,</span>
        <span class="kt">bytes</span> <span class="n">data</span>
    <span class="p">)</span> <span class="k">external</span><span class="p">;</span>
</code></pre></div></div>

<p>Based on the desired state transitions, the values of these parameters have to be set accordingly (any parameters not set in the following examples depend on the child token being managed):</p>

<ol>
  <li><strong>Reject child token</strong><br />
<img src="../assets/eip-7401/img/eip-7401-reject-child.png" alt="Reject child token" /></li>
  <li><strong>Abandon child token</strong><br />
<img src="../assets/eip-7401/img/eip-7401-abandon-child.png" alt="Abandon child token" /></li>
  <li><strong>Unnest child token</strong><br />
<img src="../assets/eip-7401/img/eip-7401-unnest-child.png" alt="Unnest child token" /></li>
  <li><strong>Transfer the child token to an EOA or an <code class="language-plaintext highlighter-rouge">ERC721Receiver</code></strong><br />
<img src="../assets/eip-7401/img/eip-7401-transfer-child-to-eoa.png" alt="Transfer child token to EOA" /></li>
  <li><strong>Transfer the child token into a new parent token</strong><br />
<img src="../assets/eip-7401/img/eip-7401-transfer-child-to-token.png" alt="Transfer child token to parent token" /><br />
This state change places the token in the pending array of the new parent token. The child token still needs to be accepted by the new parent token’s root owner in order to be placed into the active array of that token.</li>
</ol>

<h2 id="backwards-compatibility">Backwards Compatibility</h2>

<p>The Nestable token standard has been made compatible with <a href="./eip-721.md">ERC-721</a> in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.</p>

<p>The only incompatibility with ERC-721 is that Nestable tokens cannot use a token ID of 0.</p>

<p>There is some differentiation of how the <code class="language-plaintext highlighter-rouge">ownerOf</code> method behaves compared to ERC-721. The <code class="language-plaintext highlighter-rouge">ownerOf</code> method will now recursively look up through parent tokens until it finds an address that is not an NFT; this is referred to as the <em>root owner</em>. Additionally, we provide the <code class="language-plaintext highlighter-rouge">directOwnerOf</code>, which returns the most immediate owner of a token using 3 values: the owner address, the <code class="language-plaintext highlighter-rouge">tokenId</code>, which MUST be 0 if the direct owner is not an NFT, and a flag indicating whether or not the parent is an NFT. In case the token is owned by an EoA or an ERC-721 Receiver, the <code class="language-plaintext highlighter-rouge">ownerOf</code> method will behave the same as in ERC-721.</p>

<h2 id="test-cases">Test Cases</h2>

<p>Tests are included in <a href="../assets/eip-7401/test/nestable.ts"><code class="language-plaintext highlighter-rouge">nestable.ts</code></a>.</p>

<p>To run them in terminal, you can use the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ../assets/eip-7401
npm install
npx hardhat test
</code></pre></div></div>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>See <a href="../assets/eip-7401/contracts/NestableToken.sol"><code class="language-plaintext highlighter-rouge">NestableToken.sol</code></a>.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>The same security considerations as with <a href="./eip-721.md">ERC-721</a> apply: hidden logic may be present in any of the functions, including burn, add child, accept child, and more.</p>

<p>Since the current owner of the token is allowed to manage the token, there is a possibility that after the parent token is listed for sale, the seller might remove a child token just before before the sale and thus the buyer would not receive the expected child token. This is a risk that is inherent to the design of this standard. Marketplaces should take this into account and provide a way to verify the expected child tokens are present when the parent token is being sold or to guard against such a malicious behaviour in another way.</p>

<p>It is worth noting that <code class="language-plaintext highlighter-rouge">balanceOf</code> method only accounts for immediate tokens owned by the address; the tokens that are nested into a token owned by this address will not be reflected in this value as the recursive lookup needed in order to calculate this value is potentially too deep and might break the method.</p>

<p>Caution is advised when dealing with non-audited contracts.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
