<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>On-Demand Off-Chain Data Retrieval | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="On-Demand Off-Chain Data Retrieval | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-7412" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-7412" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">On-Demand Off-Chain Data Retrieval</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>Contracts may require off-chain data during execution. A smart contract function could implement the standard proposed here by reverting with <code class="language-plaintext highlighter-rouge">error OracleDataRequired(address oracleContract, bytes oracleQuery)</code>. Clients supporting this standard would recognize this error message during a simulation of the request, query the specified decentralized oracle network for signed data, and instead stage a transaction with a multicall that prepends the verification of the required off-chain data. The data would be written on-chain during verification to a smart contract for the subsequent call to read, avoiding the error.</p>

<h2 id="motivation">Motivation</h2>

<p>Ethereum’s scaling roadmap involves a series of separate execution contexts for smart contract code (including layer two and layer three scaling solutions). This makes the ability to read data across multiple chains crucial to the construction of scalable applications. Also, for decentralized finance protocols that rely on price data, it is not reasonable to expect oracle networks will be able to continuously push fresh data to every layer two and layer three network for an arbitrary number of price feeds.</p>

<p>Cross-chain bridges are being developed where smart contract functions can write data to other chains. There is a need for a similar standard that enables reading data from other chains. This standard can be generalized for reading any off-chain data from a decentralized oracle network, including price feeds.</p>

<p>With standards for both writing and reading cross-chain data, protocol developers will be able to create abstractions for asynchronicity (a topic thoroughly explored in other software engineering contexts). This will enable the development of highly sophisticated protocols that do not suffer from scaling constraints.</p>

<p><a href="./eip-3668.md">ERC-3668</a> introduced the use of reverts for requiring off-chain data, but there are various challenges introduced by the specifics of that standard which are outlined in the <em>Rationale</em> section below. By leveraging multicalls rather than callback functions, the standard proposed here is able to overcome some of these constraints.</p>

<h2 id="specification">Specification</h2>

<p>A contract implementing this standard MUST revert with the following error whenever off-chain data is required:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="n">OracleDataRequired</span><span class="p">(</span><span class="kt">address</span> <span class="n">oracleContract</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">oracleQuery</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">oracleQuery</code> specifies the off-chain data that is being required. Valid data formats for this parameter are specific to the oracle ID specified by the oracle contract. This might include chain id, contract address, function signature, payload, and timestamp/”latest” for cross-chain reads. For price feeds, it could include a ticker symbol and timestamp/”latest”.</p>

<p><code class="language-plaintext highlighter-rouge">oracleContract</code> is the address of the contract which can verify the off-chain data and provide it to the contract to avoid the <code class="language-plaintext highlighter-rouge">OracleDataRequired</code> error. This contract MUST implement the following interface:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">IERC7412</span> <span class="p">{</span>
  <span class="k">function</span> <span class="n">oracleId</span><span class="p">()</span> <span class="k">view</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="n">oracleId</span><span class="p">);</span>
  <span class="k">function</span> <span class="n">fulfillOracleQuery</span><span class="p">(</span><span class="kt">bytes</span> <span class="n">signedOffchainData</span><span class="p">)</span> <span class="k">payable</span> <span class="k">external</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">oracleId</code> is a unique identifier that references the decentralized oracle network that generates the desired signed off-chain data. Oracle IDs would be analogous to Chain IDs in the Ethereum ecosystem. Clients are expected to resolve a gateway that corresponds to an Oracle ID, similar to how clients are expected to resolve an RPC endpoint based on a Chain ID.</p>

<p>It should be possible to derive the <code class="language-plaintext highlighter-rouge">oracleQuery</code> from the <code class="language-plaintext highlighter-rouge">signedOffchainData</code>, such that the oracle contract is able to provide the verified offchain data based on the <code class="language-plaintext highlighter-rouge">oracleQuery</code>.</p>

<p>The contract implementing the <code class="language-plaintext highlighter-rouge">IERC7412</code> interface MUST revert with the following error message if it requires payment to fulfill the oracle data query:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span> <span class="n">FeeRequired</span><span class="p">(</span><span class="kt">uint</span> <span class="n">amount</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">amount</code> specifies the amount of native gas tokens required to execute the <code class="language-plaintext highlighter-rouge">fulfillOracleQuery</code> function, denominated in wei. This error MUST be resolved if the caller provides sufficient <code class="language-plaintext highlighter-rouge">msg.value</code> such that the fee amount can be collected by the oracle contract. The contract MAY NOT return gas tokens if they are provided in excess of the <code class="language-plaintext highlighter-rouge">amount</code>. In practice, we would expect the fee amount to remain relatively stable, if not constant.</p>

<p>It is the responsibility of the client to decide how to construct the multicall, where necessary the <code class="language-plaintext highlighter-rouge">fulfillOracleQuery</code> functions are being called before the intended function call in an atomic transaction. Wallets that support account abstraction (per <a href="./eip-4337.md">ERC-4337</a>) should already have the ability to generate atomic multi-operations. For EOA support, protocols could implement <a href="./eip-2771.md">ERC-2771</a>. A standard multicall contract can only be used to construct multicalls including functions which do not reference <code class="language-plaintext highlighter-rouge">msg.sender</code> or <code class="language-plaintext highlighter-rouge">msg.data</code>.</p>

<p>To prevent data becoming too stale for a request between the simulation and a call’s execution, ideally a contract could also emit the following event: <code class="language-plaintext highlighter-rouge">event OracleDataUsed(address oracleContract, bytes oracleQuery, uint expirationTime)</code> Here, <code class="language-plaintext highlighter-rouge">expirationTime</code> is the time after which the <code class="language-plaintext highlighter-rouge">OracleDataRequired</code> error would be thrown by the contract. (This would typically be a calculation involving a staleness tolerance and <code class="language-plaintext highlighter-rouge">block.timestamp</code>). Client applications that implement this standard would be able to recognize this event during simulation and estimate if an additional update will still be necessary, taking into account the speed of the chain. For example, the oracle query may request the latest quote available for a particular price feed and the expiration time may signal that the price cannot be older than three seconds prior to the current timestamp recognized by the blockchain. This has been omitted from the standard because there isn’t a practical way to retrieve event data during transaction simulations on most JSON-RPC APIs at this time.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">URI</code> could be used as the <code class="language-plaintext highlighter-rouge">oracleId</code> with a URI specified as the <code class="language-plaintext highlighter-rouge">oracleQuery</code>. This would allow this standard to be compliant with arbitrary on-chain URIs without requiring updates to a client library, similar to <a href="./eip-3668.md">ERC-3668</a>.</p>

<h2 id="rationale">Rationale</h2>

<p>This proposal is essentially an alternative to <a href="./eip-3668.md">ERC-3668</a> with a few important distinctions:</p>

<ul>
  <li>ERC-3668 requires URIs to be encoded on-chain. While this can work well for static assets (such as IPFS hashes for assets related to NFTs and merkle trees), it is not ideal for retrieving data that must be fresh like cross-chain data retrieval or price feeds. Although dynamic data can be referenced with an HTTP URL, this increases centralization and maintenance-related risks.</li>
  <li>By relying on a multicall rather than callbacks, it is much simpler to handle situations in which nested calls require different off-chain data. By the standard proposed here, end users (including those using clients that implement account abstraction) always need to simply sign a transaction, regardless of the complexity of the internal structure of the call being executed. The client can automatically prepend any necessary off-chain data to the transaction for the call to succeed.</li>
  <li>The error is very simple to construct. Developers implementing this standard only need to have awareness of the oracle network they choose to rely on, the form of the query accepted by this network, and the contract from which they expect to retrieve the data.</li>
</ul>

<p>With this standard, not only can oracle providers scalably support an unlimited number of networks but they can also be compatible with local/forked networks for protocol development.</p>

<p>Another major advantage of this standard is that oracles can charge fees in the form of native gas tokens during the on-chain verification of the data. This creates an economic incentive where fees can be collected from data consumers and provided to node operators in the decentralized oracle network.</p>

<h2 id="reference-implementation">Reference Implementation</h2>

<p>The following pseudocode illustrates an oversimplified version of the client SDK. Ideally, this could be implemented in wallets, but it could also be built into the application layer. This function takes a desired transaction and converts it into a multicall with the required data verification transactions prepended such that the <code class="language-plaintext highlighter-rouge">OracleDataRequired</code> errors would be avoided:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">prepareTransaction</span><span class="p">(</span><span class="nx">originalTx</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">multicallTx</span> <span class="o">=</span> <span class="p">[</span><span class="nx">originalTx</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">simulationResult</span> <span class="o">=</span> <span class="nx">simulateTx</span><span class="p">(</span><span class="nx">multicallTx</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">multicallTx</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">error</span> <span class="k">instanceof</span> <span class="nx">OracleDataRequired</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">signedRequiredData</span> <span class="o">=</span> <span class="nx">fetchOffchainData</span><span class="p">(</span>
          <span class="nx">error</span><span class="p">.</span><span class="nx">oracleContract</span><span class="p">,</span>
          <span class="nx">error</span><span class="p">.</span><span class="nx">oracleQuery</span>
        <span class="p">);</span>
        <span class="kd">const</span> <span class="nx">dataVerificationTx</span> <span class="o">=</span> <span class="nx">generateDataVerificationTx</span><span class="p">(</span>
          <span class="nx">error</span><span class="p">.</span><span class="nx">oracleContract</span><span class="p">,</span>
          <span class="nx">signedRequiredData</span>
        <span class="p">);</span>
        <span class="nx">multicallTx</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">dataVerificationTx</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>An oracle provider could create a contract (that might also perform some pre-processing) that would automatically trigger a request for off-chain data as follows:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">OracleContract</span> <span class="k">is</span> <span class="n">IERC7412</span> <span class="p">{</span>
  <span class="kt">address</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">VERIFIER_CONTRACT</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
  <span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">STALENESS_TOLERANCE</span> <span class="o">=</span> <span class="mi">86400</span><span class="p">;</span> <span class="c1">// One day
</span>  <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="kt">bytes</span><span class="p">)</span> <span class="k">public</span> <span class="n">latestVerifiedData</span><span class="p">;</span>

  <span class="k">function</span> <span class="n">oracleId</span><span class="p">()</span> <span class="k">external</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">){</span>
    <span class="k">return</span> <span class="kt">bytes32</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="s">"MY_ORACLE_ID"</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="n">fulfillOracleQuery</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">signedOffchainData</span><span class="p">)</span> <span class="k">payable</span> <span class="k">external</span> <span class="p">{</span>
    <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">oracleQuery</span> <span class="o">=</span> <span class="n">_verify</span><span class="p">(</span><span class="n">signedOffchainData</span><span class="p">);</span>
    <span class="n">latestVerifiedData</span><span class="p">[</span><span class="nb">keccak256</span><span class="p">(</span><span class="n">oracleQuery</span><span class="p">)]</span> <span class="o">=</span> <span class="n">signedOffchainData</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="n">retrieveCrossChainData</span><span class="p">(</span><span class="kt">uint</span> <span class="n">chainId</span><span class="p">,</span> <span class="kt">address</span> <span class="n">contractAddress</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">payload</span><span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">oracleQuery</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">chainId</span><span class="p">,</span> <span class="n">contractAddress</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">uint</span> <span class="n">timestamp</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">response</span><span class="p">)</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">latestVerifiedData</span><span class="p">[</span><span class="n">oracleQuery</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">bytes</span><span class="p">));</span>

    <span class="k">if</span><span class="p">(</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">block</span><span class="p">.</span><span class="n">timestamp</span> <span class="o">-</span> <span class="n">STALENESS_TOLERANCE</span><span class="p">){</span>
      <span class="nb">revert</span> <span class="n">OracleDataRequired</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">oracleQuery</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">function</span> <span class="n">_verify</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">signedOffchainData</span><span class="p">)</span> <span class="k">payable</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="n">oracleQuery</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Insert verification code here
</span>    <span class="c1">// This may revert with error FeeRequired(uint amount)
</span>  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Now a top-level protocol smart contract could implement a cross-chain function like so:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">interface</span> <span class="n">ICrosschainContract</span> <span class="p">{</span>
  <span class="k">function</span> <span class="n">functionA</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
  <span class="k">function</span> <span class="n">functionB</span><span class="p">(</span><span class="kt">uint</span> <span class="n">x</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">contract</span> <span class="n">CrosschainAdder</span> <span class="p">{</span>
  <span class="n">IERC7412</span> <span class="n">oracleContract</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>

  <span class="k">function</span> <span class="n">add</span><span class="p">(</span><span class="kt">uint</span> <span class="n">chainIdA</span><span class="p">,</span> <span class="kt">address</span> <span class="n">contractAddressA</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">chainIdB</span><span class="p">,</span> <span class="kt">address</span> <span class="n">contractAddressB</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">sum</span><span class="p">){</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">oracleContract</span><span class="p">.</span><span class="n">retrieveCrossChainData</span><span class="p">(</span><span class="n">chainIdA</span><span class="p">,</span> <span class="n">contractAddressA</span><span class="p">,</span> <span class="n">abi</span><span class="p">.</span><span class="n">encodeWithSelector</span><span class="p">(</span><span class="n">ICrosschainContract</span><span class="p">.</span><span class="n">functionA</span><span class="p">.</span><span class="nb">selector</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="kt">uint</span><span class="p">))</span> <span class="o">+</span> <span class="n">abi</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">oracleContract</span><span class="p">.</span><span class="n">retrieveCrossChainData</span><span class="p">(</span><span class="n">chainIdB</span><span class="p">,</span> <span class="n">contractAddressB</span><span class="p">,</span> <span class="n">abi</span><span class="p">.</span><span class="n">encodeWithSelector</span><span class="p">(</span><span class="n">ICrosschainContract</span><span class="p">.</span><span class="n">functionB</span><span class="p">.</span><span class="nb">selector</span><span class="p">,</span><span class="mi">2</span><span class="p">)),(</span><span class="kt">uint</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that the developer of the <code class="language-plaintext highlighter-rouge">CrosschainAdder</code> function does not need to be concerned with the implementation of this standard. The <code class="language-plaintext highlighter-rouge">add</code> function can simply call the function on the oracle contract as if it were retrieving on-chain data normally.</p>

<p>Cross-chain functions like this could also be leveraged to avoid O(n) (and greater) loops on-chain. For example, <code class="language-plaintext highlighter-rouge">chainIdA</code> and <code class="language-plaintext highlighter-rouge">chainIdB</code> could reference the same chain that the <code class="language-plaintext highlighter-rouge">CrosschainAdder</code> contract is deployed on with <code class="language-plaintext highlighter-rouge">functionA</code> and <code class="language-plaintext highlighter-rouge">functionB</code> as view functions with computationally intensive loops.</p>

<h2 id="security-considerations">Security Considerations</h2>

<p>One potential risk introduced by this standard is that its reliance on multicalls could obfuscate transaction data in wallet applications that do not have more sophisticated transaction decoding functionality. This is an existing challenge being addressed by wallet application developers, as multicalls are increasingly common in protocol development outside of this standard.</p>

<p>Note that it is the responsibility of the verifier contract to confirm the validity of the data provided from the oracle network. This standard does not create any new opportunities for invalid data to be provided to a smart contract.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
