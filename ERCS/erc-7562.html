<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Account Abstraction Validation Scope Rules | Ethereum Improvement Proposals</title>
    <meta
      property="og:title"
      content="Account Abstraction Validation Scope Rules | Ethereum Improvement Proposals"
    />
    <meta name="description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta property="og:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
    <meta name="twitter:description" content="Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards." />
  
  <meta name="generator" content="Jekyll" />
  <meta property="og:locale" content="en_US" />
  <link rel="canonical" href="http://localhost:4000/ERCS/erc-7562" />
  <meta property="og:url" content="http://localhost:4000/ERCS/erc-7562" />
  <meta property="og:site_name" content="Ethereum Improvement Proposals" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@" />
  <script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "http://localhost:4000",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
  <link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ethereum Improvement Proposals" /><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
  <link rel="stylesheet" href="/assets/css/override.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.min.js" integrity="sha384-Rx+T1VzGupg4BHQYs2gCW9It+akI2MM/mndMCy36UVfodzcJcF0GGLxZIzObiEfa" crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", (event) => {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    });
  </script>
  <script type="text/javascript">
    window.MathJax = {
      loader: {
        load: ['input/tex-base', 'output/chtml']
      },
      tex: {
        inlineMath: [['$', '$']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: false,
        processRefs: false
      }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js" integrity="sha384-/1zmJ1mBdfKIOnwPxpdG6yaRrxP6qu3eVYm0cz2nOx+AcL4d3AqEFrwcqGZVVroG" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/citation-js/0.6.7/citation.min.js" integrity="sha512-N+LDFMa9owHXGS+CyMrBvuxq2QuGl3fiB/7cys3aUEL7K6P1soHGqsS0sjHXZpwNd9Kz0m3R4IPy1HYRi6ROEQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="text/javascript">
    addEventListener('DOMContentLoaded', async () => {
      const Cite = window.require('citation-js');
      const citationElements = document.querySelectorAll('.language-csl-json');
      for (let citationElement of citationElements) {
        try {
          const citation = await Cite.async(citationElement);
          const template = document.createElement('template');
          template.innerHTML = citation.format('bibliography', {
            format: 'html',
            template: 'apa',
            lang: 'en-US'
          });
          if (citationElement.parentElement && citationElement.parentElement.matches('pre')) {
            citationElement.parentElement.replaceWith(template.content);
          } else {
            citationElement.replaceWith(template.content);
          }
        } catch (e) {
          console.error("unable to render citation", e);
        }
      }
    });
  </script>
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav d-flex">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger row p-2"><a class="page-link col" href="/all">All</a><a class="page-link col" href="/core">Core</a><a class="page-link col" href="/networking">Networking</a><a class="page-link col" href="/interface">Interface</a><a class="page-link col" href="/erc">ERC</a><a class="page-link col" href="/meta">Meta</a><a class="page-link col" href="/informational">Informational</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Account Abstraction Validation Scope Rules</h1>
  </header>

  <div class="post-content">
    <h2 id="abstract">Abstract</h2>

<p>This document describes the rules we impose on the validation context of Account Abstraction transactions,
such as <a href="./eip-4337.md">ERC-4337</a> <code class="language-plaintext highlighter-rouge">UserOperation</code> or RIP-7560 (Native Account Abstraction), which are enforced off-chain by a
block builder or a standalone bundler, and the rationale behind each one of them.</p>

<h2 id="motivation">Motivation</h2>

<p>With Account-Abstraction, instead of hard-coded logic for processing a transaction (validation, gas-payment, and execution), this logic is executed by EVM code.
The benefits for the account are countless -</p>
<ul>
  <li>abstracting the validation allows the contract to use different signature schemes, multisig configuration, custom recovery, and more.</li>
  <li>abstracting gas payments allows easy onboarding by 3rd party payments, paying with tokens, cross-chain gas payments</li>
  <li>abstracting execution allows batch transactions</li>
</ul>

<p>All of the above are missing from the EOA account model.</p>

<p>However, there is one rule a transaction must follow to preserve the decentralized network: once submitted into the network (the mempool), the transaction is guaranteed to pay. This comes to prevent denial of service attacks on the network.</p>

<p>The EOA model implicitly follows the rule: a valid transaction can’t become invalid without payment by the account: e.g account balance can’t be reduced (except with a higher paying transaction)</p>

<p>This simple rule makes the network sustainable and DoS-protected: the network can’t be cheaply attacked by a mass of transactions. An attack (sending a mass of transactions) is expensive, and gets more expensive as the network clogs. Legitimate users pay more, and can delay operations to avoid the cost, but the attacker pays a huge (and increasing) amount to keep the network clogged.</p>

<p>With Account Abstraction, however, the validation can also include an arbitrary EVM code and rely on storage as well, which means that unrelated <code class="language-plaintext highlighter-rouge">UserOperations</code> or transactions may invalidate each other, and thus mount a DoS attack.</p>

<p>The purpose of the following validation rules is to have the same trait so that attempting a DoS attack on the network should be as expensive.</p>

<p>For the actual interfaces of those contract-based accounts see the definitions in ERC-4337 and RIP-7560.</p>

<p>This documentation uses the terminology “UserOperation” for a transaction created by a smart contract account, and closely follows ERC-4337 terminology.
However, the rules apply to any account-abstraction framework that uses EVM code to perform transaction validation and makes a distinction between validation and execution.</p>

<h2 id="specification">Specification</h2>

<h3 id="rule-types">Rule Types</h3>

<p>There are two types of rules:</p>

<ul>
  <li><strong>Network-wide rules</strong> rules that MUST be applied to each UserOperation before accepting it into the local mempool and propagating it.
These rules include the opcode and storage rules.
    <ul>
      <li>Failing these validation rules SHOULD drop the UserOperation</li>
      <li>Failing these validations during 2nd validation phase (before submitting a bundle) SHOULD degrade
the reputation of the offending entity</li>
      <li>Bundler MUST NOT propagate UserOperations that fail the validation rules, otherwise
it will be considered a “spammer” by other bundlers in the mempool, and get disconnected.</li>
    </ul>
  </li>
  <li><strong>Local rules</strong>
These are “soft” rules, based on the reputation of entities.
These rules come to protect the bundler itself from spamming attacks.
    <ul>
      <li>Bundlers SHOULD drop such UserOperations without performing validation.</li>
      <li>Bundlers SHOULD NOT propagate such UserOperations to other bundlers.</li>
      <li>Bundlers SHOULD NOT consider another bundler a “spammer” if it does.</li>
    </ul>
  </li>
</ul>

<h3 id="constants">Constants</h3>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Value</th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MIN_UNSTAKE_DELAY</code></td>
      <td>86400</td>
      <td>1 day</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MIN_STAKE_VALUE</code></td>
      <td>Adjustable per chain value</td>
      <td>Equivalent to ~$1000 in native tokens</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SAME_SENDER_MEMPOOL_COUNT</code></td>
      <td>4</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT</code></td>
      <td>10</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_MEMPOOL_COUNT</code></td>
      <td>4</td>
      <td>Number of <code class="language-plaintext highlighter-rouge">UserOperations</code> with a throttled entity that can stay in the mempool</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_LIVE_BLOCKS</code></td>
      <td>10</td>
      <td>Number of blocks a <code class="language-plaintext highlighter-rouge">UserOperations</code> with a throttled entity can stay in mempool</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_BUNDLE_COUNT</code></td>
      <td>4</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MIN_INCLUSION_RATE_DENOMINATOR</code></td>
      <td>100 (client) \ 10 (bundler)</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">THROTTLING_SLACK</code></td>
      <td>10</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">BAN_SLACK</code></td>
      <td>50</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">BAN_OPS_SEEN_PENALTY</code></td>
      <td>10000</td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">MAX_OPS_ALLOWED_UNSTAKED_ENTITY</code></td>
      <td>10000</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="validation-rules">Validation Rules</h3>

<h3 id="definitions"><strong>Definitions</strong>:</h3>
<ol>
  <li><strong>Validation Phases</strong>: there are up to 3 phases of validation
    <ol>
      <li>smart account deployment</li>
      <li>smart account validation</li>
      <li>paymaster validation.</li>
    </ol>
  </li>
  <li><strong>Entity</strong>: a contract that is explicitly specified by the <code class="language-plaintext highlighter-rouge">UserOperation</code>.
Includes the <code class="language-plaintext highlighter-rouge">factory</code>, <code class="language-plaintext highlighter-rouge">paymaster</code>, <code class="language-plaintext highlighter-rouge">aggregator</code>, and staked <code class="language-plaintext highlighter-rouge">account</code>, as discussed below. <br />
Each “validation phase” is attributed to a single entity. <br />
Entity contracts must have non-empty code on-chain.</li>
  <li><strong>Canonical Mempool</strong>: The rules defined in this document apply to the main mempool shared by all bundlers on the network.</li>
  <li><strong>Staked Entity:</strong> an entity that has a locked stake of at least <code class="language-plaintext highlighter-rouge">MIN_STAKE_VALUE</code>
and an unstake delay of at least <code class="language-plaintext highlighter-rouge">MIN_UNSTAKE_DELAY</code>.</li>
  <li><strong>Associated storage:</strong> a storage slot of any smart contract is considered to be “associated” with address <code class="language-plaintext highlighter-rouge">A</code> if:
    <ol>
      <li>The slot value is <code class="language-plaintext highlighter-rouge">A</code></li>
      <li>The slot value was calculated as <code class="language-plaintext highlighter-rouge">keccak(A||x)+n</code>, where <code class="language-plaintext highlighter-rouge">x</code> is a <code class="language-plaintext highlighter-rouge">bytes32</code> value, and <code class="language-plaintext highlighter-rouge">n</code> is a value in the range 0..128</li>
    </ol>
  </li>
  <li><strong>Using an address</strong>: accessing the code of a given address in any way.
This can be done by executing <code class="language-plaintext highlighter-rouge">*CALL</code> or <code class="language-plaintext highlighter-rouge">EXTCODE*</code> opcodes for a given address.</li>
</ol>

<h3 id="reputation-definitions">Reputation Definitions</h3>
<ol>
  <li>
    <p><strong>opsSeen</strong>: a per-entity counter of how many times a unique valid <code class="language-plaintext highlighter-rouge">UserOperation</code> referencing this entity
was received by this bundler.
This includes <code class="language-plaintext highlighter-rouge">UserOperation</code> received via incoming RPC calls or through a P2P mempool protocol.</p>
  </li>
  <li><strong>opsIncluded</strong>: a per-entity counter of how many times a unique valid <code class="language-plaintext highlighter-rouge">UserOperation</code> referencing this entity
appeared in an actual included <code class="language-plaintext highlighter-rouge">UserOperation</code>. <br />
Calculation of this value is based on UserOperationEvents and is only counted for <code class="language-plaintext highlighter-rouge">UserOperations</code> that were
previously counted as <code class="language-plaintext highlighter-rouge">opsSeen</code> by this bundler.</li>
  <li>Both values are updated every hour as <code class="language-plaintext highlighter-rouge">value = value * 23 // 24</code> <br />
Effectively, the value is reduced to 1% after 4 days.</li>
  <li><strong>inclusionRate</strong>: Relation of <code class="language-plaintext highlighter-rouge">opsIncluded</code>  to <code class="language-plaintext highlighter-rouge">opsSeen</code></li>
</ol>

<h3 id="reputation-calculation">Reputation Calculation</h3>

<p>We define a value <code class="language-plaintext highlighter-rouge">max_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR</code>.</p>

<p>The reputation state of each entity is determined as follows:</p>

<ol>
  <li><strong>BANNED</strong>: <code class="language-plaintext highlighter-rouge">max_seen &gt; opsIncluded + BAN_SLACK</code></li>
  <li><strong>THROTTLED</strong>: <code class="language-plaintext highlighter-rouge">max_seen &gt; opsIncluded + THROTTLING_SLACK</code></li>
  <li><strong>OK</strong>: otherwise</li>
</ol>

<p>Note that new entities start with an <code class="language-plaintext highlighter-rouge">OK</code> reputation.</p>

<p>To help make sense of these parameters, note that a malicious paymaster can at most cause the network (only the P2P network, not the blockchain) to process <code class="language-plaintext highlighter-rouge">BAN_SLACK * MIN_INCLUSION_RATE_DENOMINATOR / 24</code> non-paying ops per hour.</p>

<h3 id="the-processing-flow-of-a-useroperation">The processing flow of a UserOperation</h3>

<ul>
  <li>First, a UserOperation is received - either via RPC (submitted on behalf of a single application) or via the p2p protocol, from another node in the mempool.</li>
  <li>The node performs validation on the UserOperation, and then adds it to its in-memory mempool, and submits it to its peers.</li>
  <li>Lastly, when building a block, a node collects UserOperations from the mempool, performs a 2nd validation to make sure they are all still valid as a bundle and submits them into the next block.</li>
</ul>

<h3 id="running-the-validation-rules">Running the Validation Rules</h3>

<ol>
  <li>A block builder or a bundler should perform a full validation before accepting a <code class="language-plaintext highlighter-rouge">UserOperation</code> into its mempool.</li>
  <li>During the validation phase, the bundler should trace the execution and apply all the rules defined in this document.</li>
  <li>A bundler should also perform a full validation of the entire bundle before submission.</li>
  <li>The validation rules prevent an unstaked entity from detecting the bundle validation.
However, a malicious staked entity can detect that it is running in a bundle validation and cause a revert.</li>
  <li>The failed <code class="language-plaintext highlighter-rouge">UserOperation</code> should be dropped from the bundle.</li>
  <li>The staked entity that caused a revert violated the Account Abstraction rules and should be marked as <code class="language-plaintext highlighter-rouge">THROTTLED</code>.</li>
</ol>

<h3 id="mempool-validation-rules">Mempool Validation Rules</h3>

<ol>
  <li>A <code class="language-plaintext highlighter-rouge">UserOperation</code> is broadcast over the P2P protocol with the following information:
    <ol>
      <li>The <code class="language-plaintext highlighter-rouge">UserOperation</code> itself</li>
      <li>The blockhash this <code class="language-plaintext highlighter-rouge">UserOperation</code> was originally verified against.</li>
    </ol>
  </li>
  <li>Once a <code class="language-plaintext highlighter-rouge">UserOperation</code> is received from another bundler it should be verified locally by a receiving bundler.</li>
  <li>A received <code class="language-plaintext highlighter-rouge">UserOperation</code> may fail any of the reasonable static checks, such as: <br />
invalid format, values below minimum, submitted with a blockhash that isn’t recent, etc. <br />
In this case, the bundler should drop this particular <code class="language-plaintext highlighter-rouge">UserOperation</code> but keep the connection.</li>
  <li>The bundler should check the <code class="language-plaintext highlighter-rouge">UserOperation</code> against the nonces of last-included bundles. <br />
Silently drop <code class="language-plaintext highlighter-rouge">UserOperations</code> with <code class="language-plaintext highlighter-rouge">nonce</code> that was recently included.
This invalidation is likely attributable to a network race condition and should not cause a reputation change.</li>
  <li>If a received <code class="language-plaintext highlighter-rouge">UserOperation</code> fails against the current block:
    <ol>
      <li>Retry the validation against the block the <code class="language-plaintext highlighter-rouge">UserOperation</code> was originally verified against.</li>
      <li>If it succeeds, silently drop the <code class="language-plaintext highlighter-rouge">UserOperation</code> and keep the connection.</li>
      <li>If it fails, mark the sender as a “spammer”</li>
    </ol>
  </li>
</ol>

<h3 id="opcode-rules">Opcode Rules</h3>
<ul>
  <li>Block access from opcodes that access information outside of storage and code (aka “environment”).
    <ul>
      <li><strong>[OP-011]</strong> Blocked Opcodes:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">BALANCE</code> (<code class="language-plaintext highlighter-rouge">0x31</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">ORIGIN</code> (<code class="language-plaintext highlighter-rouge">0x32</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">GASPRICE</code> (<code class="language-plaintext highlighter-rouge">0x3A</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">BLOCKHASH</code> (<code class="language-plaintext highlighter-rouge">0x40</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">COINBASE</code> (<code class="language-plaintext highlighter-rouge">0x41</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">TIMESTAMP</code> (<code class="language-plaintext highlighter-rouge">0x42</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">NUMBER</code> (<code class="language-plaintext highlighter-rouge">0x43</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">PREVRANDAO</code>/<code class="language-plaintext highlighter-rouge">DIFFICULTY</code> (<code class="language-plaintext highlighter-rouge">0x44</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">GASLIMIT</code> (<code class="language-plaintext highlighter-rouge">0x45</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">SELFBALANCE</code> (<code class="language-plaintext highlighter-rouge">0x47</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">BASEFEE</code> (<code class="language-plaintext highlighter-rouge">0x48</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">GAS</code> (<code class="language-plaintext highlighter-rouge">0x5A</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">CREATE</code> (<code class="language-plaintext highlighter-rouge">0xF0</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">INVALID</code> (<code class="language-plaintext highlighter-rouge">0xFE</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">SELFDESTRUCT</code> (<code class="language-plaintext highlighter-rouge">0xFF</code>)</li>
        </ul>
      </li>
      <li><strong>[OP-012]</strong> <code class="language-plaintext highlighter-rouge">GAS </code>opcode is allowed, but only if followed immediately by <code class="language-plaintext highlighter-rouge">*CALL</code> instructions.<br />
This is a common way to pass all remaining gas to an external call, and it means that the actual value is
consumed from the stack immediately and cannot be accessed by any other opcode.</li>
      <li><strong>[OP-13]</strong> any “unassigned” opcode.</li>
    </ul>
  </li>
  <li><strong>[OP-020]</strong> Revert on “out of gas” is forbidden as it can “leak” the gas limit or the current call stack depth.</li>
  <li>Contract creation:
    <ul>
      <li><strong>[OP-031]</strong> <code class="language-plaintext highlighter-rouge">CREATE2</code> is allowed exactly once in the deployment phase and must deploy code for the “sender” address.</li>
    </ul>
  </li>
  <li>Access to an address without a deployed code is forbidden:
    <ul>
      <li><strong>[OP-041]</strong> For <code class="language-plaintext highlighter-rouge">EXTCODE*</code> and <code class="language-plaintext highlighter-rouge">*CALL</code> opcodes.</li>
      <li><strong>[OP-042]</strong> Exception: access to the “sender” address is allowed.
This is only possible in <code class="language-plaintext highlighter-rouge">factory</code> code during the deployment phase.</li>
    </ul>
  </li>
  <li>Allowed access to the <code class="language-plaintext highlighter-rouge">EntryPoint</code> address:
    <ul>
      <li><strong>[OP-051]</strong> May call <code class="language-plaintext highlighter-rouge">EXTCODESIZE ISZERO</code><br />
This pattern is used to check destination has a code before the <code class="language-plaintext highlighter-rouge">depositTo</code> function is called.</li>
      <li><strong>[OP-052]</strong> May call <code class="language-plaintext highlighter-rouge">depositTo(sender)</code> with any value from either the <code class="language-plaintext highlighter-rouge">sender</code> or <code class="language-plaintext highlighter-rouge">factory</code>.</li>
      <li><strong>[OP-053]</strong> May call the fallback function from the <code class="language-plaintext highlighter-rouge">sender</code> with any value.</li>
      <li><strong>[OP-054]</strong> Any other access to the <code class="language-plaintext highlighter-rouge">EntryPoint</code> is forbidden.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">*CALL</code> opcodes:
    <ul>
      <li><strong>[OP-061]</strong> <code class="language-plaintext highlighter-rouge">CALL</code> with <code class="language-plaintext highlighter-rouge">value</code> is forbidden. The only exception is a call to the <code class="language-plaintext highlighter-rouge">EntryPoint</code> described above.</li>
      <li><strong>[OP-062]</strong> Precompiles:
        <ul>
          <li>Only allow known accepted precompiles on the network, that do not access anything in the blockchain state or environment.</li>
          <li>The core precompiles 0x1 .. 0x9</li>
          <li>The <a href="./eip-7212.md">EIP-7212</a> sec256r1 precompile, on networks that accepted it.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>[OP-070]</strong> Transient (<a href="./eip-1153.md">EIP-1153</a>) opcodes <code class="language-plaintext highlighter-rouge">TLOAD</code> (<code class="language-plaintext highlighter-rouge">0x5c</code>) and <code class="language-plaintext highlighter-rouge">TSTORE</code> (<code class="language-plaintext highlighter-rouge">0x5d</code>)
are treated exactly like persistent storage (SLOAD/SSTORE).<br />
(on networks that don’t support EIP-1153, these opcodes are equivalent to INVALID)</li>
</ul>

<h3 id="code-rules">Code Rules</h3>

<ul>
  <li><strong>[COD-010]</strong> Between the first and the second validations, the <code class="language-plaintext highlighter-rouge">EXTCODEHASH</code> value of any visited address,
entity, or referenced library, may not be changed.<br />
If the code is modified, the UserOperation is considered invalid.</li>
</ul>

<h3 id="storage-rules">Storage Rules</h3>

<p>The permanent storage access with <code class="language-plaintext highlighter-rouge">SLOAD</code> and <code class="language-plaintext highlighter-rouge">SSTORE</code> instructions within each phase is limited as follows:</p>

<ul>
  <li><strong>[STO-010]</strong> Access to the “account” storage is always allowed.</li>
  <li>Access to associated storage of the account in an external (non-entity) contract is allowed if either:
    <ul>
      <li><strong>[STO-021]</strong>  The account already exists.</li>
      <li><strong>[STO-022]</strong>  There is an <code class="language-plaintext highlighter-rouge">initCode</code> and the <code class="language-plaintext highlighter-rouge">factory</code> contract is staked.</li>
    </ul>
  </li>
  <li>If the entity (<code class="language-plaintext highlighter-rouge">paymaster</code>, <code class="language-plaintext highlighter-rouge">factory</code>) is staked, then it is also allowed:
    <ul>
      <li><strong>[STO-031]</strong> Access the entity’s own storage.</li>
      <li><strong>[STO-032]</strong> Read/Write Access to storage slots that are associated with the entity, in any non-entity contract.</li>
      <li><strong>[STO-033]</strong> Read-only access to any storage in non-entity contract.</li>
    </ul>
  </li>
</ul>

<h3 id="local-rules">Local Rules</h3>

<p>Local storage rules protect the bundler against denial of service at the time of bundling. They do not affect mempool propagation and cannot cause a bundler to be marked as a “spammer”.</p>
<ul>
  <li><strong>[STO-040]</strong> <code class="language-plaintext highlighter-rouge">UserOperation</code> may not use an entity address (<code class="language-plaintext highlighter-rouge">factory</code>/<code class="language-plaintext highlighter-rouge">paymaster</code>/<code class="language-plaintext highlighter-rouge">aggregator</code>) that is used as an “account” in another <code class="language-plaintext highlighter-rouge">UserOperation</code> in the mempool. <br />
This means that <code class="language-plaintext highlighter-rouge">Paymaster</code> and <code class="language-plaintext highlighter-rouge">Factory</code> contracts cannot practically be an “account” contract as well.</li>
  <li><strong>[STO-041]</strong> <code class="language-plaintext highlighter-rouge">UserOperation</code> may not use associated storage (of either its account or from staked entity) in a contract that is a “sender” of another UserOperation in the mempool.</li>
</ul>

<h3 id="general-reputation-rules">General Reputation Rules</h3>

<p>The following reputation rules apply for all staked entities, and for unstaked paymasters. All rules apply to all of these entities unless specified otherwise.</p>

<ul>
  <li><strong>[GREP-010]</strong> A <code class="language-plaintext highlighter-rouge">BANNED</code> address is not allowed into the mempool.<br />
Also, all existing <code class="language-plaintext highlighter-rouge">UserOperations</code> referencing this address are removed from the mempool.</li>
  <li><strong>[GREP-020]</strong> A <code class="language-plaintext highlighter-rouge">THROTTLED</code> address is limited to:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_MEMPOOL_COUNT</code> entries in the mempool.</li>
      <li><code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_BUNDLE_COUNT</code> <code class="language-plaintext highlighter-rouge">UserOperations</code> in a bundle.</li>
      <li>Can remain in the mempool only for <code class="language-plaintext highlighter-rouge">THROTTLED_ENTITY_LIVE_BLOCKS</code>.</li>
    </ul>
  </li>
  <li><strong>[GREP-040]</strong> If an entity fails the bundle creation after passing second validation, its <code class="language-plaintext highlighter-rouge">opsSeen</code> set to <code class="language-plaintext highlighter-rouge">BAN_OPS_SEEN_PENALTY</code>, and <code class="language-plaintext highlighter-rouge">opsIncluded</code> to zero, causing it to be <code class="language-plaintext highlighter-rouge">BANNED</code>.</li>
</ul>

<h3 id="staked-entities-reputation-rules">Staked Entities Reputation Rules</h3>

<ul>
  <li><strong>[SREP-010]</strong> The “canonical mempool” defines a staked entity if it has <code class="language-plaintext highlighter-rouge">MIN_STAKE_VALUE</code> and unstake delay of <code class="language-plaintext highlighter-rouge">MIN_UNSTAKE_DELAY</code></li>
  <li><strong>[SREP-020]</strong> An <code class="language-plaintext highlighter-rouge">OK</code> staked entity is unlimited by the reputation rule.
    <ul>
      <li>Allowed in unlimited numbers in the mempool.</li>
      <li>Allowed in unlimited numbers in a bundle.</li>
    </ul>
  </li>
</ul>

<h3 id="entity-specific-rules">Entity-specific Rules</h3>

<ul>
  <li><strong>[EREP-010]</strong> For each <code class="language-plaintext highlighter-rouge">paymaster</code>, the mempool must maintain the total gas <code class="language-plaintext highlighter-rouge">UserOperations</code> using this <code class="language-plaintext highlighter-rouge">paymaster</code> may consume.
    <ul>
      <li>Do not add a <code class="language-plaintext highlighter-rouge">UserOperation</code> to the mempool if the maximum total gas cost, including the new <code class="language-plaintext highlighter-rouge">UserOperation</code>, is above the deposit of the <code class="language-plaintext highlighter-rouge">paymaster</code> at the current gas price.</li>
    </ul>
  </li>
  <li><strong>[EREP-015]</strong> A <code class="language-plaintext highlighter-rouge">paymaster</code> should not have its opsSeen incremented on failure of factory or account
    <ul>
      <li>When running 2nd validation (before inclusion in a bundle), if a UserOperation fails because of factory or account error (either a FailOp revert or validation rule), then the paymaster’s opsSeen valid is decremented by 1.</li>
    </ul>
  </li>
  <li><strong>[EREP-020]</strong> A staked factory is “accountable” for account breaking the rules. <br />
That is, if the <code class="language-plaintext highlighter-rouge">validateUserOp()</code> is rejected for any reason in a <code class="language-plaintext highlighter-rouge">UserOperation</code> that has an <code class="language-plaintext highlighter-rouge">initCode</code>, it is treated as if the factory caused this failure, and thus this affects its reputation.</li>
  <li><strong>[EREP-030]</strong> A Staked Account is accountable for failures in other entities (<code class="language-plaintext highlighter-rouge">paymaster</code>, <code class="language-plaintext highlighter-rouge">aggregator</code>) even if they are staked.</li>
  <li><strong>[EREP-040]</strong> An <code class="language-plaintext highlighter-rouge">aggregator</code> must be staked, regardless of storage usage.</li>
</ul>

<h3 id="unstaked-paymasters-reputation-rules">Unstaked Paymasters Reputation Rules</h3>

<ul>
  <li>Definitions:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">opsSeen</code>, <code class="language-plaintext highlighter-rouge">opsIncluded</code>, and reputation calculation</strong> are defined above.</li>
      <li><code class="language-plaintext highlighter-rouge">UnstakedReputation</code> of an entity determines the maximum number of entries using this entity allowed in the mempool.</li>
      <li><code class="language-plaintext highlighter-rouge">opsAllowed</code> is a reputation-based calculation for an unstaked entity, representing how many <code class="language-plaintext highlighter-rouge">UserOperations</code> it is allowed to have in the mempool.</li>
      <li>Rules:
        <ul>
          <li><strong>[UREP-010]</strong> An unstaked sender is only allowed to have <code class="language-plaintext highlighter-rouge">SAME_SENDER_MEMPOOL_COUNT</code> <code class="language-plaintext highlighter-rouge">UserOperation</code>s  in the mempool. A staked sender is only limited by the SREP rules.</li>
          <li><strong>[UREP-020]</strong> For an unstaked paymaster only that is not throttled/banned: <br />
<code class="language-plaintext highlighter-rouge">opsAllowed = SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT + inclusionRate * min(opsIncluded, MAX_OPS_ALLOWED_UNSTAKED_ENTITY)</code>.</li>
          <li>This is a default of <code class="language-plaintext highlighter-rouge">SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT</code> for new entity</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="alt-mempools-rules">Alt-mempools Rules</h3>

<p>Alternate mempool is an agreed-upon rule that the bundlers may opt into, in addition to the canonical mempool
The alt-mempool “topic” is a unique identifier. By convention, this is the IPFS hash of the document describing (in clear test and YAML file) the specifics of this alt mempool</p>

<ul>
  <li><strong>[ALT-010]</strong> The bundler listens to the alt-mempool “topic” over the P2P protocol</li>
  <li><strong>[ALT-020]</strong> The alt mempool rules MUST be checked only when a canonical rule is violated
    <ul>
      <li>That is, if validation follows the canonical rules above, it is not considered part of an alt-mempool.</li>
    </ul>
  </li>
  <li><strong>[ALT-021]</strong> Such a <code class="language-plaintext highlighter-rouge">UserOperation</code> (that violates the canonical rules) is checked against all the “alternate mempools”, and is considered part of all those alt-mempools</li>
  <li><strong>[ALT-030]</strong> Bundlers SHOULD forward <code class="language-plaintext highlighter-rouge">UserOperations</code> to other bundlers only once, regardless of how many (shared) alt-mempools they have. <br />
The receiving bundler validates the <code class="language-plaintext highlighter-rouge">UserOperations</code>, and based on the above rules (and subscribed alt-mempools) decides which alt-mempools to propagate it to.</li>
  <li><strong>[ALT-040]</strong> opsInclude and opsSeen of entities are kept per alt-mempool. That is, an entity can be considered throttled (or banned) in one mempool, while still active on another.</li>
</ul>

<h3 id="alt-mempool-reputation">Alt-mempool Reputation</h3>

<p>Alt-mempools are served by the same bundlers participating in the canonical mempool, but change the rules and may introduce denial-of-service attack vectors. To prevent them from taking the canonical mempool or other alt mempools down with them, a reputation is managed for each. An alt mempool that causes too many invalidations gets throttled. This limits the scope of the attack and lets the bundler continue doing its work for other mempools.</p>

<ul>
  <li><strong>[AREP-010]</strong> each alt-mempool manages “opsSeen” and “opsIncluded”, much like entities. The opsSeen is incremented after <code class="language-plaintext highlighter-rouge">UserOperation</code> initial validation, where it is considered part of this mempool.
  The “opsIncluded” is incremented after this UserOperation is included on-chain (either by this bundler, or another)</li>
  <li><strong>[AREP-020]</strong> the alt-mempool becomes THROTTLED based on the <a href="#reputation-calculation">Reputation Calculation</a></li>
</ul>

<h2 id="rationale">Rationale</h2>

<h3 id="the-high-level-goal">The high-level goal</h3>

<p>The purpose of this specification is to define a consensus between nodes (bundlers or block-builders) when processing incoming UserOperations from an external source.
This external source for UserOperations is either an end-user node (via RPC) or another node in the p2p network.</p>

<p>The protocol tries to detect “spam” - which are large bursts of UserOperations that cannot be included on-chain (and thus can’t pay).
The network is protected by throttling down requests from such spammer nodes.</p>

<p>All nodes in the network must have the same definition of “spam”: otherwise, if some nodes accept some type of UserOperations and propagate them while others consider them spam, those “forgiving” nodes will be considered “spammers” by the rest of the nodes, and the network effectively gets split.</p>

<h3 id="the-need-for-2nd-validation-before-submitting-a-block">The need for 2nd validation before submitting a block</h3>

<p>A normal Ethereum transaction in the mempool can be invalidated if another transaction was received with the same nonce. That other transaction had to increase the gas price in order to replace the first one, so it satisfied the rule of “must pay to get included into the mempool”
With contract-based accounts, since the UserOperation validity may depend on mutable state, other transactions may invalidate a previously valid UserOperation, so we must check it before inclusion</p>

<h3 id="rationale-of-limiting-opcodes">Rationale of limiting opcodes</h3>

<ul>
  <li>the validation is performed off-chain, before creating a block. Some opcodes access information that is known only when creating the block.</li>
  <li>using those opcodes while validating a transaction can easily create a validation rule that will succeed off-chain, but always revert on-chain, and thus cause a DoS attack.</li>
  <li>a simple example is <code class="language-plaintext highlighter-rouge">require block.number==12345</code>. It can be valid when validating the UserOperation and adding it to the mempool
but will be invalid when attempting to include it on-chain at a later block.</li>
</ul>

<h3 id="rationale-for-limiting-storage-access">Rationale for limiting storage access</h3>

<ul>
  <li>We need UserOperation validations not to overlap so that a single storage change can’t easily invalidate a large number of UserOperations in the mempool. By limiting UserOperations to access storage associated with the account itself, we know that we can for sure include a single UserOperation for each account in a bundle</li>
  <li>(A bundler MAY include more than one UserOperation of an account in a bundle, MUST first validate them together)</li>
</ul>

<h3 id="rationale-of-requiring-a-stake">Rationale of requiring a stake</h3>

<p>We want to be able to allow globally-used contracts (paymasters, factories) to use storage not associated with the account, but still prevent them from
spamming the mempool.
If a contract causes too many UserOperations to fail in their second validation after succeeding in their first, we can throttle its use in the mempool.
By requiring such a contract to have a stake, we prevent a “Sybil attack”, by making it expensive to create a large number of such paymasters to continue the spam attack.</p>

<p>By following the validation rules, we can detect contracts that cause spam UserOperations, and throttle them.
The stake comes to prevent the fast re-creation of malicious entities.
The stake is never slashed (since it is only used for off-chain detection) but is locked for a period of time, which makes such an attack much more expensive.</p>

<h3 id="definition-of-the-mass-invalidation-attack">Definition of the <code class="language-plaintext highlighter-rouge">mass invalidation attack</code></h3>

<p>A possible set of actions is considered to be a <code class="language-plaintext highlighter-rouge">mass invalidation attack</code> on the network if a large number of
<code class="language-plaintext highlighter-rouge">UserOperations</code> that did pass the initial validation and were accepted by nodes and propagated further into the
mempool to other bundlers in the network becomes invalid and not eligible for inclusion in a block.</p>

<p>There are 3 ways to perform such an attack:</p>

<ol>
  <li>Submit <code class="language-plaintext highlighter-rouge">UserOperation</code>s that pass the initial validation, but later fail the re-validation
that is performed during the bundle creation.</li>
  <li>Submit <code class="language-plaintext highlighter-rouge">UserOperation</code>s that are valid in isolation during validation, but when bundled
together become invalid.</li>
  <li>Submit valid <code class="language-plaintext highlighter-rouge">UserOperation</code>s but “front-run” them by executing a state change on the
network that causes them to become invalid. The “front-run” in question must be economically viable.</li>
</ol>

<p>To prevent such attacks, we attempt to “sandbox” the validation code.
We isolate the validation code from other <code class="language-plaintext highlighter-rouge">UserOperations</code>, from external changes to the storage, and
from information about the environment such as a current block timestamp.</p>

<h3 id="what-is-not-considered-a-mass-invalidation-attack">What is not considered a <code class="language-plaintext highlighter-rouge">mass invalidation attack</code></h3>

<p>A <code class="language-plaintext highlighter-rouge">UserOperation</code> that fails the initial validation by a receiving node without entering its mempool is not
considered an attack. The node is expected to apply web2 security measures and throttle requests based on API key,
source IP address, etc.
RPC nodes already do that to prevent being spammed with invalid transactions which also have a validation cost.
P2P nodes already have (and should apply) a scoring mechanism to determine spammer nodes.</p>

<p>Also, if the invalidation of <code class="language-plaintext highlighter-rouge">N</code> UserOperations from the mempool costs <code class="language-plaintext highlighter-rouge">N*X</code> with a sufficiently large <code class="language-plaintext highlighter-rouge">X</code>, it is not considered an economically viable attack.</p>

<ul>
  <li>The minimum change to cause an invalidation is a storage change (5k gas)</li>
  <li>Assuming a Node can sustain processing 2000 invalid UserOps per block, the cost of a DoS attack is 10M gas per block.</li>
  <li>The above value is high, but we take further measures to make such an attack more expensive.</li>
</ul>

<h2 id="security-considerations">Security Considerations</h2>

<p>This document describes the security considerations bundlers must take to protect themselves (and the entire mempool network)
from denial-of-service attacks.</p>

<h2 id="copyright">Copyright</h2>

<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ethereum Improvement Proposals</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ethereum Improvement Proposals</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
